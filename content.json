[{"title":"Android 调试桥 (adb)","date":"2020-11-30T06:48:56.000Z","path":"2020/11/30/Android-调试桥-adb/","text":"Android 调试桥 (adb)1- 基本用法 1.1- 命令语法 adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s ] 这一部分，直接使用 adb 。 如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;**serialNumber**&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s 参数，serialNumber 可以通过 adb devices 命令获取 1.2- 启动/停止 启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 1.3- 查看 adb 版本 1adb version 示例输出： 1234apple@fenglolodeMacBook-Pro ~ % adb devices -lList of devices attached8b112f28 device usb:336658432X product:virgo model:MI_NOTE_LTE device:virgo transport_id:3 1.4- 以 root 权限运行 adbd adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 1.5- 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 2- 设备连接管理 2.1- 查询已连接设备/模拟器 命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 3- 应用管理 3.1- 查看应用列表 查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：| 参数 | 显示列表 ||–|–|| 无 | 所有应用 || -f| 显示应用关联的 apk 文件 || -d | 只显示 disabled 的应用|| -e | 只显示 enabled 的应用 || -s | 只显示系统应用 || -3 | 只显示第三方应用 || -i | 显示应用的 installer || -u | 包含已卸载应用 || &lt;**FILTER**&gt; | 包名包含 &lt;**FILTER**&gt; 字符串 | 所有应用 命令： 1adb shell pm list packages 系统应用 命令： 1adb shell pm list packages -s 第三方应用 命令： 1adb shell pm list packages -3 3.2- 安装 APK 命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=”true” 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 3.3- 卸载应用 命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;**packagename**&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 3.4- 清除应用数据与缓存 命令： 1adb shell pm clear &lt;packagename&gt; &lt;**packagename**&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 3.5- 查看应用详细信息 命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;**packagename**&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268Activity Resolver Table: Schemes: ytmbank: 67a95af com.zjrc.cba/com.yitong.mobile.biz.launcher.app.SplashActivity Non-Data Actions: android.intent.action.MAIN: 67a95af com.zjrc.cba/com.yitong.mobile.biz.launcher.app.SplashActivity cn.jiguang.privates.intent.PushActivity: 273dbc com.zjrc.cba/cn.jiguang.privates.push.ui.PushActivity cn.jiguang.privates.intent.JNotifyActivity: ecc145 com.zjrc.cba/cn.jiguang.privates.push.service.JNotifyActivityReceiver Resolver Table: Non-Data Actions: cn.jpush.android.intent.WakedReceiver: 80f809a com.zjrc.cba/.push.biz.PushWakedResultReceiver com.xiaomi.mipush.MESSAGE_ARRIVED: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.xiaomi.mipush.ERROR: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.huawei.android.push.intent.REGISTRATION: b0879a8 com.zjrc.cba/com.huawei.hms.support.api.push.PushReceiver android.net.conn.CONNECTIVITY_CHANGE: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver fd50c66 com.zjrc.cba/com.xiaomi.push.service.receivers.NetworkStatusReceiver com.huawei.intent.action.PUSH_DELAY_NOTIFY: 4618ba7 com.zjrc.cba/com.huawei.hms.support.api.push.PushMsgReceiver cn.jiguang.privates.intent.NOTIFICATION_RECEIVED_PROXY: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver com.zjrc.cba.config.action: 3f8854 com.zjrc.cba/.config.biz.ConfigReceiver com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver cn.jiguang.privates.intent.RECEIVE_MESSAGE: 31588f2 com.zjrc.cba/.push.biz.PushMessageReceiver com.huawei.android.push.intent.RECEIVE: b0879a8 com.zjrc.cba/com.huawei.hms.support.api.push.PushReceiver com.meizu.c2dm.intent.RECEIVE: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.vivo.pushclient.action.RECEIVE: d113b43 com.zjrc.cba/cn.jiguang.privates.push.vivo.receiver.VivoMessageReceiver com.meizu.cloud.pushservice.action.PUSH_SERVICE_START: 936d5c0 com.zjrc.cba/com.meizu.cloud.pushsdk.SystemReceiver com.meizu.flyme.push.intent.MESSAGE: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.meizu.c2dm.intent.REGISTRATION: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver android.intent.action.USER_PRESENT: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver com.xiaomi.push.PING_TIMER: 3f9b2f9 com.zjrc.cba/com.xiaomi.push.service.receivers.PingReceiver com.xiaomi.mipush.RECEIVE_MESSAGE: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.meizu.flyme.push.intent.REGISTER.FEEDBACK: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.huawei.intent.action.PUSH: 4618ba7 com.zjrc.cba/com.huawei.hms.support.api.push.PushMsgReceiverService Resolver Table: Non-Data Actions: com.huawei.push.msg.NOTIFY_MSG: b6f423e com.zjrc.cba/com.huawei.hms.support.api.push.service.HmsMsgService cn.jpush.android.intent.DaemonService: e82489f com.zjrc.cba/cn.jpush.android.service.DaemonService com.heytap.mcs.action.RECEIVE_MCS_MESSAGE: 9938dec com.zjrc.cba/cn.jiguang.privates.push.oppo.service.OppoHeytapService com.coloros.mcs.action.RECEIVE_MCS_MESSAGE: 99985b5 com.zjrc.cba/cn.jiguang.privates.push.oppo.service.OppoColorosService com.huawei.push.msg.PASSBY_MSG: b6f423e com.zjrc.cba/com.huawei.hms.support.api.push.service.HmsMsgService cn.jiguang.privates.intent.USER_SERVICE: c19444a com.zjrc.cba/.push.biz.PushService com.huawei.push.action.MESSAGING_EVENT: 4cccfbb com.zjrc.cba/cn.jiguang.privates.push.huawei.service.HuaweiMessageServicePermissions: Permission [com.zjrc.cba.permission.PROCESS_PUSH_MSG] (8219cd8): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;b29c831 com.zjrc.cba.permission.PROCESS_PUSH_MSG&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.PUSH_WRITE_PROVIDER] (b6eac97): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;a7fae84 com.zjrc.cba.permission.PUSH_WRITE_PROVIDER&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.push.permission.MESSAGE] (da1b66d): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;8be12a2 com.zjrc.cba.push.permission.MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.JPUSH_MESSAGE] (de77b33): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;f8b2ef0 com.zjrc.cba.permission.JPUSH_MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.C2D_MESSAGE] (4304c69): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;20eb6ee com.zjrc.cba.permission.C2D_MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.config.send] (614978f): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;48c4a1c com.zjrc.cba.config.send&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.MIPUSH_RECEIVE] (bf84625): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;3b353fa com.zjrc.cba.permission.MIPUSH_RECEIVE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.PUSH_PROVIDER] (44d1dab): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;121ec08 com.zjrc.cba.permission.PUSH_PROVIDER&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125;Registered ContentProviders: com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider: Provider&#123;78c1fa1 com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider&#125; com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider: Provider&#123;fd2b5c6 com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider&#125; com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider: Provider&#123;d3de987 com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider&#125; com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider: Provider&#123;5edc0b4 com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider&#125; com.zjrc.cba/cn.jpush.android.service.DownloadProvider: Provider&#123;62a14dd com.zjrc.cba/cn.jpush.android.service.DownloadProvider&#125; com.zjrc.cba/android.support.v4.content.FileProvider: Provider&#123;2346852 com.zjrc.cba/android.support.v4.content.FileProvider&#125; com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider: Provider&#123;9859723 com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider&#125; com.zjrc.cba/com.yitong.mobile.framework.utils.YTFileProvider: Provider&#123;a003420 com.zjrc.cba/com.yitong.mobile.framework.utils.YTFileProvider&#125;ContentProvider Authorities: [com.zjrc.cba.DownloadProvider]: Provider&#123;62a14dd com.zjrc.cba/cn.jpush.android.service.DownloadProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.miniprogram.provider]: Provider&#123;fd2b5c6 com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.hms.update.provider]: Provider&#123;78c1fa1 com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.huawei.push.provider]: Provider&#123;d3de987 com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.provider]: Provider&#123;2346852 com.zjrc.cba/android.support.v4.content.FileProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.AGCInitializeProvider]: Provider&#123;9859723 com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.DataProvider]: Provider&#123;5edc0b4 com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125;Key Set Manager: [com.zjrc.cba] Signing KeySets: 198Packages: Package [com.zjrc.cba] (2af5b16): userId=10091 pkg=Package&#123;98cb79e com.zjrc.cba&#125; codePath=/data/app/com.zjrc.cba-1 dexoptNeeded=false resourcePath=/data/app/com.zjrc.cba-1 legacyNativeLibraryDir=/data/app/com.zjrc.cba-1/lib primaryCpuAbi=armeabi-v7a secondaryCpuAbi=null versionCode=100 targetSdk=30 versionName=1.1.0 splits=[base] applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; flags=[ DEBUGGABLE HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] dataDir=/data/user/0/com.zjrc.cba supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-23 16:09:48 firstInstallTime=2020-11-23 16:10:03 lastUpdateTime=2020-11-23 16:10:03 signatures=PackageSignatures&#123;310827f [304724c]&#125; installPermissionsFixed=true installStatus=1 pkgFlags=[ DEBUGGABLE HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] declared permissions: com.zjrc.cba.config.send: prot=signature, INSTALLED com.zjrc.cba.permission.PROCESS_PUSH_MSG: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.PUSH_PROVIDER: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.PUSH_WRITE_PROVIDER: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.JPUSH_MESSAGE: prot=signature, INSTALLED com.zjrc.cba.push.permission.MESSAGE: prot=signature, INSTALLED com.zjrc.cba.permission.C2D_MESSAGE: prot=signature, INSTALLED com.zjrc.cba.permission.MIPUSH_RECEIVE: prot=signature, INSTALLED requested permissions: android.permission.READ_PHONE_STATE android.permission.ACCESS_NETWORK_STATE android.permission.INTERNET android.permission.WRITE_EXTERNAL_STORAGE android.permission.CALL_PHONE android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_WIFI_STATE android.permission.CHANGE_WIFI_STATE android.permission.ACCESS_COARSE_LOCATION android.permission.USE_FINGERPRINT android.permission.REQUEST_INSTALL_PACKAGES android.permission.VIBRATE android.permission.SYSTEM_ALERT_WINDOW android.permission.CAMERA android.permission.FLASHLIGHT android.permission.READ_CONTACTS android.permission.READ_EXTERNAL_STORAGE android.permission.GET_TASKS android.permission.RESTART_PACKAGES android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.WAKE_LOCK android.permission.RECEIVE_USER_PRESENT android.permission.MOUNT_UNMOUNT_FILESYSTEMS android.permission.ACCESS_BACKGROUND_LOCATION android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.READ_PRECISE_PHONE_STATE com.zjrc.cba.permission.PROCESS_PUSH_MSG com.zjrc.cba.permission.PUSH_PROVIDER com.huawei.appmarket.service.commondata.permission.GET_COMMON_DATA android.permission.WRITE_CONTACTS android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR com.zjrc.cba.permission.JPUSH_MESSAGE com.meizu.flyme.push.permission.RECEIVE com.zjrc.cba.push.permission.MESSAGE com.meizu.c2dm.permission.RECEIVE com.zjrc.cba.permission.C2D_MESSAGE com.coloros.mcs.permission.RECIEVE_MCS_MESSAGE com.heytap.mcs.permission.RECIEVE_MCS_MESSAGE com.zjrc.cba.permission.MIPUSH_RECEIVE install permissions: android.permission.RESTART_PACKAGES: granted=true com.zjrc.cba.permission.PROCESS_PUSH_MSG: granted=true com.zjrc.cba.push.permission.MESSAGE: granted=true android.permission.BLUETOOTH: granted=true android.permission.GET_TASKS: granted=true android.permission.INTERNET: granted=true com.zjrc.cba.permission.JPUSH_MESSAGE: granted=true android.permission.BLUETOOTH_ADMIN: granted=true com.zjrc.cba.permission.C2D_MESSAGE: granted=true com.zjrc.cba.permission.MIPUSH_RECEIVE: granted=true android.permission.ACCESS_LOCATION_EXTRA_COMMANDS: granted=true android.permission.CHANGE_WIFI_STATE: granted=true android.permission.FLASHLIGHT: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.USE_FINGERPRINT: granted=true com.zjrc.cba.permission.PUSH_PROVIDER: granted=true android.permission.VIBRATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true android.permission.REQUEST_INSTALL_PACKAGES: granted=true android.permission.WAKE_LOCK: granted=true User 0: installed=true hidden=false stopped=true notLaunched=false enabled=0 gids=[3002, 3003, 3001] runtime permissions: android.permission.READ_PHONE_STATE: granted=true android.permission.CAMERA: granted=true disabledComponents: com.xiaomi.push.service.XMPushService enabledComponents: cn.jpush.android.service.DaemonService cn.jpush.android.service.DownloadProvider 3.6- 查看应用安装路径 命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 4- 文件管理 4.1- 复制设备里的文件到电脑 命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到sdcard，然后 adb pull /sdcard/filename /path/on/pc。 4.2- 复制电脑里的文件到设备 命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc/sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp/sdcard/filename /path/on/device。 5- 查看日志 5.1- Android 日志 命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 5.1.1- 按级别过滤日志 Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多）D —— DebugI —— InfoW —— WarningE —— ErrorF —— FatalS —— Silent（最高，啥也不输出）按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat “*:W”，不然会报错 nomatches found: *:W。） 5.1.2- 按 tag 和级别过滤日志 可以由多个 [:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 5.2- 常用打印日志命令 命令行打印日志1adb logcat -v time 输出日志到本地 log.txt 文件 1adb logcat -v time &gt;log.txt 清空日志 1adb logcat -c 6- 查看设备信息 6.1- 型号 命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 6.2- 电池状况 命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 6.3- 屏幕分辨率 命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 6.4- android_id 命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 6.5- Android 系统版本 命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 7- 实用功能 7.1- 屏幕截图 截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 7.2- 屏幕录制 录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 7.3- 重启手机 命令： 1adb reboot 7.4- 检测设备是否已 root 命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 7.5- 使用 Monkey 进行压力测试 Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 指定的应用程序发送 500 个伪随机事件。","tags":[]},{"title":"Mac下jenkins安装步骤","date":"2020-11-18T02:45:22.000Z","path":"2020/11/18/Mac下jenkins安装步骤/","text":"前言 本文写的是在自己本机上部署jenkins，如果是要部署到服务器，则需要另外配置一些东西。 jenkins下载、安装、配置、新建项目 1、从官网https://jenkins.io/ 上下载最新的pkg安装包,进行安装。 然后一直点击next…就行 2、安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080 这个时候可能会报一个错误。如果出现了这面的问题。这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080会出现下图的重设初始密码的界面。 实际操作过程中分两种情况：一、如果出现/Users/Shared/Jenkins/Home/这样的路径 按照提示，找到 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录 和initialAdminPassword文件是没有读写权限的,将权限更改成读与写 点击右下角 锁的标志可以修改权限 打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图 二、如果出现的/Users/zhaoziliang/.jenkins/……这样的路径 在/Users/zhaoziliang目录下是找不到.jenkins目录可以通过终端 输入open .jenkins 来打开.jenkinds目录找到initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了 3、安装 4、设置用户名和密码 5、在建立项目之前开始设置,选择系统管理 再选择Global Tool Configuration 配置JDK,Gradle,Git, Gradle版本要和项目里面的Gradle版本一致,否则会报错 JDK 的JAVA_HOME从下图找到 git Path to Git executable 从下图找到 Gradle的 GRADLE_HOME从下图找到 SDK设置 6、新建项目 填写项目名称选择构建自由风格的项目 将项目地址填进去,填上用户名和密码（项目在git托管的地址和自己的git.feinno的账号密码） 项目中设置周期打包每天六点钟多H 6 * * * 选择Gradle版本 7、fir.im Jenkins 插件使用方法 https://www.jianshu.com/p/9a245918a219 8、注意事项: 构建时,注意自己的项目在Gradle文件里需要配置如下,否则遇到元素重复的时候,直接Error编译不过去.lintOptions {//设置编译的lint开关，程序在buid的时候，会执行lint检查，有任何的错误或者警告提示，都会终止构建abortOnError false 在AndroidStudio里面需要配置的,将签名文件放在app目录下 在build.gradle文件里, 根据自己的项目配置签名文件的信息 . 1234567signingConfigs &#123; release &#123; keyAlias &#x27;&#x27; keyPassword &#x27;&#x27; storeFile file(&#x27;&#x27;) storePassword &#x27;&#x27;&#125;","tags":[]},{"title":"安卓自动化测试工具：「appium + vscode」 安装、配置、使用","date":"2020-11-11T05:50:06.000Z","path":"2020/11/11/安卓自动化测试工具：「appium-vscode」-安装、配置、使用/","text":"一、Appium 1、Appium简介 Appium是一个开源测试自动化框架，可用于原生，混合和移动Web应用程序测试。 它使用WebDriver协议驱动IOS，Android和Windows应用程序。 2、关于Appium的文档 Appium官网 Appiumgithub主页 官方中文文档 3、下载及使用Appium 3.1、到appium官网下载安装即可 3.2、参考文档 安卓平台自动化测试之Appium工具 3.3、配置appium 3.3.1、打开appium 3.3.2、配置sdk和jdk路径 配置完成后，点击 Save and Restart 即可。 3.4、使用appium （1）电脑连接测试机后（也可以使用模拟器），打开appium，点击下图中红框中的按钮 （2）点击下图中编辑按钮，填写连接的手机的信息，格式如下。然后点击Save As…，下次直接可以在Saved找到方便使用 123456&#123; &quot;platformName&quot;: &quot;Android&quot;, &quot;platformVersion&quot;: &quot;9&quot;, &quot;appPackage&quot;: &quot;com.test.cbaa&quot;, &quot;appActivity&quot;: &quot;com.yitong.mobile.biz.launcher.app.SplashActivity&quot;&#125; 1234platformName //设备类型，我们用的是androidplatformVersion //设备的系统版本号，我用的是安卓9版本的测试机appPackage //我们测试的app的包名appActivity //我们测试的app的启动页路径 （3）然后点击 Start Session 就可以打开我们的app了 左边是应用程序的屏幕截图，可以在应用程序中使用鼠标来模拟操作。 中间是应用程序的层次结构，表示为XML。您可以通过单击它，或者通过点击屏幕快照视图中的元素来导航这棵树，会被强调。 右侧是细节视图，当一个元素被突出显示时，它的信息会出现在检查器右侧的细节视图中。这个细节视图包括对元素的潜在操作，以及元素属性的表。这些属性在决定如何使用特定的Appium定位策略访问元素时是有价值的。选择一个元素，还可以“Tap”元素，或者“发送键”到元素(如果它是一个文本字段)。 （4）录制脚本 点击下图中的「录制按钮」，然后「鼠标操作」左侧的app，再点击后侧的「Tap按钮」即可录制脚本。每一步操作后，就会生成对应的脚本代码，脚本可支持多种语言选择。 二、VS Code 1、下载VS Code 下载地址 安装完成后，打开软件会自动提示你安装一些重要插件，如中文语言包，Git等，这里可以直接选择安装Python插件(也可以使用Ctrl+Shift+X可以打开扩展商店然后输入Python搜索)。 vs code如何设置中文 2、homebrew安装python 2.1、安装 Python3 1brew install python3 2.2、确认安装 123456~ $ python3 --versionPython 3.7.2~ $ which python3/usr/local/bin/python3~ $ which python/usr/bin/python 2.3、确认pip的版本 12345~ $ pip --versionpip 19.0.1 from /Library/Python/2.7/site-packages/pip-19.0.1-py2.7.egg/pip (python 2.7)~ $ pip3 --versionpip 18.1 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) 3、使用VS Code开发Python 3.1、VS Code中下载Python插件 由于Python插件服务器在国外，所以需要配置国内镜像下载比较快。在VS Code命令行中配置更换pip源到国内镜像 3.2、选取Python解释器 使用Ctrl+Shift+P打开命令板，输入Python: Select Interpreter进行搜索。接下来会显示VS Code所能找到的全部解释器，选择你需要的哪个就好。 3.3、使用VS Code运行脚本：实现自动化测试 刚刚我们使用appium生成了脚本，现在就派上用场了。 比如刚生成的脚本叫 untitled111.py 使用VS Code打开 untitled111.py 在空白处右键选择在「终端运行Python文件」，就可以看到运行结果了。 当然也可以debug运行单步调试。 只要电脑连接上测试手机或者模拟器，启动运行脚本，则可以实现自动化测试app啦。","tags":[]},{"title":"Mac通过命令行编辑保存文件","date":"2020-11-09T11:07:51.000Z","path":"2020/11/09/Mac通过命令行编辑保存文件/","text":"1. cd 文件所在目录 2. vi 文件名.文件后缀 3. 输入i，进入insert模式编辑文本 4. esc退出插入模式 5. shift + ：wq 保存文件并退出文本编辑模式","tags":[]},{"title":"博客工具:「hexo+github博客」安装、配置、编写blog","date":"2020-11-09T11:07:51.000Z","path":"2020/11/09/博客工具-「hexo-github博客」安装、配置、编写blog/","text":"前言 hexo+github是一个博客框架,可以很简洁的在本地搭建一个属于自己的blog,有各种不同的自定义风格,同时可以把自己的blog同步到github进行保存 安装+配置 直接给链接,博主写的非常详细1&gt; Mac 系统下搭建hexo个人博客2&gt;Github+Hexo搭建个人博客 hexo主题 有的小伙伴想定制自己独特的主题风格,hexo也可以满足你哦1&gt;hexo官方提供的主题推荐 编写blog 一个blog最主要还是编辑文章,主页搭建的再好看也的需要有干货才行啊是不 1、创建新的文章 1hexo new &quot;name blog的标题&quot; 2、编写blog 1open . 打开文件夹,在 sourse-_posts 目录下打开刚刚新建的 “name blog的标题” 的文件. 编辑markdown文件，可以使用markdown神器typora。可以看到markdown文件，里面自动生成了题目和时间，还可以写标签，这些我们先不去修改，这些是yaml内容，一般不去修改，修改不好会报错。我们直接在下面编辑一些内容。 3、发布文章至博客 12hexo ghexo d or 1hexo g -d 4、查看blog (1)在本地的hexo中查看 1hexo s 然后打开 http://localhost:4000/ (2)在github中查看 打开自己的github项目即可 hexo常用命令 1234567891011121314151617181920npm install hexo -g //安装 npm update hexo -g //升级 hexo version //查看hexo的版本hexo init nodejs-hexo //创建nodejs-hexo 名字的本地文件hexo init nodejs-hexo //创建博客hexo init blog //初始化，生成文件夹为blogcd blog //进入blog文件夹npm install //安装依赖库hexo generate //生成一套静态网页hexo server //运行测试,浏览器打开地址，http://localhost:4000/hexo deploy //进行部署hexo new &quot;new article&quot; //新建文章‘new article’hexo new page &quot;about&quot; //新建页面 ‘about’hexo n &quot;我的博客&quot;` == `hexo new` &quot;我的博客&quot; //新建文章hexo g == hexo generate //生成`hexo s == hexo server //启动服务预览hexo d == hexo deploy //部署","tags":[]},{"title":"Android 内存泄漏「检测工具」之——LeakCanary2.0","date":"2020-10-23T07:26:25.000Z","path":"2020/10/23/Android-内存泄漏「检测工具」之——LeakCanary2-0/","text":"前言 在Android的性能优化中，内存优化是必不可少的点，而内存优化最重要的一点就是解决内存泄漏的问题，在Android的内存泄漏分析工具也不少，比如PC端的有：AndroidStudio自带的Android Profiler、MAT等工具；手机端也有，就是我们今天要介绍的LeakCanary LeakCanary2.0原理 详见LeakCanary官网文档 LeakCanary2.0使用 1. 集成 LeakCanary2.0只需要在build.gradle中添加依赖即可 1234dependencies&#123; // debugImplementation because LeakCanary should only run in debug builds. debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:2.4&#x27;&#125; 官方给出的这种依赖方式，是为了防止在release环境中使用LeakCanary。 一般开发我们会有debug和release两种buildType，但是如果你想额外创建一个buildType也是可以的，也可以为这个buildType单独设置LeakCanary2.0的依赖。 1234567891011121314151617buildTypes &#123; release &#123; debuggable false //是否开启debug模式 ... &#125; &#125; debug &#123; debuggable true //是否开启debug模式 ... &#125; &#125; debug2 &#123;//新建的一个buildType debuggable true //是否开启debug模式 ... &#125; &#125; &#125; 为debug2单独设置LeakCanary2.0： 123dependencies&#123; debug2Implementation &#x27;com.squareup.leakcanary:leakcanary-android:2.4&#x27;&#125; 2.确认LeakCanary是否运行 在LogCat控制台查看如下日志确认LeakCanary已经运行 1D LeakCanary: LeakCanary is running and ready to detect leaks 参考文献1、LeakCanary原理解析2、LeakCanary2.0使用及原理分析3、leakcanary以及leakcanary2.0使用方法总结4、内存分析工具之LeakCanary2.4使用整理","tags":[]},{"title":"Android monkey测试adb命令","date":"2020-10-23T07:25:51.000Z","path":"2020/10/23/Android-monkey测试adb命令/","text":"Android monkey测试 通用monkey测试命令：adb shell monkey-p com.hoomsun.hxb（包名）–throttle 100–ignore-crashes（忽略崩溃可设置）–ignore-timeouts （忽略超时可设置）–ignore-security-exceptions（索引越界）–ignore-native-crashes–monitor-native-crashes -v -v -v 10000&gt;monkeysss.txt 一、理解monkey测试 1、Monkey测试是Android自动化测试的一种手段。Monkey测试本身非常简单，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 2、当Monkey程序在模拟器或真实设备运行的时候，程序会产生一定数量或一定时间内的随机模拟用户操作的事件, 如点击，按键，手势等， 以及一些系统级别的事件。通常也称随机测试或者稳定性测试。 二、查看设备连接、包名、和入口Activity 1、进入cmd查看设备连接状态： 1adb devices 2、查看包名、和入口Activity 1234进入cd D:\\Program Files\\adt-bundle-windows-x86_64-20130917\\sdk\\build-tools\\android-4.3 目录下执行下条命令aapt dump badging apk安装包绝对路径 三、运行monkey测试 //不间断操作500次 1adb shell monkey -p 包名 -v 500 //每个操作间隔500ms，共执行100次 1adb shell monkey -p 包名 -v-v --throttle 500 100 //每个操作间隔100ms,共执行1000次 ，其中点击事件占比50%，轨迹50% 1adb shell monkey -p 包名 -v-v --pct-touch 50 --pct-trackball 50 --throttle 100 1000 //日志重定向到桌面文件夹 1adb shell monkey -p 包名 -v-v --pct-touch 50 --pct-trackball 50 --throttle 100 1000 &gt;C:\\Users\\xyp\\Desktop\\Android脚本\\1.log //每个操作间隔500ms、崩溃、超时、许可错误继续执行 1adb shell monkey -p 包名 --throttle 500 --ignore-crashes --ignore-timeouts --ignore-security-exceptions --ignore-native-crashes --monitor-native-crashes -v-v-v 1000000&gt;C:\\Users\\xyp\\Desktop\\Android脚本\\1.log 四、停止monkey测试 重新打开一个cmd窗口进入adb shellps | grep monkey //查找monkey进程kill 进程号 //结束monkey 五、结果分析 得到Monkey测试的log之后，我们可以通过几个关键词来判断测试是否通过。 1、Monkey finished用记事本打开LOG，查看log的最下端，是否有类似以下字段： 12## Network stats: elapsed time=3799ms (3799ms mobile, 0ms wifi, 0ms not connected)// Monkey finished 这个字段表明本次的Monkey测试通过，没有异常 2、CRASH同样，在得到LOG后，搜索”CRASH”字段，如果搜索到有结果，则表明，在测试过程中，测试对象出现了报错现象，因此测试失败。 1// CRASH: com.onekchi.downloadmanager (pid 12919) 3、NOT RESPONDING在log中搜素该字段，如果有搜索有结果，则表示测试过程中，测试对象出现了进程无响应的现象，因此测试失败。 4、无法搜索到上述信息出现这种情况，一般都是外界原因而非程序本身原因。比如测试过程中，电脑断电关机。或者测试过程中内存不足等等，结果作废，需要重新测试。 六、monkey说明 123456789101112131415161718192021--throttle 时间间隔--ignore-crashes 忽略崩溃--ignore-timeouts 忽略超时--ignore-security-exceptions 忽略许可错误--ignore-native-crashes 忽略本地崩溃--monitor-native-crashes 监控本地崩溃 --pct-touch 触摸、点击--pct-motion 调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)--pct-trackball 调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)--pct-nav 调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)--pct-majornav 调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键)--pct-syskeys 调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)--pct-appswitch 调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法--pct-flip 调整“键盘翻转”事件的百分比。--pct-anyevent 调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等 注意：各事件类型的百分比总数不能超过100%。","tags":[]},{"title":"mac安装adb工具","date":"2020-10-23T07:25:14.000Z","path":"2020/10/23/mac安装adb工具/","text":"homebrew是macOS的一个包管理工具 1、安装homebrew 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2、安装adb 1brew cask install android-platform-tools 3、运行adb 1adb devices","tags":[]},{"title":"点击非Edittext触发EditText焦点和自动弹出软键盘","date":"2020-10-23T07:24:23.000Z","path":"2020/10/23/点击非Edittext触发EditText焦点和自动弹出软键盘/","text":"前言 最近做项目时遇到要求点击非EditText时，使该EditText获取焦点并自动弹出软键盘的需求。由于一般情况下我们点击EditText时会自动弹出系统键盘，而对与点击其他button触发EditText的弹出键盘没做过，于是记录下。 实用场景1、点击button时，触发EditText的获取焦点和自动弹出软键盘2、点击某个话题的选项卡，会弹出一个popupwindow，或开启新的ACTIVITY。里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。 方法 12345editText.requestFocus();InputMethodManager imm = (InputMethodManager) login_phone_et.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);if (null != imm) &#123; imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);&#125; 1、通过requestFocus();获取焦点；2、通过InputMethodManager强制弹出键盘； 参考文献 1、事件触发EditText焦点和自动弹出键盘以及InputMethodManager输入法简介","tags":[]},{"title":"Android 获取屏幕、状态栏、标题栏的高度详解","date":"2020-10-23T07:22:18.000Z","path":"2020/10/23/Android-获取屏幕、状态栏、标题栏的高度详解/","text":"前言 如下图：绿色区域：屏幕区域蓝色区域：状态栏区域红色区域：标题栏区域黄色区域：view绘制区域 1.Android手机屏幕的高度（绿色区域） 方法一 123DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);Log.e(&quot;TAG&quot;, &quot;屏幕高:&quot; + dm.heightPixels); 方法二 12DisplayMetrics displayMetrics = getResources().getDisplayMetrics();Log.e(&quot;TAG&quot;,&quot;screenHeight&quot;+displayMetrics.heightPixels); 2.Android手机状态栏的高度（蓝色区域） 方法一 12345678int statusBarHeight1 = -1;//获取status_bar_height资源的IDint resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);if (resourceId &gt; 0) &#123; //根据资源ID获取响应的尺寸值 statusBarHeight1 = getResources().getDimensionPixelSize(resourceId);&#125;Log.e(&quot;TAG&quot;, &quot;方法1:&quot; + statusBarHeight1); 方法二：通过反射 1234567891011int statusBarHeight2 = -1;try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object object = clazz.newInstance(); int height = Integer.parseInt(clazz.getField(&quot;status_bar_height&quot;) .get(object).toString()); statusBarHeight2 = getResources().getDimensionPixelSize(height);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;Log.e(&quot;TAG&quot;, &quot;方法2:&quot; + statusBarHeight2); 方法三：状态栏高度 = 屏幕高度 - 应用区高度 123456789//屏幕DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);//应用区域Rect outRect1 = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);//状态栏高度=屏幕高度-应用区域高度int statusBar = dm.heightPixels - outRect1.height(); Log.e(&quot;TAG&quot;, &quot;方法3:&quot; + statusBar); 3.Android手机应用区域（红+黄区域） 1234//应用区域Rect outRect1 = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);Log.e(&quot;TAG&quot;, &quot;应用区高&quot; + outRect1.height()); 4.Android手机标题高度（红色区域） 12int viewTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();Log.e(&quot;TAG&quot;, &quot;标题栏：&quot; + viewTop); 5.Android手机绘制区域高度(黄色区域) 123Rect outRect2 = new Rect();getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(outRect2);Log.e(&quot;TAG&quot;, &quot;View绘制区域高度：&quot; + outRect2.height()); 参考文献 Android如何获取屏幕、状态栏及标题栏的高度详解","tags":[]},{"title":"Android 硬件加速 4种方式","date":"2020-10-23T07:21:16.000Z","path":"2020/10/23/Android-硬件加速-4种方式/","text":"前言： 硬件加速可以在一下四个级别开启或关闭：（1）Application（2）Activity（3）Window（4）View 1、Application级别 在应用程序AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启硬件加速： 1&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; 2、Activity级别 可以控制每个activity是否开启硬件加速，只需在activity元素中添加android:hardwareAccelerated属性即可办到。比如下面的例子，在application级别开启硬件加速，但在某个activity上关闭硬件加速。 12345&lt;application android:hardwareAccelerated=&quot;true&quot;&gt; &lt;activity ... /&gt; &lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt;&lt;/application&gt; 3、Window级别 如果需要更小粒度的控制，可以使用如下代码开启某个window的硬件加速： 123getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4、View级别 可以在运行时用以下的代码关闭单个view的硬件加速： 1testView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);","tags":[]},{"title":"Android 全面屏显示\\沉浸式状态栏","date":"2020-10-23T07:19:56.000Z","path":"2020/10/23/Android-全面屏显示-沉浸式状态栏/","text":"前言： 之前做项目为了达到全面屏显示，设置了一个theme主题样式，如下： 1234&lt;!-- 应用全屏样式 --&gt; &lt;style name=&quot;AppFullWindowTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 但是在部分手机上会出现一个坑爹的现象：虽然状态栏隐藏了，但是原状态栏位置上会被黑条占领。（没错，就是在万恶的小米手机上出现了…） 解决方案： 方案1:在代码中设置 1234567891011WindowManager.LayoutParams lp = activity.getWindow().getAttributes(); lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; activity.getWindow().setAttributes(lp); View decorView = activity.getWindow().getDecorView(); int systemUiVisibility = decorView.getSystemUiVisibility(); int flags =View.SYSTEM_UI_FLAG_HIDE_NAVIGATION//隐藏导航栏 | View.SYSTEM_UI_FLAG_FULLSCREEN;//隐藏状态栏 systemUiVisibility |= flags; activity.getWindow().getDecorView().setSystemUiVisibility(systemUiVisibility); 方案2:在xml中设置theme 12345&lt;style name=&quot;AppFullTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowLayoutInDisplayCutoutMode&quot;&gt;shortEdges&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 注解1: Android P版本为我们提供了解决方法，我们可以通过对Window设置layoutInDisplayCutoutMode来达到我们的目的，先来看一下layoutInDisplayCutoutMode的几种属性： LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：默认情况下，全屏窗口不会使用到刘海区域，非全屏窗口可正常使用刘海区域LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：窗口不允许和刘海屏重叠LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES：该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 注解2: 了解一下几个设置沉浸式状态栏的基础属性： 1.View.SYSTEM_UI_FLAG_LOW_PROFILE：低调模式, 会隐藏不重要的状态栏图标；2.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏导航栏；3.View.SYSTEM_UI_FLAG_FULLSCREEN：状态栏隐藏（高度不变）；4.View.SYSTEM_UI_FLAG_LAYOUT_STABLE：保持整个View稳定, 常和控制System UI悬浮, 隐藏的Flags共用, 使View不会因为System UI的变化而重新layout；5.View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：视图延伸至导航栏区域，导航栏覆盖在视图之上（在style中设置windowTranslucentNavigation）；6.View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ：视图延伸至状态栏区域，状态栏覆盖在视图之上（在style中设置windowTranslucentStatus）；7.View.SYSTEM_UI_FLAG_IMMERSIVE：配合2或3同时使用，假设同时设置了2和7，状态栏隐藏，此时在状态栏顶部下滑，系统清除2设置，重新唤出状态栏，导航栏同理，滑动方向为由下至上；8.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY：作用与7相似，但是设置并未被清楚，所以状态栏与导航栏在被唤出3s后或再次点击时，再次隐藏。","tags":[]},{"title":"Mac 电脑查看本机的mac地址和ip地址","date":"2020-10-23T07:18:44.000Z","path":"2020/10/23/Mac-电脑查看本机的mac地址和ip地址/","text":"Mac电脑：获取mac地址和ip地址 方法1：通过「命令行」获取 打开命令行，输入ifconfig，然后找到en0，找到ether对应的就是mac地址，找到inet对应的就是ip地址。 方法2：通过「查看关于本机信息」获取 打开关于本机 -&gt; 系统报告 -&gt; 左侧找到“WIFI” -&gt; 右边找到“en0”目录下的MAC地址 方法三：通过「系统偏好设置」获取 打开“系统偏好设置” -&gt; “网络” -&gt; “高级” -&gt; “TCP/IP”查看ip -&gt; “硬件”查看mac地址","tags":[]},{"title":"Android 防止按钮多次重复点击之「防重复点击」","date":"2020-10-23T07:17:47.000Z","path":"2020/10/23/Android-防止按钮多次重复点击之「防重复点击」/","text":"前言 为了防止“按钮”的点击事件在短时间内多次点击从而触发了多次处理操作；比如：快速点击“登录按钮”发送了多次登录接口，导致程序在短时间内进行多次数据提交or数据处理，这样的体验就不太好了。 方法 判断用户点击按钮间隔时间，如果间隔时间太短，则认为是无效操作，否则进行相关业务处理 1234567891011121314151617181920/** * 判断两次点击事件的间隔 */public class ClickHelper &#123; private static long lastClickTime = 0; /** * 判断事件出发时间间隔是否超过预定值 * 如果小于间隔（目前是1000毫秒）则返回true，否则返回false */ public static boolean isFastDoubleClick() &#123; long time = System.currentTimeMillis(); long timeD = time - lastClickTime; if (0 &lt; timeD &amp;&amp; timeD &lt; 1000) &#123; return true; &#125; lastClickTime = time; return false; &#125;&#125; 调用demo 123456789btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (ClickHelper.isFastDoubleClick()) &#123;//连续点击 return; &#125; ...//此处添加点击按钮后的触发事件处理 &#125; &#125;);","tags":[]},{"title":"macOS Catalina(10.15.6)双网卡同时连内外网","date":"2020-10-23T07:17:03.000Z","path":"2020/10/23/macOS-Catalina-10-15-6-双网卡同时连内外网/","text":"前提 使用网线连接内网，此时不能连接外网，无线可以连接外网，却又不能完成部分在内网才能完成的操作 1、修改无线网卡的优先级，使之大于有线网卡 进入系统偏好设置，网络，左下角的齿轮，更改服务顺序，拖动wifi到有线网卡上面就可以了（我的有线网卡是AX8817） 此时变成的状态是连着无线，插着网卡，以无线网卡优先，即上不了内网，可以上外网（苹果默认的是插上有线网络有线优先） 2、设置路由修改连接内网使用的网卡 由于公司里内外网分两个路由，只需要修改前往公司内网地址的网关就可以了，比如你需要访问的内网地址是158.220.155.188和158.220.21.39，而公司的内网网关是158.223.13.254，那么就这样写 12345678910$ sudo route delete -net 158.220.155.188 $ sudo route -n add -net 158.220.155.188 158.223.13.254 $ sudo route delete -net 158.220.21.39 $ sudo route -n add -net 158.220.21.39 158.223.13.254 # 列出全部的路由信息$ sudo netstat -nr 如果公司里内外网是一个路由，或者两个路由在同一个网段之内。此时需要有线网卡转发内网链接，无线网卡转发外网链接，写法如下： 123$ sudo route delete -net 158.220.155.188 $ sudo route add -net 158.220.155.188 -netmask 255.255.255.0 -interface en10 3、如何自动在每次启动的时候都切换到当前的路由表 当mac每次重启的时候，路由表都会被重置；或者拔了网线之后再连接网线，也会重置。这时候避免每次我们都需要执行命令行，可以使用macOS里好用的小机器人 Automator来帮我们。 点击右上角的「运行」就OK了。 参考链接 Macbook利用双网卡同时连内外网","tags":[]},{"title":"Android dp和px之间相互转换","date":"2020-10-23T07:16:23.000Z","path":"2020/10/23/Android-dp和px之间相互转换/","text":"前言 android中在xml布局中我们可以使用dp和px都可以；但是在代码中，很多方法只提供了设置px的方法，这时候就需要用到dp和px相互切换了。 方法 123456789101112131415161718192021/** * dp和px之间进行转换 */public class DensityHelper &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125;","tags":[]},{"title":"Android 限制EditText输入的文本行数为1","date":"2020-10-23T07:12:49.000Z","path":"2020/10/23/Android-限制EditText输入的文本行数为1/","text":"前言： android Edittext默认是可以换行的，但当我们用来作为输入账号、密码的时候，是希望它作为一行来展示，并不想让它可以换行。 方法1： 「不建议」 xml设置maxlines属性： 1android:maxlines=&quot;1&quot; 此属性设置为1，发现仅仅是显示1行，但按下回车仍然生效，可以换行输入。 方法2：「不建议」 xml设置singleLine属性： 1android:singleLine=&quot;true&quot; 可以保证EditText为单行，但此方法在Android 7.0的环境下过期了 **方法3:**「实用」 xml设置lines和inputType属性： 12android:inputType=&quot;text&quot;android:lines=&quot;1&quot; 两项属性如上配置，可实现EditText输入框屏蔽回车键，按下回车键为换行的功能。 方法4: 动态用addTextChangedListener去监听控件中文本的变化： 需要实现的函数有三个： 12345public void beforeTextChanged(CharSequence A, int B, int C,int D)public void onTextChanged(CharSequence A, int B, int C, int D)public void afterTextChanged(Editable A) 这个三个函数描述了editText控件的一次输入过程： beforeTextChanged 字符串A中从索引B位置开始的C个字符将被D个字符替换onTextChanged 字符串A中从索引B位置开始的C个字符刚刚被D个字符替afterTextChanged 控件中现在的字符 这里beforeTextChanged ，onTextChanged 这两个函数中是不能对控件内容进行重新的设定的，但是afterTextChanged 是可以递归的，当然要能正确的结束递归过程。 1234567891011121314151617181920212223242526272829303132EditText.addTextChangedListener @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // TODO Auto-generated method stub &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // TODO Auto-generated method stub &#125; @Override public void afterTextChanged(Editable s) &#123; // TODO Auto-generated method stub int lines = editText.getLineCount(); // 限制最大输入行数 if (lines &gt; MAXLINES) &#123; String str = s.toString(); int cursorStart = editText.getSelectionStart(); int cursorEnd = editText.getSelectionEnd(); if (cursorStart == cursorEnd &amp;&amp; cursorStart &lt; str.length() &amp;&amp; cursorStart &gt;= 1) &#123; str = str.substring(0, cursorStart-1) + str.substring(cursorStart); &#125; else &#123; str = str.substring(0, s.length()-1); &#125; // setText会触发afterTextChanged的递归 editText.setText(str); // setSelection用的索引不能使用str.length()否则会越界 editText.setSelection(editText.getText().length()); &#125; &#125;","tags":[]},{"title":"MAC下Apktool、dex2jar、jd-gui的安装和反编译、回编译、重新签名简单使用","date":"2020-10-23T07:12:11.000Z","path":"2020/10/23/MAC下Apktool、dex2jar、jd-gui的安装和反编译、回编译、重新签名简单使用/","text":"一、安装 1、安装Apktool 方法1：普通下载安装 下载Apktool 下载Apktool安装包脚本 macOS：下载Mac 包装器脚本（右键单击，将链接另存为apktool）下载apktool-2（在这里找到最新的）将下载的jar重命名为 apktool.jar将两个文件（apktool.jar＆apktool）移动到/usr/local/bin（需要root）确保两个文件均可执行（chmod +x）尝试apktool通过cli 运行 12$：cd /usr/local/bin$：chmod +x apktool 方法2:使用homebrew安装 或者您可以通过Homebrew安装apktool ：如本页所述安装Homebrewbrew install apktool在终端中执行命令（无需root）。最新版本将安装/usr/local/Cellar/apktool/[version]/并链接到/usr/local/bin/apktool。尝试apktool通过cli 运行注意 -包装脚本不是必需的，但很有用，因此您不必java -jar apktool.jar一遍又一遍地输入。 123brew install apktool# 验证安装结果apktool -version 2、安装dex2jar 需要注意的是，假如使用dex2jar遇到报错 com.googlecode.d2j.DexException: not support version。则说明你安装的版本不兼容，所以尽量安装最新版本。 下载地址：https://github.com/pxb1988/dex2jar/tree/2.1-nightly-28 点击右下角的Latest按钮，选择最新版本进行下载； 最后点击下载zip文件，解压就OK了。我比较懒，直接把dex2jar放在了桌面，也方便我使用。 3、安装JD-GUI 官网下载地址：http://java-decompiler.github.io/ 把app文件拖到Application文件夹下就ok了。 二、反编译流程 现在桌面上有一个demo.apk文件，我们复制一份，demo副本.apk将副本文件名的后缀改为zip，即demo副本.zip 1. 获取xml反编译文件和smail代码 启动终端 12$：cd /Users/apple/Desktop $：apktool d demo.apk 注意，demo.apk 要在控制台的当前目录下，因为demo.apk 在桌面，所以我先cd到了桌面的目录。 其中d是decode的意思，表示我们要对Demo.apk这个文件进行解码。那除了这个基本用法之外，我们还可以再加上一些附加参数来控制decode的更多行为：· f 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。·o 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹。·s 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。·r 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）。常用用法就这么多了，那么上述命令的执行结果如下图所示：原文链接：https://blog.csdn.net/u013082948/article/details/52195514 2. 反编译calss.dex文件 刚刚的demo副本.zip解压获得demo副本文件夹，进入文件夹后拷贝classes.dex(如果解压失败，换一个解压软件，不用系统自带的) 打开dex2jar 解压的目录，将classes.dex文件复制进去 由于我的dex2jar文件夹在桌面上，所以终端直接执行： 12apple@fenglolodeMacBook-Pro ~ % cd /Users/apple/Desktop/dex-tools-2.1 apple@fenglolodeMacBook-Pro dex-tools-2.1 % ./d2j-dex2jar.sh classes.dex 如果没有执行权限 123apple@fenglolodeMacBook-Pro ~ % cd /Users/apple/Desktop/dex-tools-2.1 apple@fenglolodeMacBook-Pro dex-tools-2.1 % chmod +x ./*apple@fenglolodeMacBook-Pro dex-tools-2.1 % ./d2j-dex2jar.sh classes.dex 这个时候文件夹下回多出一个jar文件classes-dex2jar.jar 3. 查看jar文件代码 打开 JD-GUI ，将 jar 拖拽到 JD-GUI 区域就可以看代码了（该代码是混淆之后的） 三、回编译流程 以demo.apk通过 apktool d demo.apk 反编译生成的demo文件为例：命令行窗口输入 1apktool b demo 新生成的apk会在demo/dist/目录下面。若报错则输入apktool -r b name,资源文件不反编译，避免资源报错 四、apk 签名，打包 命令行窗口输入 12jarsigner -verbose -keystore 签名文件名字 -signedjar newName.apk oldName.apk 签名文件名字输入密钥库的密码短语: 备注：签名文件名字：如abc.keystorenewName.apk：签名后的apk的名字，可自定义oldName.apk：需要被签名的apk的名字，如我的案例中应为demo.apk 然后输入你的签名文件的密码就开始重新签名了，签名后的apk为你自定义的newName.apk。","tags":[]},{"title":"记录wget使用详解 & Mac安装wget","date":"2020-10-23T07:11:37.000Z","path":"2020/10/23/记录wget使用详解-Mac安装wget/","text":"一、记录wget使用详解 1、什么是wget 百度百科介绍的wget 2、wget命令详解 来自大牛随性i的文章介绍的wget命令详解 二、Mac安装wget的两种方法 1、手动下载并终端安装 从ftp://ftp.gnu.org/gnu/wget/下载到最新的wget安装包到本地 将解压的安装包放到自己想要保管的路径下，然后在终端进入对应的安装包位置，如果不知道文件的路径可查看文件的简介-位置 或者直接把文件拖进终端即可显示文件路径 打开终端，进入wget文件路径，然后在终端依次输入：./configure、 make 以及 make install 命令 2、直接终端使用homebrew安装 执行安装brew（homebrew官网地址） 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 安装 wget 1brew install wget","tags":[]},{"title":"Android Dialog 去掉透明遮罩层「全透明」","date":"2020-10-23T07:10:07.000Z","path":"2020/10/23/Android-Dialog-去掉透明遮罩层「全透明」/","text":"dialog即使设置透明背景也会有一个蒙层（遮罩层），有时候因为UI设计并不想要这个蒙层。 一行代码搞定 1dialog.getWindow().setDimAmount(0f);","tags":[]},{"title":"Android 使用简单帧动画实现一个自定义动态等待层","date":"2020-10-23T07:09:27.000Z","path":"2020/10/23/Android-使用简单帧动画实现一个自定义动态等待层/","text":"前言 项目中有时候需要自定义等待层，使用帧动画实现一个动态的等待层还是不错的。 一、简单帧动画实现 1.在drawable下创建loading_view.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/loading_001&quot; android:duration=&quot;50&quot;/&gt; &lt;item android:drawable=&quot;@drawable/loading_002&quot; android:duration=&quot;50&quot;/&gt; &lt;item android:drawable=&quot;@drawable/loading_003&quot; android:duration=&quot;50&quot;/&gt;&lt;/animation-list&gt; 2.在xml布局中调用loading_view 123456&lt;ImageView android:id=&quot;@+id/img_loading_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:src=&quot;@drawable/loading_view&quot; /&gt; 3、在代码中调用 12345ImageView imgLoadingView = (ImageView) view.findViewById(R.id.img_loading_view);AnimationDrawable animationDrawable = (AnimationDrawable) imgLoadingView.getDrawable();animationDrawable.start();//开启动画animationDrawable.stop();//关闭动画 二、帧动画等待层 只需要自定义一个dialog，xml布局中使用以上帧动画即可。当开启等待层时调用： animationDrawable.start();//开启动画 当关闭等待层时调用： animationDrawable.stop();//关闭动画","tags":[]},{"title":"Android 自定义dialog学习之——自定义一个提示框","date":"2020-10-23T07:05:42.000Z","path":"2020/10/23/Android-自定义dialog学习之——自定义一个提示框/","text":"前言 最近项目中觉的Android系统的dialog样式太丑，确实也不太好看，就打算自定义一个dialog来使用。 自定义dialog实例demo 1、布局dialog_alert 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;@dimen/dp_550&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@drawable/new_dialog_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题--&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_80&quot; android:layout_marginLeft=&quot;@dimen/dp_60&quot; android:layout_marginRight=&quot;@dimen/dp_60&quot; android:gravity=&quot;center|bottom&quot; android:text=&quot;@string/title&quot; android:textColor=&quot;@color/color_222222&quot; android:textSize=&quot;@dimen/dp_32&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;!--提示信息--&gt; &lt;TextView android:id=&quot;@+id/tv_msg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;@dimen/dp_60&quot; android:layout_marginTop=&quot;@dimen/dp_36&quot; android:layout_marginRight=&quot;@dimen/dp_60&quot; android:layout_marginBottom=&quot;@dimen/dp_50&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/color_222222&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_1&quot; android:background=&quot;@color/color_E8E8E8&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_92&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;!--取消按钮--&gt; &lt;TextView android:id=&quot;@+id/tv_cancel&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/tv_cancel&quot; android:textColor=&quot;@color/color_666666&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;View android:id=&quot;@+id/v_line&quot; android:layout_width=&quot;@dimen/dp_1&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/color_E8E8E8&quot; /&gt; &lt;!--确认按钮--&gt; &lt;TextView android:id=&quot;@+id/tv_ok&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/tv_ok&quot; android:textColor=&quot;@color/color_00A1C1&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; new_dialog_bg 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 边框的宽度和颜色 --&gt; &lt;stroke android:width=&quot;@dimen/dp_1&quot; android:color=&quot;#E8E8E8&quot; /&gt; &lt;!-- 圆角的半径 --&gt; &lt;corners android:radius=&quot;@dimen/dp_12&quot; /&gt; &lt;!-- 填充颜色 --&gt; &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&lt;/shape&gt; 2、代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class MyDialog extends Dialog implements View.OnClickListener &#123; private TextView tv_title; private TextView tv_msg; private TextView tv_cancel; private TextView tv_ok; private View v_line; private OkOnClickListener okOnClickListener; private CancelOnClickListener cancelOnClickListener; public MyDialog(@NonNull Context context) &#123; this(context, R.style.BaseDialogStyle); &#125; public MyDialog(@NonNull Context context, int themeResId) &#123; super(context, themeResId); setContentView(R.layout.dialog_alert); initView(); initAction(); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); WindowManager m = getWindow().getWindowManager(); Display d = m.getDefaultDisplay(); WindowManager.LayoutParams p = getWindow().getAttributes(); p.width = d.getWidth(); //设置dialog的宽度为当前手机屏幕的宽度 getWindow().setAttributes(p); &#125; private void initView() &#123; tv_title = findViewById(R.id.tv_title); tv_msg = findViewById(R.id.tv_msg); tv_cancel = findViewById(R.id.tv_cancel); tv_ok = findViewById(R.id.tv_ok); v_line = findViewById(R.id.v_line); tv_ok.setOnClickListener(this); tv_cancel.setOnClickListener(this); &#125; //默认设置ok和cancel按钮都不可见：这样可以代码动态设置只显示一个按钮或者两个按钮，使控件更加实用 private void initAction() &#123; tv_cancel.setVisibility(View.GONE); tv_ok.setVisibility(View.GONE); v_line.setVisibility(View.GONE); &#125; //设置title public MyDialog setTitle(String title) &#123; if (this.tv_title != null) &#123; this.tv_title.setText(StringUtil.isEmpty(title) ? this.getContext().getResources().getString(R.string.title) : title); &#125; return this; &#125; //设置msg public MyDialog setMessage(String message) &#123; if (this.tv_msg != null) &#123; this.tv_msg.setText(StringUtil.isEmpty(message) ? &quot;&quot; : message); &#125; return this; &#125; //设置ok按钮点击事件 public MyDialog setPositiveButton(String okMsg, OkOnClickListener okOnClickListener) &#123; if (this.tv_ok != null) &#123; this.tv_ok.setVisibility(View.VISIBLE); this.tv_ok.setText(StringUtil.isEmpty(okMsg) ? this.getContext().getResources().getString(R.string.tv_ok) : okMsg); this.okOnClickListener = okOnClickListener; &#125; return this; &#125; //设置cancel按钮点击事件 public MyDialog setNegativeButton(String cancelMsg, CancelOnClickListener cancelOnClickListener) &#123; if (this.tv_cancel != null) &#123; this.tv_cancel.setVisibility(View.VISIBLE); this.v_line.setVisibility(View.VISIBLE); this.tv_cancel.setText(StringUtil.isEmpty(cancelMsg) ? this.getContext().getResources().getString(R.string.tv_cancel) : cancelMsg); this.cancelOnClickListener = cancelOnClickListener; &#125; return this; &#125; @Override public void onClick(View v) &#123; dismiss(); int id = v.getId(); if (id == R.id.tv_ok) &#123; if (okOnClickListener != null) &#123; okOnClickListener.confirm(); &#125; &#125; else if (id == R.id.tv_cancel) &#123; if (cancelOnClickListener != null) &#123; cancelOnClickListener.cancel(); &#125; &#125; &#125; public interface OkOnClickListener &#123; void confirm(); &#125; public interface CancelOnClickListener &#123; void cancel(); &#125;&#125; 3、调用dialog我们写一个工具类来调用，这样全局只需要调用工具类就ok了，不用每次都new一个dialog对象来调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//工具类public class DialogHelper &#123; /** * 单按钮dialog弹出框 * * @param context 上下文 * @param title 标题 * @param msg 内容 * @param cancelOutSide 是否可以点击dialog外部时关闭dialog * @param ok 确认按钮 * @param okOnClickListener 确认回调 */ public static void showDialog(Context context, String title, String msg, boolean cancelOutSide, String ok, MyDialog.OkOnClickListener okOnClickListener) &#123; showDialog(context, title, msg, true, cancelOutSide, ok, okOnClickListener, &quot;&quot;, null); &#125; /** * 双按钮dialog弹出框 * * @param context 上下文 * @param title 标题 * @param msg 内容 * @param hideCancel 是否隐藏“取消”按钮 * @param cancelOutSide 是否可以点击dialog外部时关闭dialog * @param ok 确认按钮 * @param okOnClickListener 确认回调 * @param cancel 取消按钮 * @param cancelOnClickListener 取消回调 */ public static void showDialog(Context context, String title, String msg, boolean hideCancel, boolean cancelOutSide, String ok, MyDialog.OkOnClickListener okOnClickListener, String cancel, MyDialog.CancelOnClickListener cancelOnClickListener) &#123; MyDialog dialog = new MyDialog(context); dialog.setTitle(title); dialog.setMessage(msg); dialog.setCanceledOnTouchOutside(cancelOutSide); dialog.setCancelable(cancelOutSide); dialog.setPositiveButton(ok, okOnClickListener); if (!hideCancel) &#123; dialog.setNegativeButton(cancel, cancelOnClickListener); &#125; dialog.show(); &#125;&#125; 4、最后附上自定义dialog的样式","tags":[]},{"title":"Mac 中 Android Studio使用内存调整方法","date":"2020-10-23T07:05:01.000Z","path":"2020/10/23/Mac-中-Android-Studio使用内存调整方法/","text":"Mac下调整Android Studio可使用内存大小 前言 当使用 MAC 安装完 AS 后，系统会给AS的内存值分配一个默认值，这个默认值是一个通用的，不可能去适配到每台机器。默认的值在/Applications/Android Studio.app/Contents/bin/studio.vmoptions这个文件里面 12345678910111213141516171819-Xms256m-Xmx1280m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-XX:CICompilerCount=2-Dsun.io.useCanonPrefixCache=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;-Djdk.attach.allowAttachSelf=true-Dkotlinx.coroutines.debug=off-Djdk.module.illegalAccess.silent=true-Djna.nosys=true-Djna.boot.library.path=-XX:+UseCompressedOops-Dfile.encoding=UTF-8-XX:ErrorFile=$USER_HOME/java_error_in_studio_%p.log-XX:HeapDumpPath=$USER_HOME/java_error_in_studio.hprof 修改方式1:（不建议） 可以直接修改/Applications/AndroidStudio.app/Contents/bin/studio.vmoptions这个文件的内容，但是不建议直接修改该安装目录下的配置，如果修改了这个配置，每当你升级AS的时候都会有个alert框提示：这个目录下有冲突了，还是有点烦的。 修改方式2:（推荐） 修改~/Library/Preferences/AndroidStudio4.0/目录下的studio.vmoptions文件，如果没这个文件的话就自己touch个，最后将自己的配置写进去 如果你用的是别的版本的AS，上面的路径需要对应到正确的版本，比如用的是AS v3.1，那么对应的路径应该是~/Library/Preferences/AndroidStudio3.1/ 以下是我的修改的配置： 12# custom Android Studio VM options, see https://developer.android.com/studio/intro/studio-config.html-Xmx4096m","tags":[]},{"title":"Android ViewFlipper控件使用之——图片切换的实现「带手势检测」","date":"2020-10-23T07:04:15.000Z","path":"2020/10/23/Android-ViewFlipper控件使用之——图片切换的实现「带手势检测」/","text":"使用ViewFlipper控件实现图片切换参考：ViewFlipper使用详解 前言 ViewFlipper是一个切换控件1、一般用于图片的切换2、也可以用来添加View，不限定只用于ImageView，也可以是自定义View；只是我们经常利用ViewFlipper来实现ImageView的切换，如果切换自定义的View，使用ViewPager做更方便吧。 一、使用ViewFlipper实现「图片切换」demo案例 ViewFlipper布局： 123456&lt;ViewFlipper android:id=&quot;@+id/flipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;10dp&quot; android:flipInterval=&quot;2000&quot; /&gt; 代码实现： 123456789101112ViewFlipper mFlipper = findViewById(R.id.flipper); mFlipper.addView(getImageView(R.mipmap.img_1)); mFlipper.addView(getImageView(R.mipmap.img_2)); mFlipper.addView(getImageView(R.mipmap.img_3)); mFlipper.addView(getImageView(R.mipmap.img_4)); if (mFlipper.getChildCount() &gt; 1) &#123; mFlipper.startFlipping(); &#125; else &#123; mFlipper.stopFlipping(); &#125; 二、完整版demo「包含手势检测，可以手动滑动图片切换」 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 图片切换demo:手势切换 */public class TwoActivity extends Activity &#123; private ViewFlipper mFlipper; private GestureDetector mDetector; //手势检测 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_two); initView(); initData(); initAction(); &#125; private void initView() &#123; mFlipper = findViewById(R.id.flipper); mDetector = new GestureDetector(new simpleGestureListener()); &#125; private void initData() &#123; mFlipper.addView(getImageView(R.mipmap.img_1)); mFlipper.addView(getImageView(R.mipmap.img_2)); mFlipper.addView(getImageView(R.mipmap.img_3)); mFlipper.addView(getImageView(R.mipmap.img_4)); &#125; @SuppressLint(&quot;ClickableViewAccessibility&quot;) private void initAction() &#123; mFlipper.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; return mDetector.onTouchEvent(motionEvent);//手势监听 &#125; &#125;); if (mFlipper.getChildCount() &gt; 1) &#123; mFlipper.startFlipping(); &#125; else &#123; mFlipper.stopFlipping(); &#125; &#125; private ImageView getImageView(int id) &#123; ImageView imageView = new ImageView(this); imageView.setImageResource(id); return imageView; &#125; private class simpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123; final int FLING_MIN_DISTANCE = 100, FLING_MIN_VELOCITY = 200; //不知道为什么，不加上onDown函数的话，onFling就不会响应，真是奇怪 @Override public boolean onDown(MotionEvent e) &#123; return true; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; // Fling left if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; mFlipper.showNext();//展示下一张图片 Toast.makeText(TwoActivity.this, &quot;Fling Left&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; // Fling right mFlipper.showPrevious();//展示上一张图片 Toast.makeText(TwoActivity.this, &quot;Fling Right&quot;, Toast.LENGTH_SHORT).show(); &#125; return true; &#125; &#125;&#125;","tags":[]},{"title":"Android  ViewFlipper控件使用之——滑动轮播公告的实现","date":"2020-10-23T07:03:35.000Z","path":"2020/10/23/Android-ViewFlipper控件使用之——滑动轮播公告的实现/","text":"使用ViewFlipper控件实现轮播公告前言 ViewFlipper是一个切换控件1、一般用于图片的切换2、也可以用来添加View，不限定只用于ImageView，也可以是自定义View；只是我们经常利用ViewFlipper来实现ImageView的切换，如果切换自定义的View，使用ViewPager做更方便吧。 一、使用ViewFlipper实现轮播公告demo案例 1、布局文件配置： ViewFlipper布局： 123456789&lt;ViewFlipper android:id=&quot;@+id/vf_notice&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:autoStart=&quot;true&quot; android:background=&quot;@mipmap/new_home_bubble&quot; android:flipInterval=&quot;3000&quot; android:inAnimation=&quot;@anim/home_notice_in&quot; android:outAnimation=&quot;@anim/home_notice_out&quot; /&gt; 进入动画home_notice_in： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;100.0%p&quot; android:toYDelta=&quot;0.0&quot;/&gt; &lt;alpha android:duration=&quot;500&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;&lt;/set&gt; 滑出动画home_notice_out: 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;0.0&quot; android:toYDelta=&quot;-100.0%p&quot;/&gt; &lt;alpha android:duration=&quot;500&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot;/&gt;&lt;/set&gt; new_notice_item布局自定义view填充ViewFlipper「这里demo使用的是ViewFlipper.add(view)方式」 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_value&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;20dp&quot; android:gravity=&quot;center_vertical&quot; android:ellipsize=&quot;end&quot; android:maxLines=&quot;1&quot; android:text=&quot;测试测试&quot; android:textColor=&quot;#256470&quot; android:textSize=&quot;20dp&quot;/&gt;&lt;/LinearLayout&gt; 2、代码逻辑实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends Activity &#123; private ViewFlipper mViewFlipper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mViewFlipper = (ViewFlipper) findViewById(R.id.vf_notice); &#125; private void initData() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;这是公告111&quot;); list.add(&quot;这是公告222&quot;); list.add(&quot;这是公告333&quot;); initNotice(list); &#125; //设置滑动轮播list private void initNotice(final List&lt;String&gt; list) &#123; mViewFlipper.removeAllViews();//先移除之前的所有view for (int i = 0; i &lt; list.size(); i++) &#123; View view = LayoutInflater.from(this).inflate(R.layout.new_notice_item, null); TextView tvValue = (TextView) view.findViewById(R.id.tv_value); tvValue.setText(list.get(i)); final int finalI = i; view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, list.get(finalI), Toast.LENGTH_SHORT).show(); &#125; &#125;); mViewFlipper.addView(view);//add方式进行添加 &#125; if (mViewFlipper.getChildCount() &gt; 1) &#123; mViewFlipper.startFlipping();//开启动画 &#125; else &#123; mViewFlipper.stopFlipping();//关闭动画 &#125; &#125;&#125; 二、ViewFlipper使用介绍 1、在xml布局中的方法介绍: 1234567android:autoStart： 设置自动加载下一个Viewandroid:flipInterval：设置View之间切换的时间间隔android:inAnimation： 设置切换View的进入动画android:outAnimation：设置切换View的退出动画 2、在代码中设置的方法介绍： 12345678910111213141516isFlipping： 判断View切换是否正在进行setFilpInterval：设置View之间切换的时间间隔startFlipping： 开始View的切换，而且会循环进行stopFlipping： 停止View的切换setOutAnimation：设置切换View的退出动画setInAnimation： 设置切换View的进入动画showNext： 显示ViewFlipper里的下一个ViewshowPrevious： 显示ViewFlipper里的上一个View demo 12345viewflipper.setInAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.home_notice_in)); viewflipper.setOutAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.home_notice_out)); viewflipper.showNext();","tags":[]},{"title":"Android 获取手机设备信息：名称、型号、系统版本号、厂商、设备制造商、SDK版本、系统语言等等","date":"2020-10-23T07:02:44.000Z","path":"2020/10/23/Android-获取手机设备信息：名称、型号、系统版本号、厂商、设备制造商、SDK版本、系统语言等等/","text":"常用的设备信息获取方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 设备名称 * * @return 设备名称 */ public static String getDeviceName() &#123; return android.os.Build.DEVICE; &#125;/** * 设备型号 * * @return 设备型号 */ public static String getModelName() &#123; return android.os.Build.MODEL; &#125; /** * 获取当前手机系统版本号 * * @return 系统版本号 */ public static String getSystemVersion() &#123; return android.os.Build.VERSION.RELEASE; &#125; /** * 获取厂商 * * @return 厂商 */ public static String getBrand() &#123; return android.os.Build.BRAND; &#125; /** * 获取设备制造商 * * @return 制造商 */ public static String getManufacturer() &#123; return android.os.Build.MANUFACTURER; &#125;/** * SDK 版本 * @return */ public static String getSDKVersion() &#123; SDKVersion = android.os.Build.VERSION.SDK ; return SDKVersion; &#125; /** * 获取当前手机系统语言。 * * @return 返回当前系统语言。例如：当前设置的是“中文-中国”，则返回“zh-CN” */ public static String getSystemLanguage() &#123; return Locale.getDefault().getLanguage(); &#125; /** * 获取当前系统上的语言列表(Locale列表) * * @return 语言列表 */ public static Locale[] getSystemLanguageList() &#123; return Locale.getAvailableLocales(); &#125;","tags":[]},{"title":"Android 获取应用「唯一标识符」——DeviceID「兼容android 10（Q）」","date":"2020-10-23T07:01:57.000Z","path":"2020/10/23/Android-获取应用「唯一标识符」——DeviceID「兼容android-10（Q）」/","text":"前言 更多方法请参考官方文档 一、Android Q 之前 1、所需权限需动态申请权限 1&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; 2、获取方法获取设备Id，IMEI等 123TelephonyManager telManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);telManager.getDeviceId();telManager.getImei(); 但是这个方法在Android Q之后就不生效了。 二、Android Q之后下面是我们项目使用的一种方法，当然网上还有其它很多种兼容方式可以参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static String getDeviceId(Context context) &#123; final int targetSdkVersion = context.getApplicationInfo().targetSdkVersion; if (targetSdkVersion &gt; Build.VERSION_CODES.P &amp;&amp; Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.P) &#123; return getUniqueID(context); &#125; else &#123; return getTelId(context); &#125;&#125; private static String getTelId(Context context) &#123; final TelephonyManager manager = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE); return manager.getDeviceId();&#125; private static String getUniqueID(Context context) &#123; String id = null; final String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID); if (!TextUtils.isEmpty(androidId) &amp;&amp; !&quot;9774d56d682e549c&quot;.equals(androidId)) &#123; try &#123; UUID uuid = UUID.nameUUIDFromBytes(androidId.getBytes(&quot;utf8&quot;)); id = uuid.toString(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; if (TextUtils.isEmpty(id)) &#123; id = getUUID(); &#125; return TextUtils.isEmpty(id) ? UUID.randomUUID().toString() : id;&#125; private static String getUUID() &#123; String serial = null; String m_szDevIDShort = &quot;35&quot; + Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + ((null != Build.CPU_ABI) ? Build.CPU_ABI.length() : 0) % 10 + Build.DEVICE.length() % 10 + Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 + Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 + Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 + Build.TAGS.length() % 10 + Build.TYPE.length() % 10 + Build.USER.length() % 10; //13 位 if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.P) &#123; try &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; serial = android.os.Build.getSerial(); &#125; else &#123; serial = Build.SERIAL; &#125; //API&gt;=9 使用serial号 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString(); &#125; catch (Exception exception) &#123; serial = &quot;serial&quot;; // 随便一个初始化 &#125; &#125; else &#123; serial = android.os.Build.UNKNOWN; // 随便一个初始化 &#125; //使用硬件信息拼凑出来的15位号码 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();&#125;","tags":[]},{"title":"Android Glide集成及使用注意事项——Glide 4.x","date":"2020-10-23T06:48:54.000Z","path":"2020/10/23/Android-Glide集成及使用注意事项——Glide-4-x/","text":"Glide 4.x集成及使用注意事项前言 原文请到lmz14大神参考使用更多用法请到官方指南参考使用 一、集成 1、project gradle 123repositories &#123; mavenLocal()&#125; 2、app gradle 123compile &#39;com.android.support:support-v4:25.3.1&#39;compile &#39;com.github.bumptech.glide:glide:4.0.0&#39;annotationProcessor &#39;com.github.bumptech.glide:compiler:4.0.0&#39; 3、混淆 123456789101112131415#glide4.0-keep public class * implements com.bumptech.glide.module.GlideModule-keep public class * extends com.bumptech.glide.AppGlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# for DexGuard only-keepresourcexmlelements manifest&#x2F;application&#x2F;meta-data@value&#x3D;GlideModule# 从glide4.0开始，GifDrawable没有提供getDecoder()方法，# 需要通过反射获取gifDecoder字段值，所以需要保持GifFrameLoader和GifState类不被混淆-keep class com.bumptech.glide.load.resource.gif.GifDrawable$GifState&#123;*;&#125;-keep class com.bumptech.glide.load.resource.gif.GifFrameLoader &#123;*;&#125; 4、在4.0中不用像3.X需要在AndroidManifest.xml配置GlideModule，而是通过注解继承AppGlideModule的子类来配置。 12345678910111213141516171819202122@GlideModulepublic class GlideConfiguration extends AppGlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; &#x2F;&#x2F;自定义缓存目录，磁盘缓存给150M 另外一种设置缓存方式 builder.setDiskCache(new InternalCacheDiskCacheFactory(context, &quot;GlideImgCache&quot;, 150 * 1024 * 1024)); &#x2F;&#x2F;配置图片缓存格式 默认格式为8888 builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_ARGB_8888)); ViewTarget.setTagId(R.id.glide_tag_id); &#125; &#x2F;** * 禁止解析Manifest文件 * 主要针对V3升级到v4的用户，可以提升初始化速度，避免一些潜在错误 * @return *&#x2F; @Override public boolean isManifestParsingEnabled() &#123; return false; &#125;&#125; 二、使用 1、基本用法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123Glide.with(context) .load(myUrl) .into(imageView); 取消加载同样很简单： 1Glide.with(context).clear(imageView); 尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。 2、加载圆形图 1234Glide.with(this) .load(R.mipmap.ic_splash_bg) .apply(bitmapTransform(new CropCircleTransformation())) .into(mImageHead); 3、模糊过滤 12345Glide.with(this) .load(R.mipmap.ic_splash_bg) .apply(bitmapTransform(new BlurTransformation( 25, 4))) .into(mImageView); 4、在 Application 模块中的使用在 Application 模块中，可创建一个添加有 @GlideModule 注解，继承自 AppGlideModule 的类。此类可生成出一个流式 API，内联了多种选项，和集成库中自定义的选项： 1234567package com.example.myapp;import com.bumptech.glide.annotation.GlideModule;import com.bumptech.glide.module.AppGlideModule;@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123;&#125; 生成的 API 默认名为 GlideApp ，与 AppGlideModule 的子类包名相同。在 Application 模块中将 Glide.with() 替换为 GlideApp.with()，即可使用该 API 去完成加载工作。 12345GlideApp.with(context) .load(myUrl) .placeholder(placeholder) .fitCenter() .into(imageView); 三、注意事项 1、使用GlideApp代替Glide，asBitmap、asGif、asDrawable、asFile都要放到load之前（glide3.7.0都是要在load之后调用）。 1234567public static void loadImg(Context context,String url, ImageView imageView)&#123; GlideApp.with(context) .asBitmap() .load(url) .placeholder(R.drawable.placeholder) &#x2F;&#x2F;设置资源加载过程中的占位符 .into(imageView); &#125; 2、占位符.placeholder(R.drawable.placeholder)不能用.9图，占位图片和加载的目标图片会同时显示，只是目标图片会先显示缩略图，然后显示正常。 3、加载gif图时，若调用dontAnimate()移除所有动画，gif就会加载失败。 4、设置淡入淡出动画glide3.7.0 1234567Glide.with(context) .load(url) .crossFade(100) &#x2F;&#x2F;系统渐变动画 .placeholder(R.drawable.placeholder) .fallback(R.drawable.fallback) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView); glide4.0 1234567GlideApp.with(context) .load(url) .transition(DrawableTransitionOptions.withCrossFade(100))&#x2F;&#x2F;淡入淡出100m .placeholder(R.drawable.placeholder) .fallback(R.drawable.fallback) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView); 5、磁盘缓存策略glide3.7.0 DiskCacheStrategy 的枚举意义：DiskCacheStrategy.NONE 什么都不缓存DiskCacheStrategy.SOURCE 只缓存全尺寸图DiskCacheStrategy.RESULT 只缓存最终的加载图DiskCacheStrategy.ALL 缓存所有版本图（默认行为） glide4.0 //DiskCacheStrategy.ALL 既缓存原始图片，也缓存转换过后的图片。// DiskCacheStrategy.NONE 不缓存任何内容// DiskCacheStrategy.DATA 在资源解码前就将原始数据写入磁盘缓存（即只缓存原始图片）// DiskCacheStrategy.RESOURCE 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源（即只缓存转换过后的图片）。// DiskCacheStrategy.AUTOMATIC 让Glide根据图片资源智能地选择使用哪一种缓存策略。//（默认采用）DiskCacheStrategy.AUTOMATIC策略/——————————————————————————-///源码 RequestOptions.javaprivate DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC; 6、占位符、错误图片设置glide4.0 若into中设置的是target，占位符（placeholder、error）需要在回调中再次设置，否则无效。 1234567891011121314151617181920212223242526272829303132public static void loadImg(String url, ImageView imageView) &#123; &#x2F;&#x2F;into中用Target，占位符（placeholder、error）需要在回调中设置 GlideApp.with(FanhuanApplication.getInstance().getApplication()) .asBitmap() .load(url) .placeholder(drawbleId) &#x2F;&#x2F;设置资源加载过程中的占位符 .fallback(drawbleId) .error(drawbleId) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(new SimpleTarget&lt;Bitmap&gt;() &#123; @Override public void onResourceReady(Bitmap resource, Transition&lt;? super Bitmap&gt; transition) &#123; imageView.setImageBitmap(resource); &#125; @Override public void onLoadFailed(@Nullable Drawable errorDrawable) &#123; super.onLoadFailed(errorDrawable); if(errorDrawable!&#x3D;null)&#123; imageView.setImageDrawable(errorDrawable); &#125; &#125; @Override public void onLoadStarted(@Nullable Drawable placeholder) &#123; super.onLoadStarted(placeholder); if(placeholder!&#x3D;null)&#123; imageView.setImageDrawable(placeholder); &#125; &#125; &#125;); &#125;","tags":[]},{"title":"Android Glide集成及使用注意事项——Glide 3.x","date":"2020-10-23T06:48:08.000Z","path":"2020/10/23/Android-Glide集成及使用注意事项——Glide-3-x/","text":"Glide 3.x集成及使用注意事项前言 更多用法请参考官方指南了解使用。 一、集成 1、project gradle 123repositories &#123; mavenCentral() &#125; 2、app gradle 12&#x2F;&#x2F;glide implementation &#39;com.github.bumptech.glide:glide:3.8.0&#39; 3、混淆 123456#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125; 二、使用及注意事项 1、基本方法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123456String url &#x3D; &quot;http:&#x2F;&#x2F;www.technosamrat.com&#x2F;wp-content&#x2F;uploads&#x2F;2012&#x2F;02&#x2F;Ocean-Wallpapers-Images1.jpg&quot;;ImageView imageView &#x3D; (ImageView) findViewById(R.id.imageView);Glide.with(context) .load(url) .into(imageView); 取消加载同样很简单： 1Glide.with(context).clear(imageView); 尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。 2、占位图设置Glide 也为我们提供这种方法 placeholder() 和 error() 12345Glide.with(context) .load(url) .placeholder(R.drawable.place_image)&#x2F;&#x2F;图片加载出来前，显示的图片 .error(R.drawable.error_image)&#x2F;&#x2F;图片加载失败后，显示的图片 .into(imageView); 3、缩略图Glide 的缩略图功能和占位图略有不同，占位图必须使用资源文件才行，而缩略图是动态的占位图可以从网络中加载。缩略图会在世纪请求加载完成或者处理完之后才显示。在原始图片到达之后，缩略图不会取代原始图片，只会被抹除。 Glide 为缩略图提供了2种不同的加载方式，比较简单的方式是调用 thumbnail() 方法，参数是 float 类型，作为其倍数大小。例如，你传入 0.2f 作为参数，Glide 将会显示原始图片的20%的大小，如果原图是 1000x1000 的尺寸，那么缩略图将会是 200x200 的尺寸。为缩略图明显比原图小得多，所以我们需要确保 ImageView 的 ScaleType 设置的正确。 1234Glide.with( context ) .load( url ) .thumbnail( 0.2f ) .into( imageView ); 与上面这种方式不同的是，这里的第一个缩略图请求是完全独立于第二个原始请求的。该缩略图可以是不同的资源图片，同时也可以对缩略图做不同的转换等等 123456789private void loadImageThumbnailRequest()&#123; &#x2F;&#x2F; setup Glide request without the into() method DrawableRequestBuilder&lt;String&gt; thumbnailRequest &#x3D; Glide.with( context ).load( url ); &#x2F;&#x2F; pass the request as a a parameter to the thumbnail request Glide.with( context ) .load( url ) .thumbnail( thumbnailRequest ) .into( imageView );&#125; 4、动画开关动画效果可以让图片加载变得更加的平滑，crossFade() 方法强制开启 Glide 默认的图片淡出淡入动画，当前版本3.7.0是默认开启的。crossFade() 还有一个重载方法 crossFade(int duration)。可以控制动画的持续时间，单位ms。动画默认的持续时间是300ms。既然可以添加动画，那肯定就可以设置没有任何淡出淡入效果，调用 dontAnimate() 123456Glide.with(context) .load(url) .crossFade()&#x2F;&#x2F;或者使用 dontAnimate() 关闭动画 .placeholder(R.drawable.place_image) .error(R.drawable.error_image) .into(imageView); 5、图片大小与裁剪使用 override(width,height) 方法，在图片显示到 ImageView 之前，重新改变图片大小。 1234Glide.with(context) .load(url) .override(width,height)&#x2F;&#x2F;这里的单位是px .into(imageView); 6、图片的缓存处理为了更快的加载图片，Glide默认帮我们开启了内存缓存和磁盘缓存。（1）内存缓存 内存缓存是 Glide 默认开启的，可以调用 skipMemoryCache(true) 告诉 Glide 跳过内存缓存。 （2）磁盘缓存 磁盘缓存是 Glide 默认开启的，可以调用 .diskCacheStrategy( DiskCacheStrategy.NONE )告诉 Glide 跳过磁盘缓存。 例子如下： 12345Glide.with(context) .load(url) .skipMemoryCache(true) .diskCacheStrategy( DiskCacheStrategy.NONE ) .into(imageView); （3）自定义磁盘缓存 DiskCacheStrategy 的枚举意义：DiskCacheStrategy.NONE 什么都不缓存DiskCacheStrategy.SOURCE 只缓存全尺寸图DiskCacheStrategy.RESULT 只缓存最终的加载图DiskCacheStrategy.ALL 缓存所有版本图（默认行为） 例子如下： 1234Glide.with(context) .load(url) .diskCacheStrategy( DiskCacheStrategy.SOURCE ) .into(imageView); 7、显示 Gif 和 Video显示 GIf 对于 Glide 来说一个比较特别的功能（ Picasso 暂时还不行）而且使用起来非常简单。 12345Glide.with( context ) .load( gifUrl ) .placeholder（ R.drawable.default ） .error( R.drawable.error ) .into( imageView ); 这段代码还有点问题，如果加载的不是一张 gif 图的话，是没有办法显示的。 12345Glide.with( context ) .load( gifUrl ) .asGif() .error( R.drawable.error ) .into( imageView ); 做以上修改，如果图片类型不是 Gif 图的话就会当作 load 失败来处理，因此 error() 会被回调。即使这个url的图片是好的，也是不会显示的。当然，如果你想显示 Gif 但只是向现实静态的图片你就可以这么做 12345Glide.with( context ) .load( gifUrl ) .asBitmap() .error( R.drawable.error ) .into( imageView ); 仅仅是显示 Gif 的第一帧图像，这样就可以保证图片的正常显示了。 最后的小惊喜，Glide 还能显示视频，但是只能够显示手机本地的视频，要是向现实网络上的视频的话，还是另寻他法吧！ 1234String filePath &#x3D; &quot;&#x2F;storrage&#x2F;emulated&#x2F;0&#x2F;Pictures&#x2F;video.mp4&quot;;Glide.with( context ) .load( Uri.fromFile( new File( filePath ) ) ) .into( imageView ); 以上就是Glide的基本用法了。","tags":[]},{"title":"代码对比工具「for Mac」","date":"2020-10-23T06:46:35.000Z","path":"2020/10/23/代码对比工具「for-Mac」/","text":"代码对比工具 链接: https://pan.baidu.com/s/1rFeRV_r4FJhhJpeN5X0ojw密码: vgnp","tags":[]},{"title":"Android dialog属性——点击「屏幕」或者「返回键」不消失","date":"2020-10-23T06:41:10.000Z","path":"2020/10/23/Android-dialog属性——点击「屏幕」或者「返回键」不消失/","text":"Dialog属性设置 在dialog.show();之前加： 12dialog.setCanceledOnTouchOutside(false);&#x2F;&#x2F;点击屏幕 dialog不消失dialog.setCancelable(false);&#x2F;&#x2F;点击屏幕或返回按钮 dialog不消失 屏蔽返回键,按返回键时不销毁当前activity 重写onKeyDown方法 1234567@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_BACK) &#123; return false;&#x2F;&#x2F;返回false进行拦截点击事件 &#125; return super.onKeyDown(keyCode, event);&#125;","tags":[]},{"title":"Android productFlavors的用法之——gradle 配置productFlavors &子模块配置productFlavors","date":"2020-10-23T06:34:24.000Z","path":"2020/10/23/Android-productFlavors的用法之——gradle-配置productFlavors-子模块配置productFlavors/","text":"前言 1234561、什么时候用到在子模块配置productFlavors 当子模块需要「配置不同信息」时，可以使用。 比如： （1）子模块在不同开发环境（uat、sit）使用不同的请求地址url，可以配置productFlavors用来区分调用即可； （2）当使用模块化开发时，可以专门抽出一个子模块配置productFlavors，这样其他模块只需要依赖该子模块，就可以全局使用子模块的配置信息；2、备注：「子模块配置样式」与「主模块配置样式」应保持一致； 配置1、主模块配置productFlavors app/build.gradle 123456789101112131415161718192021android &#123; ... flavorDimensions &#39;default&#39; &#x2F;&#x2F; 定义必要的配置 否则会报错 productFlavors &#123; dev &#123; dimension &#x3D; &#39;default&#39; &#x2F;&#x2F; 定义不同的包名 applicationId &#x3D; &quot;com.test.demo1&quot; &#x2F;&#x2F; 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;APPID_BUGLY&quot;, &#39;&quot;12345&quot;&#39; &#125; sit &#123; dimension &#x3D; &#39;default&#39; applicationId &#x3D; &quot;com.test.demo2&quot; buildConfigField &quot;String&quot;, &quot;APPID_BUGLY&quot;, &#39;&quot;67890&quot;&#39; &#125; &#125;&#125; 2、子模块配置productFlavors module/build.gradle 1234567891011121314151617181920android &#123;... publishNonDefault true flavorDimensions &#39;default&#39; productFlavors &#123; dev &#123; dimension &#x3D; &#39;default&#39; &#x2F;&#x2F; 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;158.223.12.22:8080&quot;&#39; buildConfigField &quot;String&quot;, &quot;RESOURCE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;158.223.12.22:8080&quot;&#39; &#125; sit &#123; dimension &#x3D; &#39;default&#39; &#x2F;&#x2F; 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;158.223.12.11:9090&quot;&#39; buildConfigField &quot;String&quot;, &quot;RESOURCE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;158.223.12.11:9090&quot;&#39; &#125; &#125;&#125; 只需要其他模块依赖该子模块，就可以全局使用该子模块的配置信息。所以可以抽出一个「公共子模块」专门用来做「配置信息」使用。","tags":[]},{"title":"Android时间获取之——Date、String、Long三种日期类型之间的相互转换","date":"2020-10-23T06:32:02.000Z","path":"2020/10/23/Android时间获取之——Date、String、Long三种日期类型之间的相互转换/","text":"date类型转换为String类型 12345&#x2F;&#x2F; formatType 格式为yyyy-MM-dd HH:mm:ss&#x2F;&#x2F;yyyy年MM月dd日 HH时mm分ss秒&#x2F;&#x2F;或者自定义格式 &#x2F;&#x2F; data Date类型的时间 public static String dateToString(Date data, String formatType) &#123; return new SimpleDateFormat(formatType).format(data); &#125; string类型转换为date类型 注：strTime的时间格式必须要与formatType的时间格式相同 12345678910&#x2F;&#x2F; strTime 要转换的string类型的时间，&#x2F;&#x2F; formatType 要转换的格式yyyy-MM-dd HH:mm:ss&#x2F;&#x2F;yyyy年MM月dd日HH时mm分ss秒， &#x2F;&#x2F; strTime的时间格式必须要与formatType的时间格式相同 public static Date stringToDate(String strTime, String formatType) throws ParseException &#123; SimpleDateFormat formatter &#x3D; new SimpleDateFormat(formatType); Date date &#x3D; null; date &#x3D; formatter.parse(strTime); return date; &#125; long转换为Date类型 12345678910&#x2F;&#x2F; currentTime 要转换的long类型的时间 &#x2F;&#x2F; formatType 要转换的时间格式yyyy-MM-dd HH:mm:ss&#x2F;&#x2F;yyyy年MM月dd日 HH时mm分ss秒 public static Date longToDate(long currentTime, String formatType) throws ParseException &#123; Date dateOld &#x3D; new Date(currentTime); &#x2F;&#x2F; 根据long类型的毫秒数生命一个date类型的时间 String sDateTime &#x3D; dateToString(dateOld, formatType); &#x2F;&#x2F; 把date类型的时间转换为string Date date &#x3D; stringToDate(sDateTime, formatType); &#x2F;&#x2F; 把String类型转换为Date类型 return date; &#125; date类型转换为long类型 1234&#x2F;&#x2F; date 要转换的date类型的时间 public static long dateToLong(Date date) &#123; return date.getTime(); &#125; long类型转换为String类型 12345678&#x2F;&#x2F; currentTime 要转换的long类型的时间 &#x2F;&#x2F; formatType 要转换的string类型的时间格式 public static String longToString(long currentTime, String formatType) throws ParseException &#123; Date date &#x3D; longToDate(currentTime, formatType); &#x2F;&#x2F; long类型转成Date类型 String strTime &#x3D; dateToString(date, formatType); &#x2F;&#x2F; date类型转成String return strTime; &#125; String类型转换为long类型注：strTime的时间格式和formatType的时间格式必须相同 12345678910111213&#x2F;&#x2F; strTime 要转换的String类型的时间 &#x2F;&#x2F; formatType 时间格式 &#x2F;&#x2F; strTime的时间格式和formatType的时间格式必须相同 public static long stringToLong(String strTime, String formatType) throws ParseException &#123; Date date &#x3D; stringToDate(strTime, formatType); &#x2F;&#x2F; String类型转成date类型 if (date &#x3D;&#x3D; null) &#123; return 0; &#125; else &#123; long currentTime &#x3D; dateToLong(date); &#x2F;&#x2F; date类型转成long类型 return currentTime; &#125; &#125;","tags":[]},{"title":"Android项目多渠道打包之——productFlavors的用法","date":"2020-10-23T06:16:25.000Z","path":"2020/10/23/Android项目多渠道打包之——productFlavors的用法/","text":"productFlavors的用处 创建不同的产品并为不同产品分配专有属性 配置不同的环境并为不同环境配置专有信息（sit、uat、pro…） 一、创建不同的「产品风味」，并为不同产品分配「专有属性」 在app:级别下的gradle文件中，加入productFlavors,并在productFlavors下创建产品A与B 12345678910111213141516171819202122232425262728293031productFlavors &#123; &#x2F;&#x2F;新建产品A A &#123; &#x2F;&#x2F;程序包名 applicationId &quot;com.wmj.a&quot; &#x2F;&#x2F;不同渠道号 manifestPlaceholders &#x3D; [UMC:&quot;product-Complete&quot;] &#x2F;&#x2F;versionName versionName &quot;1.0.0&quot; &#x2F;&#x2F;versionCode versionCode 1 &#x2F;&#x2F; 自定义buildConfig.java中的变量供代码中使用 buildConfigField(&quot;String&quot;, &quot;APPID&quot;, &quot;\\&quot;111111\\&quot;&quot;) buildConfigField(&quot;int&quot;, &quot;TYPE&quot;, &quot;1&quot;) &#125; &#x2F;&#x2F;新建产品B B &#123; &#x2F;&#x2F;程序包名 applicationId &quot;com.wmj.b&quot; &#x2F;&#x2F;不同渠道号 manifestPlaceholders &#x3D; [UMC:&quot;product-Temp&quot;] &#x2F;&#x2F;versionName versionName &quot;2.1.1&quot; &#x2F;&#x2F;versionCode versionCode 2 &#x2F;&#x2F; 自定义buildConfig.java中的变量供代码中使用 buildConfigField (&quot;String&quot;, &quot;APPID&quot;, &quot;\\&quot;222222\\&quot;&quot;) buildConfigField(&quot;int&quot;, &quot;TYPE&quot;, &quot;2&quot;) &#125; 这样，就可以区分A和B两个不同的产品了。A和B分别有自己不同的包名、渠道号、版本号等属性；当然，如果你想区分他们的其他属性比如不同的应用名、应用图标icon、引用不同代码资源、图片资源等等也是可以的；先在src目录下简历对应的文件夹，比如java代码则建立，product/java,res文件夹则建立product/res 二、配置不同的「开发环境」，并为不同环境配置「专有信息」有时候我们开发一个产品，需要经过开发环境、测试环境、生产环境等不同环境的测试才能正式发布；而不同的环境可能有不同的服务请求地址、不同的资源地址等等，这时候productFlavors就可以大显身手了。 123456789101112131415161718flavorDimensions &#39;default&#39; productFlavors &#123; sit &#123; dimension &#x3D; &#39;default&#39; &#x2F;&#x2F;自定义变量，如：配置sit环境的请求地址，不同环境的请求地址各不相同 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;123.123.123:8080&quot;&#39; &#125; uat &#123; dimension &#x3D; &#39;default&#39; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;124.124.124:8081&quot;&#39; &#125; pro &#123; dimension &#x3D; &#39;default&#39; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;125.125.125:8083&quot;&#39; &#125; &#125; 如上，配置了sit、uat、pro三个不同的环境，分别配有不同的服务请求地址，这样就不用每次打不同环境的apk时手动去修改配置文件了。 当然，上面两种使用方式也可以配合一起使用啊！就可以组合出不同产品在不同环境的apk了。 1234567891011121314151617181920212223242526272829303132flavorDimensions(&quot;name&quot;, &quot;build&quot;) productFlavors &#123; &#x2F;&#x2F;产品A A &#123; dimension &quot;name&quot; &#125; &#x2F;&#x2F;产品B B &#123; dimension &quot;name&quot; &#125; &#x2F;&#x2F;sit环境配置 sit &#123; dimension &#x3D; &#39;build&#39; &#x2F;&#x2F;自定义变量，如：配置sit环境的请求地址，不同环境的请求地址各不相同 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;123.123.123:8080&quot;&#39; &#125; &#x2F;&#x2F;uat环境配置 uat &#123; dimension &#x3D; &#39;build&#39; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;124.124.124:8081&quot;&#39; &#125; &#x2F;&#x2F;pro环境配置 pro &#123; dimension &#x3D; &#39;build&#39; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#39;&quot;http:&#x2F;&#x2F;125.125.125:8083&quot;&#39; &#125; &#125; 构建变体：[A, B] [sit, uat, pro] [Debug, Release] 到时这样组合就可以构建12个变体了。","tags":[]},{"title":"Android代码混淆之——依赖库Library中混淆配置方法","date":"2020-10-23T06:15:34.000Z","path":"2020/10/23/Android代码混淆之——依赖库Library中混淆配置方法/","text":"应用场景 我们自己新建一个Library给主工程引用； 引入三方Library给项目主工程引用； 这种情况下，一般我们需要对Library中的代码配置一些混淆规则，以免打混淆包某些方法不生效而无法使用。 一、在app模块写混淆规则（不建议使用）这种形式比较简单无脑，全部的混淆规则都写在了app模块里面，如果app模块依赖很多个Library模块那么app模块中的混淆规则将会非常的庞大，不利于代码的维护。 使用app模块编写所有混淆命令是基于Library模块当中不再编写混淆命令为前提。也就是Library模块中minifyEnabled都是false，如果强行将Library模块的minifyEnabled设置为true，那么程序将很大概率会崩溃掉，因为Library模块开启minifyEnabled后，app模块的混淆规则将无法作用到Library模块上，导致Library模块不该混淆的代码被混淆从而导致崩溃。 Library模块中minifyEnabled设置为false就会保证app模块的混淆规则作用到Library模块上，这也是Library模块中minifyEnabled设置为true还是false对组件化开发影响比较大的一个地方。 二、在各自Library模块写混淆规则（推荐做法）这是组件化/模块化开发最推荐的做法，最大的优点就是不用在app模块写上大量的混淆规则，只需要在相应模块写各自的混淆，方便混淆的维护。 在各自模块中配置混淆方法如下： 方式一：精简模式 123release &#123; consumerProguardFiles &#39;proguard-rules.pro&#39; &#125; 只需要配置一行代码即可，proguard-rules.pro就是该模块特定的混淆规则，使用这种配置最大的一个好处就是Library模块的是否混淆完全由app模块来决定；这种配置有一个非常重要的关键点：就是不能设置minifyEnabled true，因为设置为true之后，Library模块是否混淆的控制权将只能由该模块自身决定，app模块将无法控制Library模块的混淆与否。 方式二：常用模式第一步：开启混淆开关 123456buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; 第二步：配置gradle 12345678910defaultConfig &#123; minSdkVersion 22 targetSdkVersion 28 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#x2F;&#x2F; 配置此参数，方可生成混淆文件 consumerProguardFiles &quot;consumer-rules.pro&quot; &#125; 细心的朋友可以发现，第1步开启混淆开关配置的是proguard-rules.pro文件，而第2步配置的consumer-rules.pro文件；同时在我们Library目录下这两个混淆文件都存在。那这两文件又有什么区别呢？proguard-rules.pro文件是给Library模块自己使用的混淆规则；consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则； 而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。","tags":[]},{"title":"Windows 10 自带输入法微软拼音「简体」「繁体」切换快捷键","date":"2020-10-23T06:14:21.000Z","path":"2020/10/23/Windows-10-自带输入法微软拼音「简体」「繁体」切换快捷键/","text":"快捷键：Ctrl + Shift + F 经常无缘无故的不知道点击了什么导致输入法变成繁体，关键是不太记事每次都要查询一番，还是记下来吧。","tags":[]},{"title":"Android Studio常用快捷键(Mac)","date":"2020-10-23T06:13:39.000Z","path":"2020/10/23/Android-Studio常用快捷键-Mac/","text":"搜索查看类 编辑类编辑生成自动补全重构 选择, 移动 格式化 注释 运行调试类 测试类 版本控制类 窗口类","tags":[]},{"title":"手机Web前端调试页面之——设置debug开关方式","date":"2020-10-23T06:13:00.000Z","path":"2020/10/23/手机Web前端调试页面之——设置debug开关方式/","text":"条件：android4.4+ 配置在APP中启用 WebView 调试，开启调试后，Chrome DevTools才能对WebView进行远程调试 1WebView.setWebContentsDebuggingEnabled(true); 使用场景1.测试包如果团队中有Android开发人员能够提供测试包，只要在测试包中开启Webview的debug模式就可以了。 2.线上包对于线上的APP，一般debug开关都是关闭的，这就需要借助第三方工具，才能将debug开关打开，这个工具就是Xposed和WebviewDebugHook。 Xposed是一个框架，能够集成很多功能模块，这些模块能够在不修改APK的情况下，修改APP的运行方式。这里我们就需要WebviewDebugHook模块来开启APP的WebView debug模式。下面主要介绍一下安装的步骤： （1）获取手机的root权限，这个推荐使用KingRoot，可能一次获取root权限会失败，建议失败后多试几次； （2）下载适合版本的Xposed和WebviewDebugHook，并安装。 目前Xposed的官网上给出的链接是这样的： Android5.0+：https://forum.xda-developers.com/attachment.php 而WebviewDebugHook的安装文件是git项目https://github.com/feix760/WebViewDebugHook源码中的WebViewDebugHook.apk。 （3）激活Xposed和WebViewDebugHook模块 下图是Android5.0+下的截图，通过点击【安装/更新】激活Xposed，并切换菜单到模块功能，然后勾选上WebViewDebugHook。 安装完毕后，接下来就可以开开心心的调试Webview了。 另外还有两个小Tips： （1）访问chrome://inspect/#devices如果chrome没有检测到Remote Target中的页面，可能需要安装一下chrome的ADB插件； （2）对于腾讯系的APP，默认采用X5内核，需要将WebViewDebugHook的git目录下的debug.conf文件拷贝到SD卡的根目录下即可。","tags":[]},{"title":"Android Studio 清理缓存clean project与invalidate caches——解决项目一片报红，但是可以正常编译","date":"2020-10-23T06:12:10.000Z","path":"2020/10/23/Android-Studio-清理缓存clean-project与invalidate-caches——解决项目一片报红，但是可以正常编译/","text":"报错现象： Android studio 打开项目有时找不到R文件、 导入的资源、布局 、 jar包等等资源； Android studio打开项目一片报红，但是项目可以正常build打包； 很有可能是studio 缓存造成的。 解决方案： 方法1： 工具栏 Build –&gt; lean project 方法2： 使用invalidate caches restart备注：如果使用方法1无效，可以试一下方法2。本人项目就是使用方1无效，使用方法2有效解决问题。","tags":[]},{"title":"Android R(11) app targetSdkVersion30遇到的那些坑之——相册选择图片黑屏现象","date":"2020-10-23T06:11:03.000Z","path":"2020/10/23/Android-R-11-app-targetSdkVersion30遇到的那些坑之——相册选择图片黑屏现象/","text":"问题：当开发版本targetSdkVersion提升到30时： 在android10手机上安装app后，调用相册选择图片时，相册会出现图片全部都是黑屏现象，选择后的图片也是黑屏图片，而且无法获取图片的小大； 在android10以下的手机安装app，可以正常选择图片； 解决： 把targetSdkVersion降到28，在android10手机上则可以正常选择相册的图片。目前（2020.08.03）没有找到targetSdkVersion30的适配方法，如有大神有解决方法，望请告知，不甚感激。 备注： 当项目targetSdkVersion为28时，在android10手机安装了app；然后将项目targetSdkVersion升级到30，再在android10手机覆盖安装此app，则相册是可以正常选择图片的。 当项目targetSdkVersion直接为30，Android10手机之前并未在targetSdkVersion低版本安装过此app，直接在targetSdkVersion30第一次安装此app，则调用相册会出现黑屏现象。","tags":[]},{"title":"手机Web前端调试页面之——Chrome DevTools（谷歌浏览器）的模拟手机调试","date":"2020-10-23T06:10:15.000Z","path":"2020/10/23/手机Web前端调试页面之——Chrome-DevTools（谷歌浏览器）的模拟手机调试/","text":"Chrome DevTools（谷歌浏览器）的模拟手机调试前言 在客户端开发中，由于使用手机app加载webview页面，客户端与前端经常会出现数据交互情况；但是在手机中无法调试看到前端代码的步骤流程，有时候会导致数据交互失败查找问题比较麻烦；因此可以引入Chrome DevTools（谷歌浏览器）的模拟手机调试。 Chrome DevTools（谷歌浏览器）的模拟手机调试 Chrome DevTools远程调试Android和iOS页面 阅读 1. Chrome DevTools模拟手机调试 直接使用谷歌浏览器的开发者工具，可以参照下图，也可以使用快捷键F12或者ctrl+shift+I；个人觉得不管是哪个浏览器，直接先按下F12，一般都可以打开开发者工具，打不开再说嘛。 这种调试方式不仅能用于模拟手机调试还是主要的PC端页面调试的方式，这里主要说用于手机调试。 打开后看到类似如下界面的开发者调试界面，Elements可以查看文档元素，Console可以在线调试js和查看输出结果，Sources可以调试JS和查看依赖资源，Network查看所有的网络请求 在浏览器地址栏输入要调试的页面地址，选择模拟设备，然后就可以选择要调试的js调试了，右侧面板中有调试操作按钮；在Application面板中可以看到应用存储的数据Cookies什么的 如果没有需要模拟的机型怎么办？当然是增加了，打开DevTools的设置面板，左图中的Setting点开会出现右图，如下： 2. Chrome DevTools远程调试Android和iOS页面 电脑上安装新版谷歌浏览器，然后地址栏输入chrome://inspect会打开设备监视页面，这里可以监视到iOS和Android设备，如果界面和图中不一致请安装最新版浏览器Android: 前提： 1、手机和电脑使用usb连接，手机要开启usb调试模式(不同手机不一样) 2、手机上安装最新版谷歌浏览器并打开 会发现设备监视页面多出了一个华为设备，并且能看到当前手机上谷歌浏览器打开的网页的连接 a):可以在这里输入手机要打开的url然后open，手机上显示的当前页面就会改变 b):inspect表示开始调试当前页面，会打开调试面板(重要) c):focus tab，表示让手机显示当前这个连接 d):reload表示重新加载页面，也就是刷新 e):close表示关闭当前手机显示的页面接下来，点击inspect开始调试页面，注意如果google浏览器不能翻|墙的话，这个调试页面是打不开的，可以百度修改hosts文件翻|墙然后就可以像调试PC端网页一样远程调试手机网页了 iOS(window系统上，如果是macbook系统忽略此部分): 可以参考：http://www.cnblogs.com/kelsen/p/6402477.html 前提： 1、电脑安装iTunes软件，不然苹果手机不能正常被识别，安装好后数据线连接手机和电脑 2、打开手机的设置——&gt;Sarafi——&gt;高级——&gt;Web检查器——&gt;启用(默认是关闭的，将其打开) 3、下载ios-webkit-debug-prox代理(32位或者64位)，其作用就是在Chrome和Sarafi之间建立了一个代理，便于电脑的Chrome检测手机Sarafi打开的页面 4、在cmd中执行ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html，命令中-f是以谷歌内置的监视器来调试(默认使用远程的)启动后会监听9222端口，然后看到连接上了一台名为jiba的iOS设备，括号中为设备的UDID；然后看谷歌浏览器是否检查了这个端口，右图中有9222端口即可，没有就手动添加此时打开手机Sarafi浏览器，打开百度首页，发现浏览器能检测到，没看到就刷新这个监视界面，一般来说会在3秒内自动出现点击inspect同样出现了调试面板，如下，发现iOS调试的面板不能看到手机屏幕在电脑上的投影，不过这并不影响调试；但是可能会遇到在调试js时断点不生效的问题， 如果很不幸遇到这个问题的话，将图中红框中的按钮连续点击两次——先禁用断点再启动即可恢复端点调试功能，不知道为什么，猜测是这个过程中恢复了断点的状态；这个问题很奇葩。到这里使用Chrome调试iOS和Android就都完了，这种使用谷歌浏览器的方式，在Android上依赖于手机谷歌浏览器，在iOS上依赖Sarafi浏览器，受到具体软件的限制；不过可以理解，毕竟远程调试不如模拟调试简单 转载来源： 手机Web前端调试页面","tags":[]},{"title":"AndroidQ(10)分区存储完美适配","date":"2020-10-23T06:05:43.000Z","path":"2020/10/23/AndroidQ-10-分区存储完美适配/","text":"前言 Android Q文件存储机制修改成了沙盒模式 APP只能访问自己目录下的文件和公共媒体文件 对于AndroidQ以下，还是使用老的文件存储方式 背景 存储权限Android Q仍然使用READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE作为存储相关运行时权限，但现在即使获取了这些权限，访问外部存储也受到了限制，只能访问自身目录下的文件和公共内体文件。 外部存储结构划分1、公有目录：Downloads、Documents、Pictures 、DCIM、Movies、Music、Ringtones等地址：/storage/emulated/0/Downloads(Pictures)等公有目录下的文件不会跟随APP卸载而删除。2、APP私有目录地址：/storage/emulated/0/Android/data/包名/files私有目录存放app的私有文件，会随着App的卸载而删除。 适配方案 AndroidQ中使用ContentResolver进行文件的增删改查 1、获取(创建)自身目录下的文件夹获取及创建，如果手机中没有对应的文件夹，则系统会自动生成 123 &#x2F;&#x2F;在自身目录下创建apk文件夹File apkFile &#x3D; context.getExternalFilesDir(&quot;apk&quot;); 2、创建自身目录下的文件生成需要下载的路径，通过输入输出流读取写入 12345678910111213141516171819String apkFilePath &#x3D; context.getExternalFilesDir(&quot;apk&quot;).getAbsolutePath();File newFile &#x3D; new File(apkFilePath + File.separator + &quot;temp.apk&quot;);OutputStream os &#x3D; null;try &#123; os &#x3D; new FileOutputStream(newFile); if (os !&#x3D; null) &#123; os.write(&quot;file is created&quot;.getBytes(StandardCharsets.UTF_8)); os.flush(); &#125;&#125; catch (IOException e) &#123;&#125; finally &#123; try &#123; if (os !&#x3D; null) &#123; os.close(); &#125; &#125; catch (IOException e1) &#123; &#125;&#125; 3、创建公共目录下的文件夹通过MediaStore.insert写入 123456789101112131415if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123; return null;&#125;ContentResolver resolver &#x3D; context.getContentResolver();ContentValues values &#x3D; new ContentValues();values.put(MediaStore.Downloads.DISPLAY_NAME, fileName);values.put(MediaStore.Downloads.DESCRIPTION, fileName);&#x2F;&#x2F;设置文件类型values.put(MediaStore.Downloads.MIME_TYPE, &quot;application&#x2F;vnd.android.package-archive&quot;);&#x2F;&#x2F;注意MediaStore.Downloads.RELATIVE_PATH需要targetVersion&#x3D;29,&#x2F;&#x2F;故该方法只可在Android10的手机上执行values.put(MediaStore.Downloads.RELATIVE_PATH, &quot;Download&quot; + File.separator + &quot;apk&quot;);Uri external &#x3D; MediaStore.Downloads.EXTERNAL_CONTENT_URI;Uri insertUri &#x3D; resolver.insert(external, values);return insertUri; 4、公共目录下的指定文件夹下创建文件结合上面代码，我们主要是在公共目录下创建文件或文件夹拿到本地路径uri，不同的Uri，可以保存到不同的公共目录中。接下来使用输入输出流就可以写入文件 重点：AndroidQ中不支持file://类型访问文件，只能通过uri方式访问 123456789101112131415161718192021222324252627282930313233343536ContentResolver resolver &#x3D; context.getContentResolver();Uri insertUri &#x3D; resolver.insert(external, values);if(insertUri &#x3D;&#x3D; null) &#123; return;&#125;String mFilePath &#x3D; insertUri.toString();InputStream is &#x3D; null;OutputStream os &#x3D; null;try &#123; os &#x3D; resolver.openOutputStream(insertUri); if(os &#x3D;&#x3D; null)&#123; return; &#125; int read; File sourceFile &#x3D; new File(sourcePath); if (sourceFile.exists()) &#123; &#x2F;&#x2F; 文件存在时 is &#x3D; new FileInputStream(sourceFile); &#x2F;&#x2F; 读入原文件 byte[] buffer &#x3D; new byte[1024]; while ((read &#x3D; is.read(buffer)) !&#x3D; -1) &#123; os.write(buffer, 0, read); &#125; &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; try &#123; if (is !&#x3D; null) &#123; is.close(); &#125; if (os !&#x3D; null) &#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 5、通过MediaStore读取公共目录下的文件 1234567891011121314151617181920212223ParcelFileDescriptor parcelFileDescriptor &#x3D; null;FileDescriptor fileDescriptor &#x3D; null;Bitmap tagBitmap &#x3D; null;try &#123; parcelFileDescriptor &#x3D; context.getContentResolver().openFileDescriptor(uri, &quot;r&quot;); if (parcelFileDescriptor !&#x3D; null &amp;&amp; parcelFileDescriptor.getFileDescriptor() !&#x3D; null) &#123; fileDescriptor &#x3D; parcelFileDescriptor.getFileDescriptor(); &#x2F;&#x2F;转换uri为bitmap类型 tagBitmap &#x3D; BitmapFactory.decodeFileDescriptor(fileDescriptor); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (parcelFileDescriptor !&#x3D; null) &#123; parcelFileDescriptor.close(); &#125; &#125; catch (IOException e) &#123; &#125;&#125; 6、使用MediaStore删除文件 1context.getContentResolver().delete(fileUri, null, null); 转载来自 会撒娇的犀犀利","tags":[]},{"title":"Java中try()catch{}的使用方法：自动资源释放","date":"2020-10-23T06:04:51.000Z","path":"2020/10/23/Java中try-catch-的使用方法：自动资源释放/","text":"今天撸代码的时候发现了一段这样的代码 12345678910try( Connection conn&#x3D;DriverManager.getConnection(url,user,pass); Statement stmt&#x3D;conn.createStatement() ) &#123; boolean hasResultSet&#x3D;stmt.execute(sql); &#125; 和平常见的不一样，我们平常见的是这样的 123456789101112131415161718192021try&#123; fis&#x3D;new FileInputStream(&quot;src\\\\com\\\\ggp\\\\first\\\\FileInputStreamDemo.java&quot;); byte[]bbuf&#x3D;new byte[1024]; int hasRead&#x3D;0; while((hasRead&#x3D;fis.read(bbuf))&gt;0)&#123; System.out.println(new String(bbuf,0,hasRead)); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 如果{}中的代码块出现了异常，会被catch捕获，然后执行catch中的代码，接着执行finally中的码，其中catch中的代码有了异常才会被执行，finally中的代码无论有没有异常都会被执行， 而第一种情况的()中的代码一般放的是对资源的申请，如果{}中的代码出项了异常，（）中的资源就会被关闭，这在inputstream和outputstream的使用中会很方便例如 12345678910111213141516private static void customBufferStreamCopy(File source, File target) &#123; try (InputStream fis &#x3D; new FileInputStream(source); OutputStream fos &#x3D; new FileOutputStream(target))&#123; byte[] buf &#x3D; new byte[8192]; int i; while ((i &#x3D; fis.read(buf)) !&#x3D; -1) &#123; fos.write(buf, 0, i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 从网上查阅资料得知从 Java 7 build 105 版本开始，Java 7 的编译器和运行环境支持新的 try-with-resources 语句，称为 ARM 块(Automatic Resource Management) ，自动资源管理。 The try-with-resources statement is a try statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource. 带有resources的try语句声明一个或多个resources。resources是在程序结束后必须关闭的对象。try-with-resources语句确保在语句末尾关闭每个resources。任何实现java.lang.AutoCloseable,包括实现了java.io.Closeable的类，都可以作为resources使用。 自定义AutoClosable 实现 这个try-with-resources结构里不仅能够操作java内置的类。你也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。 AutoClosable 接口仅仅有一个方法，接口定义如下： 12345public interface AutoClosable &#123; public void close() throws Exception; &#125; 任何实现了这个接口的方法都可以在try-with-resources结构中使用。下面是一个简单的例子： 1234567891011public class MyAutoClosable implements AutoCloseable &#123; public void doIt() &#123; System.out.println(&quot;MyAutoClosable doing it!&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoClosable closed!&quot;); &#125;&#125; doIt()是方法不是AutoClosable 接口中的一部分，之所以实现这个方法是因为我们想要这个类除了关闭方法外还能做点其他事。 下面是MyAutoClosable 在try-with-resources结构中使用的例子： 12345678private static void myAutoClosable() throws Exception &#123; try(MyAutoClosable myAutoClosable &#x3D; new MyAutoClosable())&#123; myAutoClosable.doIt(); &#125;&#125; 当方法myAutoClosable.doIt()被调用时，下面是打印到System.out的输出： 123MyAutoClosable doing it!MyAutoClosable closed! 通过上面这些你可以看到，不论try-catch中使用的资源是自己创造的还是java内置的类型，try-with-resources都是一个能够确保资源能被正确地关闭的强大方法。 参考资料1、The try-with-resources Statement 转载来自1、https://blog.csdn.net/qq_33543634/article/details/807258992、https://blog.csdn.net/bigtree_3721/article/details/50508985","tags":[]},{"title":"原生WebView长截图 和 Tencent x5webview截长图","date":"2020-10-23T06:02:30.000Z","path":"2020/10/23/原生WebView长截图-和-Tencent-x5webview截长图/","text":"前言： 之前项目用的是原生webview，最近使用公司新框架使用的是x5的webview；正好有需求需要做长截图，踩坑之路开始。 1、原生WebView长截图 Android5.0及以上版本，Android对WebView进行了优化，为了减少内存使用和提高性能，使用WebView加载网页时只绘制显示部分。如果我们不做处理，仍然使用上述代码截图的话，就会出现只截到屏幕内显示的WebView内容，其它部分是空白的情况。这时候，我们通过调用WebView.enableSlowWholeDocumentDraw()方法可以关闭这种优化，但要注意的是，该方法需要在WebView实例被创建前就要调用，否则没有效果。 123if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.LOLLIPOP) &#123; android.webkit.WebView.enableSlowWholeDocumentDraw(); &#125; 1234567891011121314151617181920212223242526272829303132&#x2F;** * 原生WebView长截图 * * @param webView * @return *&#x2F; public static Bitmap getWebViewBtpBase64Str(WebView webView) &#123; Bitmap bitmap &#x3D; null; try &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; Picture snapShot &#x3D; webView.capturePicture(); bitmap &#x3D; Bitmap.createBitmap(snapShot.getWidth(), snapShot.getHeight(), Bitmap.Config.RGB_565); Canvas canvas &#x3D; new Canvas(bitmap); snapShot.draw(canvas); &#125; else &#123; float scale &#x3D; webView.getScale(); &#x2F;&#x2F;得到缩放后webview内容的高度 int webViewHeight &#x3D; (int) (webView.getContentHeight() * scale); bitmap &#x3D; Bitmap.createBitmap(webView.getWidth(), webViewHeight, Bitmap.Config.RGB_565); Canvas canvas &#x3D; new Canvas(bitmap); &#x2F;&#x2F;绘制 webView.draw(canvas); &#125; return bitmap; &#125; catch (OutOfMemoryError e) &#123; LogEx.e(&quot;ScreenUtils&quot;, e.getMessage(), e); &#125; catch (Exception e) &#123; LogEx.e(&quot;ScreenUtils&quot;, e.getMessage(), e); &#125; finally &#123; &#125; return &quot;&quot;; &#125; 2、Tencent x5webview截长图1234567891011121314151617181920212223&#x2F;** * Tencent x5webview截长图 * * @param webView * @return *&#x2F; public static Bitmap getX5WebViewBtpBase64Str(WebView webView) &#123; if (webView &#x3D;&#x3D; null) &#123; return null; &#125; int wholeWidth &#x3D; webView.getContentWidth(); int wholeHeight &#x3D; webView.getContentHeight(); Bitmap x5bitmap &#x3D; Bitmap.createBitmap(wholeWidth, wholeHeight, Bitmap.Config.RGB_565); Canvas x5canvas &#x3D; new Canvas(x5bitmap);&#x2F;&#x2F; x5canvas.scale((float) wholeWidth &#x2F; (float) webView.getContentWidth(), (float) wholeHeight &#x2F; (float)webView.getContentHeight()); if (webView.getX5WebViewExtension() &#x3D;&#x3D; null) &#123; return null; &#125; IX5WebViewExtension ix5WebViewExtension &#x3D; webView.getX5WebViewExtension(); ix5WebViewExtension.snapshotWholePage(x5canvas, false, false); Bitmap bitmap &#x3D; Bitmap.createBitmap(x5bitmap); return bitmap; &#125;","tags":[{"name":"Android Webview","slug":"Android-Webview","permalink":"http://example.com/tags/Android-Webview/"}]},{"title":"设置Android studio内存大小防止使用卡顿","date":"2020-10-23T06:01:38.000Z","path":"2020/10/23/设置Android-studio内存大小防止使用卡顿/","text":"前言： 最近开发中发现AS越来越卡，尤其使用CPU Profiler时直接卡死，顿时才想起来自己使用的是重新下载的最新版4.0.1的AS，并没有对其内存设置大小=。= 操作： 在AS的安装目录bin目录下找到studio64.exe.vmoptions文件； 设置JVM参数 Xms JVM启动的起始堆内存，堆内存是分配给对象的内存。 -Xmx AndroidStudio能使用的最大heap内存 -XX:ReservedCodeCacheSize 设置JIT java compiler在compile的时候的最大代码缓存 -XX:+UseCompressedOops 这个参数允许系统将代码里面的引用(reference)类型用32位存储，同时却能够让引用能够使用64位的内存大小。 -XX:SoftRefLRUPolicyMSPerMB 每兆堆空闲空间中SoftReference的存活时间(ms),越小越好 打开AS，打开Setting，选中Appearance，勾选Show memory indicator；就可以在AS的右下角看到内存实际使用情况；","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://example.com/tags/Android-Studio/"}]},{"title":"Android studio菜单栏被隐藏解决方案","date":"2020-10-23T06:00:21.000Z","path":"2020/10/23/Android-studio菜单栏被隐藏解决方案/","text":"今天使用android studio 开发项目，在想打开一个新的项目时，发现自己的File菜单栏不见了？？？一顿莫名其妙，不知道自己啥时候无意间点了什么快捷键把菜单栏隐藏了。 问题：android studio菜单栏被隐藏现象：解决： 点击右边【搜索】按钮； 输入搜索【Main menu】，下面就会出现View|Appearance：Main Menu一栏； 把右侧【OFF】切换到【ON】就ok了。 总结：不要手贱啊！！！","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://example.com/tags/Android-Studio/"}]},{"title":"Android fragment 4种切换方式及对应的生命周期步骤","date":"2020-10-23T05:58:44.000Z","path":"2020/10/23/Android-fragment-4种切换方式及对应的生命周期步骤/","text":"最近做项目使用到fragment切换，要求切换时对fragment页面进行刷新操作。 由于使用的是公司封装好的框架（暂无法改动），框架使用的是add hidden show的方式进行fragment切换，而这种方式切换fragment是不会重新走fragment的生命周期的，导致页面无法刷新。。。于是决定对fragment使用进行学习下 Fragment 1 切换到 Fragment 2时生命周期变化1、通过 add hide show 方式来切换 Fragment Fragment1 的生命周期变化为：onCreate（）、onCreateView、onStart（）、onResume（） 回调onHiddenChanged（） 方法 Fragment2 的生命周期变化为： onCreate（）、onCreateView、onStart（）、onResume（） Fragment 2 再次返回到 Fragment 1：不走任何生命周期方法但是回调 onHiddenChanged（）方法 123456789@Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); if (hidden) &#123; &#x2F;&#x2F;隐藏时所作的事情 &#125; else &#123; &#x2F;&#x2F;显示时所作的事情 &#125; &#125; boolean的值代表是否隐藏，当切换到当前fragment时hidden为false，切换到别到fragment时hidden为true。fragment的“显示”“隐藏”监听就这么简单。 总结：当以这种方式进行 Fragment 1 与 Fragment 2 的切换时，Fragment 隐藏的时候并不走 onDestroyView，所有的显示也不会走 onCreateView 方法，所有的 view 都会保存在内存 2、使用 replace 的方法进行切换时 载入Fragment 1时：Fragment1的生命周期：onCreate（）、onCreateView（）、onStart（）、onResume（） 切换到Fragment2时：Fragment1的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 2的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） Fragment 2切换回Fragment 1时：Fragment2的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 1的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） 总结：通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期 3、使用 ViewPager 进行切换时 当使用 ViewPager 与 Fragment 进行切换时，Fragment 会进行预加载操作 所有的 Fragment 都会提前初始—&gt;预加载； 初始化时 Fragment 们的生命周期： Fragment 1 的生命周期：onCreate（）、onCreateView（）Fragment 2 的生命周期：onCreate（）、 onCreateView（） Fragment 1 切换到 Fragment 2 的生命周期： Fragment 1 ：不走任何生命周期；Fragment 2 ：走 setUserVisVleHint（）方法 切回去也是一样的 注意： setUserVisVleHint（）方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法 1234567891011121314151617181920&#x2F;***第一个 Fragment 需要处理 setUserVisVleHint（）方法，设置为 setUserVisibleHint(true);*否则会产空指针异常，因为 setUserVisVleHint（）方法的优先级高于 onCreate（）方法。** @param savedInstanceState*&#x2F;@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; setUserVisibleHint(true); super.onActivityCreated(savedInstanceState);&#125; 主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题。setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。此时要对是否调用了onCreateView（）方法进行标记判断。 作者：吾乃韩小呆链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;c8f34229b6dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;** * 标志位，标志已经初始化完成 *&#x2F;private boolean isPrepared; @Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; &#x2F;&#x2F; 配置setUserVisibleHint（）方法 setUserVisibleHint(true); super.onActivityCreated(savedInstanceState);&#125; @Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view &#x3D; LayoutInflater.from(getActivity()).inflate(R.layout.fragment_a, container, false); &#x2F;&#x2F;已经初始化 isPrepared &#x3D; true; return view;&#125; @Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); &#x2F;&#x2F;可见的并且是初始化之后才加载 if (isPrepared &amp;&amp; isVisibleToUser) &#123; getList（）； &#125;&#125; 作者：吾乃韩小呆链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;c8f34229b6dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 4.attach和detach切换 方法和show hide一样，只是把show改为attach，把hide改为detach 从Fragment 1切换到Fragment 2的时候， Fragment 1调用detach()方法，onPause()-&gt;onStop()-&gt;onDestroyView(); Fragment 2 调用attach()方法，onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android命令行装包：卸载之前的包再重新安装新包","date":"2020-10-23T05:57:20.000Z","path":"2020/10/23/Android命令行装包：卸载之前的包再重新安装新包/","text":"Android命令行装包：卸载之前的包再重新安装新包 最近遇到早部分厂商手机（华为、小米、oppo、vivo等）中出现覆盖安装包无法安装现象，具体报错为：*系统已存在**包名的包，请卸载后在安装。然而明明已经是卸载了，还是一直报错无法安装成功，很让人头疼。 adb uninstall “包名” Success adb install -r “新包的路径”.apk","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android scrollview里面放listview 滚动出现的问题：listview展示不全","date":"2020-10-23T05:54:41.000Z","path":"2020/10/23/Android-scrollview里面放listview-滚动出现的问题：listview展示不全/","text":"问题：scrollview中加LinearLayout，然后在LinearLayout中又加了listview；导致listview展示不全，只展示出一条数据。 解决：先写一个工具类 123456789101112131415161718192021222324252627package com.android.fmis.client.util;import android.view.View;import android.view.ViewGroup;import android.widget.ListAdapter;import android.widget.ListView;public class ListHeightUtils &#123; public static void setListViewHeightBasedOnChildren(ListView listView) &#123; ListAdapter listAdapter &#x3D; listView.getAdapter(); if (listAdapter &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-condition return; &#125; int totalHeight &#x3D; 0; for (int i &#x3D; 0; i &lt; listAdapter.getCount(); i++) &#123; View listItem &#x3D; listAdapter.getView(i, null, listView); listItem.measure(0, 0); totalHeight +&#x3D; listItem.getMeasuredHeight(); &#125; ViewGroup.LayoutParams params &#x3D; listView.getLayoutParams(); params.height &#x3D; totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); listView.setLayoutParams(params); &#125; &#125; 在listview设置了adapter填充数据后调用此方法，重新设置一下listview的高度，就搞定了。 于此同时会产生一些问题 问题1：scrollview界面出来不是显示的最顶端【滚动条不是在最顶端】， 那么请在 listview填充后 这样设置 ScrollView s=(ScrollView)findViewById(R.id.scrollview1);s.smoothScrollTo(0, 20);","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android 监听应用「进入后台」「回到前台」的几种方式整理","date":"2020-10-23T05:47:45.000Z","path":"2020/10/23/Android-监听应用「进入后台」「回到前台」的几种方式整理/","text":"需求 最近接到一个新的需求：用户把app切换到后台，再次切回到app界面的时候会被要求重新输入登陆密码，这一需求的设计主要是出于安全性考虑。 这里就需要监听app的状态，从而判断app当前处于前台还是后台，再对其做不同的逻辑处理即可。 方案一：利用ActivityLifecycleCallbacks监听所有activity的生命周期 解释下registerActivityLifecycleCallbacks这个方法，只要app中有一个activity的生命周期改变了就会调用registerActivityLifecycleCallbacks的相应方法.比如说splashActivity走了onCreate方法，registerActivityLifecycleCallbacks的onActivityCreated也会被调用，括号中的参数activity就是splashActivity本身 1.在application中注册监听方法，一般写在onCreate方法中 12345678910private int countActivity = 0;//是否进入后台private boolean isBackground = false;@Override public void onCreate() &#123; super.onCreate(); //监听应用进入后台回到前台 initBackgroundCallBack(); &#125; 2.实现监听方法：具体实现onActivityStarted,onActivityStopped方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void initBackgroundCallBack() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; countActivity++; if (countActivity == 1 &amp;&amp; isBackground) &#123; Log.e(&quot;MyApplication&quot;, &quot;onActivityStarted: 应用进入前台&quot;); isBackground = false; //说明应用重新进入了前台 Toast.makeText(MyApplication.this, &quot;应用进入前台&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; countActivity--; if (countActivity &lt;= 0 &amp;&amp; !isBackground) &#123; Log.e(&quot;MyApplication&quot;, &quot;onActivityStarted: 应用进入后台&quot;); isBackground = true; //说明应用进入了后台 Toast.makeText(MyApplication.this, &quot;应用进入后台&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; &#125; &#125;); &#125; countActivity 是为了判断应用是否进入后台，当一个activity的调用onStart方法时countActivity就会+1，调用onStop方法时countActivity就会-1当所有activity的countActivity都=0时，说明所有的activity都在后台，即整个应用都处于后台 isBackground 是为了判断应用是否在后台，如果应用在后台又被调用了onActivityStarted方法，说明应用从后台回到前台 方案二：利用ActivityManager的RunningAppProcessInfo类 ActivityManager在整个系统里面起着非常重要的作用，主要为系统中运行着的activity交互提供接口，其中RunningAppProcessInfo类则封装了正在运行着的进程信息，当然也包含了正在运行的app的包名，因此我们可以activitymanager.getRunningAppProcesses()获取当前运行的app列表，对比自身的包名，来判断本身app是否处于前台运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * App前后台状态 */ public boolean isForeground = false; @Override protected void onResume() &#123; ...... if (isForeground == false) &#123; //由后台切换到前台 isForeground = true; &#125; &#125; @Override protected void onPause() &#123; ...... if (!isAppOnForeground()) &#123; //由前台切换到后台 isForeground = false; &#125; &#125; /** * 判断app是否处于前台 * * @return */ public boolean isAppOnForeground() &#123; ActivityManager activityManager = (ActivityManager) getApplicationContext() .getSystemService(Context.ACTIVITY_SERVICE); String packageName = getApplicationContext().getPackageName(); /** * 获取Android设备中所有正在运行的App */ List&lt;RunningAppProcessInfo&gt; appProcesses = activityManager .getRunningAppProcesses(); if (appProcesses == null) return false; for (RunningAppProcessInfo appProcess : appProcesses) &#123; // The name of the process that this object is associated with. if (appProcess.processName.equals(packageName) &amp;&amp; appProcess.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123; return true; &#125; &#125; return false; &#125; 通过ActivityManager来获取当前运行的app列表，然后判断我们的app是否处于前台，能基本达到我们的预期需求。但如果将上面代码放到每一个activity，或者activity基类里面，这消耗还是挺大的。而且而且，ActivityManager通过.getRunningAppProcesses()获取当前运行列表这个方法，在5.0以后已经被deprecated掉了 参考文献 1.Android 监听APP进入后台或切换到前台方案对比","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android自定义permission android:protectionLevel介绍","date":"2020-10-23T05:44:43.000Z","path":"2020/10/23/Android自定义permission-android-protectionLevel介绍/","text":"Android protectionLevel分4个级别： normal dangerous signature signatureOrSystem 如果定义的是normal或者dangerous：我们自己的应用需要去访问其对应受保护的资源时只需要在androidManifest.xml中添加相同的权限uses-permission 如果是signature：不仅需要添加相同的权限， 必须同时具有相同的签名。 如果是signatureOrSystem（这种权限的应用第三方的应用无法单独访问）：不仅要有相同的签名，而且签名必须是系统签名，此外可能还需要android:sharedUserId=”android.uid.system”。","tags":[{"name":"android:protectionLevel","slug":"android-protectionLevel","permalink":"http://example.com/tags/android-protectionLevel/"}]},{"title":"Android四大组件：BroadcastReceiver","date":"2020-10-23T01:35:41.000Z","path":"2020/10/23/Android四大组件：BroadcastReceiver/","text":"1. 定义 BroadcastReceiver即 广播，是一个全局的监听器，属于Android四大组件之一广播分为两个角色：广播发送者、广播接收者 2. 作用 监听 / 接收 应用 App 发出的广播消息，并 做出响应 3. 应用场景 Android不同组件间的通信（含 ：应用内 / 不同应用之间） 多线程通信 与 Android 系统在特定情况下的通信（如：电话呼入时、网络可用时） 4. 实现原理 ​— 5. 使用流程 5.1 自定义广播接收者BroadcastReceiver 继承BroadcastReceivre基类 必须复写抽象方法onReceive()方法 1.广播接收器接收到相应广播后，会自动回调 onReceive() 方法2.一般情况下，onReceive方法会涉及 与 其他组件之间的交互，如发送Notification、启动Service等3.默认情况下，广播接收器运行在 UI 线程，因此，onReceive()方法不能执行耗时操作，否则将导致ANR 代码范例 1234567891011// 继承BroadcastReceivre基类public class mBroadcastReceiver extends BroadcastReceiver &#123; // 复写onReceive()方法 // 接收到广播后，则自动调用该方法 @Override public void onReceive(Context context, Intent intent) &#123; //写入接收广播后的操作 &#125;&#125; 5.2 广播接收器注册 注册的方式分为两种：静态注册、动态注册 5.2.1 静态注册 注册方式：在AndroidManifest.xml里通过标签声明 属性说明： 12345678910111213141516171819202122&lt;receiver android:enabled=[&quot;true&quot; | &quot;false&quot;]//此broadcastReceiver能否接收其他App的发出的广播//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false android:exported=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot;//继承BroadcastReceiver子类的类名 android:name=&quot;.mBroadcastReceiver&quot;//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收； android:permission=&quot;string&quot;//BroadcastReceiver运行所处的进程//默认为app的进程，可以指定独立的进程//注：Android四大基本组件都可以通过此属性指定自己的独立进程 android:process=&quot;string&quot; &gt;//用于指定此广播接收器将接收的广播类型//本示例中给出的是用于接收网络状态改变时发出的广播 &lt;intent-filter&gt;&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 注册示例 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=&quot;.mBroadcastReceiver&quot; &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 当此 App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中。 5.2.2 动态注册 注册方式：在代码中调用Context.registerReceiver（）方法 具体代码如下： 12345678910111213141516171819202122232425262728// 选择在Activity生命周期方法中的onResume()中注册@Override protected void onResume()&#123; super.onResume(); // 1. 实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); // 2. 设置接收广播的类型 intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE); // 3. 动态注册：调用Context的registerReceiver（）方法 registerReceiver(mBroadcastReceiver, intentFilter); &#125;// 注册广播后，要在相应位置记得销毁广播// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 @Override protected void onPause() &#123; super.onPause(); //销毁在onResume()方法中的广播 unregisterReceiver(mBroadcastReceiver); &#125;&#125; 特别注意 动态广播最好在Activity 的 onResume()注册、onPause()注销。 对于动态广播，有注册就必然得有注销，否则会导致内存泄露。 5.2.3 两种注册方式的区别 5.3 广播发送者向AMS发送广播 5.3.1 广播的发送 广播 是 用”意图（Intent）“标识 定义广播的本质 = 定义广播所具备的“意图（Intent）” 广播发送 = 广播发送者 将此广播的“意图（Intent）”通过sendBroadcast（）方法发送出去 5.3.2 广播的类型 广播的类型主要分为5类： 普通广播（Normal Broadcast） 系统广播（System Broadcast） 有序广播（Ordered Broadcast） 粘性广播（Sticky Broadcast） App应用内广播（Local Broadcast） 1. 普通广播（Normal Broadcast） 即 开发者自身定义 intent的广播（最常用）。发送广播使用如下： 12345Intent intent = new Intent();//对应BroadcastReceiver中intentFilter的actionintent.setAction(BROADCAST_ACTION);//发送广播sendBroadcast(intent); 若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。如下mBroadcastReceiver则会接收上述广播 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=&quot;.mBroadcastReceiver&quot; &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name=&quot;BROADCAST_ACTION&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 若发送广播有相应权限，那么广播接收者也需要相应权限 ​ 2. 系统广播（System Broadcast） 3.有序广播（Ordered Broadcast） 4.App应用内广播（Local Broadcast） 2.3.4.类型的广播用法详见： Android四大组件：BroadcastReceiver史上最全面解析","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Hello World","date":"2020-10-22T07:38:46.973Z","path":"2020/10/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]