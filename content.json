[{"title":"Android 屏幕适配神器ScreenMatch","date":"2022-09-05T00:21:03.000Z","path":"2022/09/05/Android-屏幕适配神器ScreenMatch/","text":"@TOC 一、smallestWidth限定符 适配（推荐）1、smallestWidth 限定符适配原理 /——————————————————————————————————-1、smallestWidth 限定符适配原理与屏幕分辨率限定符适配原理一样，系统都是根据限定符去寻找对应的 dimens.xml 文件。/——————————————————————————————————-2、例如程序运行在最小宽度为 360dp 的设备上，系统会自动找到对应的values-sw360dp 文件夹下的 dimens.xml 文件。/——————————————————————————————————-3、区别：屏幕分辨率限定符适配是拿 px 值等比例缩放，而 smallestWidth限定符适配是拿 dp 值来等比缩放而已。需要注意的是“最小宽度”是不区分方向的，即无论是宽度还是高度，哪一边小就认为哪一边是“最小宽度”。如下分别为最小宽度为 360dp 与最小宽度为640dp 所对应的 dimens.xml 文件：/——————————————————————————————————- 2、为什么选择 smallestWidth 限定符适配？既然原理都一样，都需要多套 dimens.xml 文件，那为什么要选择 smallestWidth 限定符适配呢？ 1、屏幕分辨率限定符适配是根据屏幕分辨率的，Android 设备分辨率一大堆，而且还要考虑虚拟键盘，这样就需要大量的 dimens.xml 文件。因为无论手机屏幕的像素多少，密度多少，90% 的手机的最小宽度都为 360dp，所以采用 smallestWidth 限定符适配只需要少量 dimens.xml 文件即可。2、屏幕分辨率限定符适配采用的是 px 单位，而 smallestWidth 限定符适配采用的单位是 dp 和 sp，dp 和 sp 是 google 推荐使用的计量单位。又由于很多应用要求字体大小随系统改变，所以字体单位使用 sp 也更灵活。3、屏幕分辨率限定符适配需要设备分辨率与 values-xx 文件夹完全匹配才能达到适配，而 smallestWidth 限定符适配寻找 dimens.xml 文件的原理是从大往小找，例如设备的最小宽度为 360dp，就会先去找 values-360dp，发现没有则会向下找 values-320dp，如果还是没有才找默认的 values 下的 demens.xml 文件，所以即使没有完全匹配也能达到不错的适配效果。 3、使用步骤（重点在这）3.1、获取设计图最小宽度（单位为 dp） 蓝湖：开发平台切换到 Android，设计图宽度即为最小宽度。 psd 源文件：用像素大厨查看，设计图宽度即为最小宽度。（注意像素大厨需要选择与设计图对应的 dpi 进行显示） dp 单位的设计图：设计图宽度即为最小宽度。 px 单位的设计图：问 UI 设计师是几倍图，然后最小宽度 = 设计图宽度/倍数。 3.2、以设计图最小宽度作为基准值，生成所有设备对应的 dimens.xml 文件3.2.1、在 Android Studio 中安装 ScreenMatch 插件![在这里插入图片描述](https://img-blog.csdnimg.cn/807a5cb9ee4c492f9f99399c62bfa493.png =500x350) 3.2.2、在项目的默认 values 文件夹中需要一份 dimens.xml 文件其他大神 github 源码已经提供了一份，直接复制过来即可。![在这里插入图片描述](https://img-blog.csdnimg.cn/21873aa5081e412cb61102e12107540f.png =500x500) 3.2.3、执行生成 插件安装好后，在项目的任意目录或文件上右键，选择 ScreenMatch 选项。如下图： ![在这里插入图片描述](https://img-blog.csdnimg.cn/fba0214ebfb74c2bbf1fa0f795e6d9eb.png =500x350) 然后选择在哪个 module 下执行适配。即基于哪个 module 下的 res/values/dimens.xml 文件作为基准 dimens.xml 文件，生成的其他尺寸 dimens.xml 文件放在哪个 module 下。例如选择 app，然后点击 OK ，出现如下界面表示生成文件成功。如下图： ![在这里插入图片描述](https://img-blog.csdnimg.cn/fe3d445465f7449494be525b157ef8c6.png =500x600) 然后再看看 res 目录下会自动生成一堆 dimens.xml 文件，如下图： 通过上面的步骤就已经生成了所有设备对应的 dimens.xml 文件。 3.2.4、根据设计图填写最小宽度基准值，并填写需要适配的设备最小宽度 dp 值 步骤 3.2.3 是以插件默认的最小宽度基准值为 360dp，适配的设备最小宽度为320,360,384,392.7272,400,410,411.4285,432,480,533,592,600,640,662,720,768,800,811,820,960,961,1024,1280,1365（包含了平板和 TV ）生成的文件，但实际情况要根据设计图和需求设置。 例如设计图的最小宽度为 375dp，则需要更改最小宽度基准值为 375dp。 以上修改需要在配置文件里修改，即 screenMatch.properties 文件，该配置文件是执行完上面第 3 步后自动生成在项目的跟目录下的。如下图： 打开配置文件，修改下图中 1、3、4 的值即可。(图中单位均为 dp)1：最小宽度基准值，填写设计图的最小宽度值即可。2：插件默认适配的最小宽度值，即默认情况下会生成如下值的 dimens.xml 文件。3：需要适配的最小宽度值（如果是小数，则保留 4 位小数。例如 392.727272…，则取 392.7272），即你想生成哪些 dimens.xml 文件。4：忽略不需要适配的最小宽度值，即忽略掉插件默认生成的 dimens.xml 文件。 配置文件修改完成后，重新执行第 3 步，生成新的 dimens.xml 文件。 3.3、根据设计图标注，在布局写上对应的值 设计图标注多少 dp，布局中就写多少 dp ，非常方便！ 上传到蓝湖：显示多少 dp 就写多少 dp。psd 源文件：用像素大厨查看，显示多少 dp 就写多少 dp（注意像素大厨需要选择与设计图对应的 dpi 进行显示）dp 单位的设计图：标注多少 dp 就写多少 dp。px 单位的设计图：问 UI 设计师是几倍图，然后控件的宽度 = 设计图中控件标注的宽度/倍数（高度同理）。 举例：例如设计图上一个Button 的宽为 360dp，高为 50dp，字体大小为 15 sp，在布局中则这样使用： 12345&lt;Button android:layout_width=&quot;@dimen/dp_360&quot; android:layout_height=&quot;@dimen/dp_50&quot; android:textSize=&quot;@dimen/sp_15&quot;/&gt; 代码中动态设置 dp 或 sp：如果需要在代码中动态设置 dp 或 sp，则需要通过 getDimension（）方法获取对应资源文件下的 dp 或 sp 值再设置。如下： 123456789/*获取sp值*/float pxValue = getResources().getDimension(R.dimen.sp_15);//获取对应资源文件下的sp值int spValue = ConvertUtils.px2sp(this, pxValue);//将px值转换成sp值mTvShowParams.setTextSize(spValue);//设置文字大小/*获取dp值*/float pxValue2 = getResources().getDimension(R.dimen.dp_360);//获取对应资源文件下的dp值int dpValue = ConvertUtils.px2dp(this, pxValue2);//将px值转换成dp值 二、屏幕分辨率限定符 适配（不推荐）屏幕分辨率限定符适配需要在 res 文件夹下创建各种屏幕分辨率对应的 values-xxx 文件夹，如下图： 然后根据一个基准分辨率，例如基准分辨率为 1280x720，将宽度分成 720 份，取值为 1px720px，将高度分成 1280 份，取值为 1px1280px，生成各种分辨率对应的 dimens.xml 文件。如下分别为分辨率 1280x720 与 1920x1080 所对应的横向 dimens.xml 文件： 假设设计图上的一个控件的宽度为 720px，那么布局中就写 android:layout_width=&quot;@dimen/x720&quot; ，当运行程序的时候，系统会根据设备的分辨率去寻找对应的 dimens.xml 文件。例如运行在分辨率为 1280x720 的设备上，系统会自动找到对应的 values-1280x720 文件夹下的 lay_x.xml 文件，由上图可知 x720 对应的值为720.px，可铺满该屏幕宽度。运行在分辨率为 1920x1080 的设备上，系统会自动找到对应的 values-1920x1080 文件夹下的 lay_x.xml 文件，由上图可知 x720 对应的值为 1080.0px，可铺满该屏幕宽度。这样就达到了屏幕适配的要求！ 作者：KingWorld链接：https://www.jianshu.com/p/d204c684c240来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 三、原文作者作者：KingWorld链接：Android 屏幕适配神器ScreenMatch","tags":[]},{"title":"Android设置color透明度——颜色透明度对照表","date":"2022-08-30T08:58:11.000Z","path":"2022/08/30/Android设置color透明度——颜色透明度对照表/","text":"@[toc] 1、xml设置 设置其属性:android:background=”#AA9E9E9E”,其中前两位为透明度，后六位为颜色。 2、Java代码设置1234View v = findViewById(R.id.content);//找到你要设透明背景的layout 的idv.getBackground().setAlpha(100);//0~255透明度值 ，0为完全 3、颜色透明度对照表 例子：需求要求：颜色9E9E9E、不透明度40%最终颜色：#999E9E9E解释：不透明度40% = 透明度60%，对应透明度60%—99； 从FF开始表示完全不透明，到00表示完全透明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101100% — FF99% — FC98% — FA97% — F796% — F595% — F294% — F093% — ED92% — EB91% — E890% — E689% — E388% — E087% — DE86% — DB85% — D984% — D683% — D482% — D181% — CF80% — CC79% — C978% — C777% — C476% — C275% — BF74% — BD73% — BA72% — B871% — B570% — B369% — B068% — AD67% — AB66% — A865% — A664% — A363% — A162% — 9E61% — 9C60% — 9959% — 9658% — 9457% — 9156% — 8F55% — 8C54% — 8A53% — 8752% — 8551% — 8250% — 8049% — 7D48% — 7A47% — 7846% — 7545% — 7344% — 7043% — 6E42% — 6B41% — 6940% — 6639% — 6338% — 6137% — 5E36% — 5C35% — 5934% — 5733% — 5432% — 5231% — 4F30% — 4D29% — 4A28% — 4727% — 4526% — 4225% — 4024% — 3D23% — 3B22% — 3821% — 3620% — 3319% — 3018% — 2E17% — 2B16% — 2915% — 2614% — 2413% — 2112% — 1F11% — 1C10% — 1A9% — 178% — 147% — 126% — 0F5% — 0D4% — 0A3% — 082% — 051% — 030% — 00","tags":[]},{"title":"Android中的复制&粘贴—— ClipboardManager","date":"2022-08-30T07:25:34.000Z","path":"2022/08/30/Android中的复制-粘贴——-ClipboardManager/","text":"@[toc] 1、ClipboardManager ClipboardManager是Android系统剪贴板的主要类。使用剪切板功能主要包含以下三个类：ClipboardManager： 表示一个剪贴板ClipData： 剪贴板中保存的所有剪贴数据集（剪贴板可同时复制/保存多条多种数据条目）ClipData.Item： 剪贴数据集中的一个数据条目 1.1、复制12345678// 获取系统剪贴板ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);// 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）ClipData clipData = ClipData.newPlainText(null, &quot;需要复制的文本数据&quot;);// 把数据集设置（复制）到剪贴板clipboard.setPrimaryClip(clipData); 1.2、粘贴1234567891011// 获取系统剪贴板ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);// 获取剪贴板的剪贴数据集ClipData clipData = clipboard.getPrimaryClip();if (clipData != null &amp;&amp; clipData.getItemCount() &gt; 0) &#123; // 从数据集中获取（粘贴）第一条文本数据 CharSequence text = clipData.getItemAt(0).getText(); System.out.println(&quot;text: &quot; + text);&#125; 1.3、剪贴板的数据改变监听1234567891011121314// 获取系统剪贴板ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);// 添加剪贴板数据改变监听器clipboard.addPrimaryClipChangedListener(new ClipboardManager.OnPrimaryClipChangedListener() &#123; @Override public void onPrimaryClipChanged() &#123; // 剪贴板中的数据被改变，此方法将被回调 System.out.println(&quot;onPrimaryClipChanged()&quot;); &#125;&#125;);// 移除指定的剪贴板数据改变监听器// clipboard.removePrimaryClipChangedListener(listener); 1.4、清空剪切板内容1234567891011void clearClipboard() &#123; ClipboardManager manager = mClipboardManager; if (manager != null) &#123; try &#123; manager.setPrimaryClip(ClipData.newPlainText(null, null)); &#125; catch (Exception e) &#123; Log.i(TAG, &quot;clearClipboard: exception&gt;&gt;&quot; + e.getMessage()); &#125; &#125;&#125; 2、实战工具类封装如下： 1234567891011121314151617181920212223242526272829//保存文本内容到剪切板public void copyClicks(String text) &#123; Context context = getApplicationContext(); // 获取系统剪贴板 ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); // 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据） ClipData clipData = ClipData.newPlainText(null, text); // 把数据集设置（复制）到剪贴板 clipboard.setPrimaryClip(clipData); Toast.makeText(context, &quot;已复制到剪切板&quot;, Toast.LENGTH_SHORT).show(); &#125;//从剪切板粘贴文本 public String pasteClicks() &#123; String text = &quot;&quot;; Context context = getApplicationContext(); // 获取系统剪贴板 ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); // 获取剪贴板的剪贴数据集 ClipData clipData = clipboard.getPrimaryClip(); if (clipData != null &amp;&amp; clipData.getItemCount() &gt; 0) &#123; // 从数据集中获取（粘贴）第一条文本数据 text = clipData.getItemAt(0).getText().toString(); &#125; return text; &#125;","tags":[]},{"title":"RadioButton——下划线效果","date":"2022-08-30T03:16:45.000Z","path":"2022/08/30/RadioButton——下划线效果/","text":"@TOC 1、需求 在开发中，我们经常会要实现一个RadioGroup（**一个RadioGroup中包含多个RadioButton**）中点击某个按钮，然后去实现某个操作。这个时候要一个选中状态的标示，很多时候是在下面加一个横线，效果如下： 2、实现 通过xml文件来实现这个效果： 首先，我们肯定需要一个selector，关键是怎么在selector来实现下面的横线;（1）首先我们需要给radiobutton一个固定的高度，比如48dp;（2）然后要使用到layer-list，layer-list是用来叠加多个效果的，这里我们只有一个效果，在layer-list中，我们使用shape来实现横条，并且让他距离top44dp，这样横线的高度就是4dp，并且在下方显示。 最终整个xml文件代码如下： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:state_checked=&quot;true&quot;&gt; &lt;layer-list&gt; &lt;item android:top=&quot;44dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot; &gt; &lt;solid android:color=&quot;#ff0000&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item android:drawable=&quot;@color/transparent&quot;&gt;&lt;/item&gt;&lt;/selector&gt; 最后在radiobutton中设置android:background即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:orientation=&quot;vertical&quot; &gt;&lt;RadioGroup android:id=&quot;@+id/radioGroup1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;RadioButton android:id=&quot;@+id/radio0&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/button_underlin&quot; android:button=&quot;@null&quot; android:checked=&quot;true&quot; android:gravity=&quot;center&quot; android:text=&quot;咨询&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radio1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/button_underlin&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:text=&quot;热点&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radio2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/button_underlin&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:text=&quot;博客&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radio3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/button_underlin&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:text=&quot;推荐&quot; /&gt;&lt;/RadioGroup&gt;&lt;FrameLayout android:id=&quot;@+id/fragment&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; &gt;&lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 3、参考文献1、RadioButton点击带下划线效果2、RadioButton下划线效果的使用","tags":[]},{"title":"Android——自定义打包「修改apk文件名」","date":"2022-08-12T08:41:30.000Z","path":"2022/08/12/Android——自定义打包「修改apk文件名」/","text":"在app目录下build.gradle增加如下配置：123456789101112131415161718//打包时间static def releaseTime() &#123; return new Date().format(&quot;yyyyMMddHHmmss&quot;)&#125;android&#123; //修改生成的apk名字 android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&#x27;.apk&#x27;)) &#123; outputFileName = &quot;test名字&quot; + defaultConfig.versionName + &quot;-&quot; + releaseTime() + &quot;-&quot; + output.baseName + &quot;.apk&quot; &#125; &#125; &#125;&#125; demo实现：这里我把配置直接放在buildTypes里面也是可以实现的 12345678910111213141516171819202122232425262728buildTypes &#123; release &#123; debuggable false //是否开启debug模式 minifyEnabled true //开启混淆 zipAlignEnabled true //压缩优化 shrinkResources true //移出无用资源 proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-project.txt&#x27; signingConfig signingConfigs.release //修改生成的apk名字 android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; outputFileName = &quot;CBA_$&#123;variant.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.flavorName&#125;_$&#123;variant.buildType.name&#125;.apk&quot; &#125; &#125; &#125; debug &#123; debuggable true //是否开启debug模式 minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-project.txt&#x27; signingConfig signingConfigs.debug //修改生成的apk名字 android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; outputFileName = &quot;CBA_$&#123;variant.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.flavorName&#125;_$&#123;variant.buildType.name&#125;.apk&quot; &#125; &#125; &#125; &#125;","tags":[]},{"title":"Android 校验手机号——正则表达式","date":"2022-08-10T07:09:24.000Z","path":"2022/08/10/Android-校验手机号——正则表达式/","text":"@toc 1、粗略匹配手机号的正则： 第1位：1第2位：3-9 任意数字其他位：任意数字 12//正则表达式^1[3456789][0-9]&#123;9&#125;&amp; 2、精准匹配手机号的正则： 第1位：1第2、3位：3[0-9]、4[57]、5[012356789]、66、7[013678]、8[0-9]、9[89]其他位：任意数字 12//正则表达式^(13[0-9]|15[012356789]|17[013678]|18[0-9]|14[57]|19[89]|166)[0-9]&#123;8&#125;&amp; 3、校验手机号的方法12345678910111213public class MobileUtils &#123; //校验通过返回true，否则返回false public static boolean isMobile(String mobile) &#123; String str = mobile; String pattern = &quot;^(13[0-9]|15[012356789]|17[013678]|18[0-9]|14[57]|19[89]|166)[0-9]&#123;8&#125;&quot;; Pattern r = Pattern.compile(pattern); Matcher m = r.matcher(str); return m.matches(); &#125;&#125;","tags":[]},{"title":"GIT开发学习——git reset current branch to here","date":"2022-08-10T06:36:54.000Z","path":"2022/08/10/GIT开发学习——git-reset-current-branch-to-here/","text":"@toc 1、使用场景 提交了多次错误的提交，想回滚到之前的某次提交。 合并了错误的分支，想回滚到合并之前。 2、Android Studio开发工具回退 git reset current branch to here //是git命令中的一种回滚操作 1）在某次提交上，点击右键 Working Tree 当前的工作区域 Index/Stage 暂存区域，和git stash命令暂存的地方不一样。使用git add xx，就可以将xx添加近Stage里面 Repository 提交的历史，即使用git commit提交后的结果 2）git reset current branch to here的本质：是移动 HEAD 以及它所指向的 branch。几种模式的主要区别是： soft：重置位置的同时，保留working Tree工作目录和index暂存区的内容，只让repository中的内容和 reset 目标节点保持一致，因此原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和Reset节点之间的所有差异都会放到暂存区中。 mixed（默认）：重置位置的同时，只保留Working Tree工作目录的內容，但会将 Index暂存区 和 Repository 中的內容更改和reset目标节点一致，因此原节点和Reset节点之间的【差异变更集】会放入Working Tree工作目录中。所以效果看起来就是原节点和Reset节点之间的所有差异都会放到工作目录中。 hard：重置位置的同时，直接将 working Tree工作目录、 index 暂存区及 repository 都重置成目标Reset节点的內容，所以效果看起来等同于清空暂存区和工作区。 keep：重置位置的同时，直接将 working Tree工作目录 和 repository 都重置成目标Reset节点的內容，index 暂存区 的内容保持不变。 一般情况下，不要轻易使用hard模式。 3、git命令行回退1.首先查找版本号： 1git log 2.确定恢复到指定版本： 1git reset --hard f5c706a6 //f5c706a6为版本号 3.强制将本地代码同步到远程仓库： 1git push origin master --force //master主分支 4.error: Git:You are not allowed to force push code to a protected branch on this project 由于git 的保护机制，不能强制提交代码，需要在远程仓库的设置中，将代码保护去除，更新完代码，再保护即可。","tags":[]},{"title":"GIT开发学习——使用git stash暂存代码","date":"2022-08-10T02:51:47.000Z","path":"2022/08/10/GIT开发学习——使用git-stash暂存代码/","text":"@[toc] 1、为什么要用到git stash命令 当我们多分支开发时，当你在分支A开发某个功能，这时候生产出问题，需要你check out一份新的分支B来修改该bug。而你分支A的功能开发到一半，这时候A分支的已修改代码怎么办？ 方案一：提交已经修改的分支A的代码，但是这份修改代码并不完整，想当一次无效的提交； 方案二：直接切换到分支B，这时候分支A的代码：（1）如果选择smart checkout，会把A分支上的修改内容带到B分支；（2）如果选择force checkout，则会把A分支上的所有修改删除掉，相当于白写了。（这两种都不是我们想要的效果） 方案三：使用git stash命令：把分支A的修改暂存起来，切换到分支B修改bug，完成后再切回到分支A，再使用git stash pop取出暂存，完美保留分支A修改的代码。 2、git stash的一些相关命令 存储一个 stash 的情况（常用）123git stash //暂存本地修改的代码git stash show //查看刚才暂存的修改git stash pop //取出修改 存储多个 stash 的情况 12345git stash save &lt;message&gt; //给 stash 存储的修改起个名字git stash list //查看暂存区的所有暂存修改记录git stash pop //取出最近一次暂存并删除记录列表中对应记录git stash apply stash@&#123;X&#125; //取出相应的暂存git stash drop stash@&#123;X&#125; //将记录列表中取出的对应暂存记录删除","tags":[]},{"title":"GIT开发学习——git 合并代码出现merging dev-xxxx 无法提交拉代码解决","date":"2022-08-08T03:09:06.000Z","path":"2022/08/08/GIT开发学习——git-合并代码出现merging-dev-xxxx-无法提交拉代码解决/","text":"出现merging的原因: 当你合并代码合并到一半时候取消，出现这个是合并代码的一个状态 解决办法：使用以下两个命令1.将代码「回退」到提交代码的当前状态 1git reset --hard head 2.「提交」当前分支代码 1git push oringin dev xxx","tags":[]},{"title":"GIT开发学习——fatal: bad revision '7450ad67'","date":"2022-08-08T02:48:28.000Z","path":"2022/08/08/GIT开发学习——fatal-bad-revision-7450ad67/","text":"git仓库下拉了好几个分支，分别是开发分支A，测试分支B。现在在开发分支A开发完某个功能，commit到git上，commit的id为“7450ad67”；现在想把这次提交合并到B分支上打包给测试人员。 假如本地只有B分支的代码，直接在B分支上使用一下命令： 1234git cherry-pick 7450ad67//则报错：fatal: bad revision &#x27;7450ad67&#x27; 原因是本地B分支没有A分支的代码，应先拉取A分支的代码，步骤如下： 123451、git fetch --all2、git cherry-pick 7450ad673、git push 其实就是先更新，在使用cherry-pick进行合并。","tags":[]},{"title":"GIT开发学习——git pull失败 Invocation failed Unexpected end of file from server","date":"2022-07-12T06:17:25.000Z","path":"2022/07/12/GIT开发学习——git-pull失败-Invocation-failed-Unexpected-end-of-file-from-server/","text":"错误如下： 1234567891011121314151617181920212223242526Update failedInvocation failed Unexpected end of file from serverjava.lang.RuntimeException: Invocation failed Unexpected end of file from serverat org.jetbrains.git4idea.GitAppUtil.sendXmlRequest(GitAppUtil.java:30)at org.jetbrains.git4idea.http.GitAskPassApp.main(GitAskPassApp.java:58)Caused by: java.net.SocketException: Unexpected end of file from serverat java.base/sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:866)at java.base/sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:689)at java.base/sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:863)at java.base/sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:689)at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1615)at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1520)at org.apache.xmlrpc.DefaultXmlRpcTransport.sendXmlRpc(DefaultXmlRpcTransport... (show balloon) 原因：没有勾选Use credential helper（使用凭证），把红框勾上就ok了","tags":[]},{"title":"GIT开发学习——IDEA Smart Checkout和Force Checkout区别","date":"2022-07-12T06:11:14.000Z","path":"2022/07/12/GIT开发学习——IDEA-Smart-Checkout和Force-Checkout区别/","text":"IDEA 当在一个分支A上修改了内容没有提交，然后切换到另一个分支B时，可能会发生冲突。这时IDEA会弹出提示，问你要选择Smart Checkout还是Force Checkout: ![在这里插入图片描述](https://img-blog.csdnimg.cn/6aa19ffaffbe485ca1e24eb88db30d1d.png#pic_center =300x300) 选择Smart Checkout: IDEA会先执行stash命令，贮存这些未提交的修改，然后checkout 到分支B，在切换到分支B后，unstash 这些修改，所以A分支本地的这些修改会带到B分支上。 选择Force Checkout： 不会保留你的修改，切到另一个分支内容就消失了，且切回来原来分支也找不回，白写了。","tags":[]},{"title":"GIT开发学习——创建tag标签命令","date":"2022-07-12T00:43:07.000Z","path":"2022/07/12/GIT开发学习——创建tag标签命令/","text":"@[toc] 1、列出标签 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag： 123$ git tagv0.1v1.3 2、创建标签2.1、附注标签（annotated） 附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息。 在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项 12345$ git tag -a v1.4 -m &quot;my version 1.4&quot;$ git tagv0.1v1.3v1.4 使用 git show 命令可以看到标签信息与对应的提交信息 123456789101112$ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700 my version 1.4 commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 2.2、轻量标签（lightweight） 轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 1234567$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5 123456$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 2.3、后期打标签过去的提交打标签。 假设提交历史是这样的： 1234567891011$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）： 1$ git tag -a v1.2 9fceb02 1234567891011121314151617181920$ git tagv0.1v1.2v1.3v1.4v1.4-lwv1.5 $ git show v1.2tag v1.2Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Feb 9 15:32:16 2009 -0800 version 1.2commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile... 3、共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin [tagname]。 12345678$ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 4、删除标签 要删除掉你本地仓库上的标签，可以使用命令 git tag -d 。例如，可以使用下面的命令删除掉一个轻量级标签： 12$ git tag -d v1.4-lwDeleted tag &#x27;v1.4-lw&#x27; (was e7d5add) 应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 git push :refs/tags/ 来更新你的远程仓库： 123$ git push origin :refs/tags/v1.4-lwTo /git@github.com:schacon/simplegit.git - [deleted] v1.4-lw 5、检出标签如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用： 1234567891011121314151617$ git checkout 2.0.0Note: checking out &#x27;2.0.0&#x27;. You are in &#x27;detached HEAD&#x27; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch&gt; HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final $ git checkout 2.0-beta-0.1Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-finalHEAD is now at df3f601... add atlas.json and cover image","tags":[]},{"title":"GIT开发学习——合并分支的几种方法","date":"2022-07-07T09:30:21.000Z","path":"2022/07/07/GIT开发学习——合并分支的几种方法/","text":"@[TOC] 一、使用merge命令合并分支 1、目标：将dev分支合并到master分支1.1、首先切换到master分支上1git checkout master 1.2、如果是多人开发的话 需要把远程master上的代码pull下来12git pull origin master//如果是自己一个开发就没有必要了，为了保险期间还是pull 1.3、然后我们把dev分支的代码合并到master上12git merge dev //如果有冲突，手动解决冲突就行。 1.4、然后查看状态及执行提交命令12345678git statusOn branch master Your branch is ahead of &#x27;origin/master&#x27; by 12 commits. (use &quot;git push&quot; to publish your &gt;local commits) nothing tocommit, working tree clean//上面的意思就是你有12个commit，需要push到远程master上 &gt; 最后执行下面提交命令 git push origin master 二、合并某个分支上的单个commit（cherry-pick命令） 比如 feature 分支上的commit 82ecb31非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将82ecb31合并到master，而不合并feature上的其他commits;所以我们用git cherry-pick命令来做： 12git checkout master git cherry-pick 82ecb31 这样就好啦。现在82ecb31就被合并到master分支，并在master中添加了commit（作为一个新的commit）。cherry-pick和merge比较类似，如果git不能合并代码改动（比如遇到合并冲突），git需要你自己来解决冲突并手动添加commit。 这里git cherry-pick每次合并过来会显示文件冲突(其实并没有冲突代码部分，只需手动解决既可)。 三、使用开发工具 Android Studio 进行分支代码合并 1、开发代码在master分支，现在要将代码合到branch_cmb71分支2、首先，在idea左下角切换分支到branch_cmb71分支 3、点击右下角的Git:branch_cmb71,找到Local Branches,鼠标左键选中master分支，在弹出的框中，选择compare with Current 4、选择左上角的file，选择要合并的文件，右键点击get from branch 5、这样就把代码合并到branch_cmb71分支的本地仓库了，然后再进行commit，push操作就把代码提交到branch_cmb71分支的远程仓库了 四、参考资料1、git合并分支（一看就懂）2、Git合并指定文件到另一个分支3、IDEA如何使用git将当前分支中的部分节点代码合并到另一个分支上","tags":[]},{"title":"Android之CardView","date":"2022-06-21T07:47:25.000Z","path":"2022/06/21/Android之CardView/","text":"@[toc] 一、常用属性 1、cardBackgroundColor 设置背景色CardView是View的子类，View一般使用Background设置背景色，为什么还要单独提取出一个属性让我们来设置背景色呢？ 为了实现阴影效果，内部已经消耗掉了 Background 属性 2、cardCornerRadius 设置圆角半径3、contentPadding 设置内部paddingView提供了padding设置间距，为什么还要单独提取出一个属性？ 相同的原因，内部消耗掉了 padding 属性 4、cardElevation 设置阴影大小5、cardUseCompatPadding默认为false，用于5.0及以上，true则添加额外的 padding 绘制阴影 6、cardPreventCornerOverlap默认为true，用于5.0及以下，添加额外的 padding，防止内容和圆角重叠 二、属性效果展示 三、案例目标图： 1、布局搭建activity_main.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ListView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/listview_MsgList&quot; android:divider=&quot;@null&quot; android:background=&quot;#ffffff&quot; android:paddingTop=&quot;8dp&quot; &gt; &lt;/ListView&gt; item_msg.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;androidx.cardview.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardCornerRadius=&quot;8dp&quot; app:cardElevation=&quot;4dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginBottom=&quot;8dp&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageview_Image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:scaleType=&quot;centerCrop&quot; android:layout_margin=&quot;8dp&quot; tools:src=&quot;@drawable/img01&quot; /&gt; &lt;!-- tools 测试属性，只会在PreView中看到，运行时没有这些东西 --&gt; &lt;TextView android:id=&quot;@+id/textview_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16dp&quot; android:textStyle=&quot;bold&quot; tools:text=&quot;使用慕课网学习Android技术&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:layout_marginBottom=&quot;8dp&quot; tools:text=&quot;使用慕课网学习Android技术使用慕课网学习Android技术使用慕课网学习Android技术使用慕课网学习Android技术&quot; /&gt; &lt;/LinearLayout&gt; &lt;/androidx.cardview.widget.CardView&gt;&lt;/FrameLayout&gt; 2、功能实现MsgAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.cardviewstudy;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView;import java.util.List;/** * 继承BaseAdapter，实现4个方法 * Created by TMJ on 2020-02-20. */public class MsgAdapter extends BaseAdapter &#123; private Context mContext;//上下文环境 /** * 主要用于加载item_msg的布局 */ private LayoutInflater mInflater; private List&lt;Message&gt; mDatas; /** * 构造方法 */ public MsgAdapter(Context context, List&lt;Message&gt; datas) &#123; /** * 赋值 */ mContext = context; mInflater = LayoutInflater.from(context); mDatas = datas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = null; if (convertView == null)&#123; convertView=mInflater.inflate(R.layout.item_msg,parent,false); viewHolder=new ViewHolder(); /** * 获取子布局中三个控件：ImageView TextView TextView */ viewHolder.mIvImg=convertView.findViewById(R.id.imageview_Image); viewHolder.mTvTitle=convertView.findViewById(R.id.textview_title); viewHolder.mTvContent=convertView.findViewById(R.id.textview_content); convertView.setTag(viewHolder); &#125; else &#123; viewHolder= (ViewHolder) convertView.getTag(); &#125; Message message=mDatas.get(position); viewHolder.mIvImg.setImageResource(message.getImgResId()); viewHolder.mTvTitle.setText(message.getTitle()); viewHolder.mTvContent.setText(message.getContent()); return convertView; &#125; /** * 内部类：可省去findViewById的时间 */ public static class ViewHolder &#123; ImageView mIvImg; TextView mTvTitle; TextView mTvContent; &#125;&#125; MainActivity 1234567891011121314151617181920212223242526272829303132333435363738package com.example.cardviewstudy;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ListView mLvMsgList; private List&lt;Message&gt; mDatas = new ArrayList&lt;&gt;(); private MsgAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLvMsgList = findViewById(R.id.listview_MsgList); /** * 多调用两次，数据会更多 */ mDatas.addAll(MsgLab.generateMockList()); mDatas.addAll(MsgLab.generateMockList()); mAdapter=new MsgAdapter(this,mDatas); mLvMsgList.setAdapter(mAdapter); &#125;&#125; 效果图： 5.0以上 &lt;————&gt; 5.0以下 四、参考文献1、原文链接","tags":[]},{"title":"java.lang.IllegalStateException: Fragement no longer exists for key f0: index 0","date":"2022-05-13T07:42:00.000Z","path":"2022/05/13/java-lang-IllegalStateException-Fragement-no-longer-exists-for-key-f0-index-0/","text":"@[toc] 日常工作所遇bug记录：1、报错日志1234java.lang.IllegalStateException: Fragement no longer exists for key f0: index 0at android.support.v4.app.FragmentManagerImpl.getFragment(FragmentManager.java:564)at android.support.v4.app.FragmentStatePagerAdapter.restoreState(FragmentStatePagerAdapter.java:211)at android.support.v4.view.ViewPager.setAdapter(ViewPager.java:427) 2、报错原因： 1、Fragment为空2、Fragment已被销毁 3、分析原因 由于我项目中，使用Fragment + ViewPager + Fragment的方式；由于需求需要，ViewPager需要删除上次set 的adapter，并重新set 新的adapter，重新加载新的Fragment集合；当我点击按钮，进行清除上次的adapter内容，并添加新的adapter内容是，就会偶现报以上错误。 项目中使用的是 FragmentStatePagerAdapter； 4、解决方案4.1、方案1（建议） 此BUG的解法：就是在FragmentStatePagerAdapter的继承类里覆写此函数返回为空，这样FragmentManager.getFragment函数中就不满足第一个判断条件，不会执行后续代码也不会抛出异常了。 1234@Override public Parcelable saveState() &#123; return null; &#125; 4.2、方案二（不建议） 另一种方案说法是：不使用 FragmentStatePagerAdapter，改为使用 FragmentPagerAdapter；","tags":[]},{"title":"Java java.lang.ArithmeticException: / by zero问题解决","date":"2022-05-13T06:42:02.000Z","path":"2022/05/13/Java-java-lang-ArithmeticException-by-zero问题解决/","text":"问题描述： java.lang.ArithmeticException: / by zero 问题分析： 使用0作为除数导致了报错；只需要找到代码对应报错行数，检查除数的数值处理，使其不能为0即可。","tags":[]},{"title":"Android自定义View——自定义属性attrs.xml的使用","date":"2022-05-13T06:16:52.000Z","path":"2022/05/13/Android自定义View——自定义属性attrs-xml的使用/","text":"@[toc] 1、attrs.xml 的作用 使用attrs.xml文件，可以自己定义属性 2、在values文件夹下，新建一个attrs.xml文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;declare-styleable name=&quot;MyView&quot;&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt; 其中， 1&lt;declare-styleable name=&quot;MyView&quot;&gt; 表明样式名称为 MyView ，下面包含了两个自定义属性 textColor 和 textSize ，其中textColor是颜色(color)类的属性，textSize是尺寸(dimension)类的属性 3、自定义 MyView1234567891011121314151617181920212223242526272829303132333435363738public class MyView extends View &#123; private Paint mPaint; private static final String mString = &quot;Welcome to BaiYe&#x27;s blog&quot;; public MyView(Context context) &#123; this(context,null); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); //TypedArray是一个数组容器 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView); //这里的属性是:名字_属性名 int textColor = a.getColor(R.styleable.MyView_textColor, 0XFFFFFFFF); //防止在XML文件里没有定义，就加上了默认值36 float textSize = a.getDimension(R.styleable.MyView_textSize, 36); mPaint.setTextSize(textSize); mPaint.setColor(textColor); a.recycle();//我的理解是：返回以前取回的属性，供以后使用。以前取回的可能就是textSize和textColor初始化的那段 &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 设置填充 mPaint.setStyle(Paint.Style.FILL); // 画一个矩形,前俩个是矩形左上角坐标，后面俩个是右下角坐标// mPaint.setColor(Color.BLACK); canvas.drawRect(new Rect(10, 10, 100, 100), mPaint); // 绘制文字 canvas.drawText(mString, 60, 410, mPaint); &#125;&#125; 4、xml 布局内容:使用自定义的MyView1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:test=&quot;http://schemas.android.com/apk/res-auto&quot;//一定记得添加前缀 android:id=&quot;@+id/activity_attrs_actiity&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.lizi.newset.CustomView.attrs.AttrsActivity&quot;&gt; &lt;com.lizi.newset.CustomView.attrs.MyView android:id=&quot;@+id/myView&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;wrap_content&quot; test:textSize=&quot;50px&quot; test:textColor=&quot;#ff00ff&quot;/&gt; /&gt;&lt;/RelativeLayout&gt; 5、自定义属性5.1、reference：参考某一资源ID123456789101112&lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;background&quot; format = &quot;reference&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;ImageView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:background = &quot;@drawable/图片ID&quot; /&gt; 5.2、color：颜色值12345678910111213&lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;textColor&quot; format = &quot;color&quot; /&gt;&lt;/declare-styleable&gt;eg: &lt;TextView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:textColor = &quot;#00FF00&quot; /&gt; 5.3、boolean：布尔值123456789101112&lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;focusable&quot; format = &quot;boolean&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;Button android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:focusable = &quot;true&quot;/&gt; 5.4、dimension：尺寸值12345678910111213&lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;layout_width&quot; format = &quot;dimension&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;com.lizi.newset.CustomView.attrs.MyView android:id=&quot;@+id/myView&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;wrap_content&quot; test:textSize=&quot;50px&quot; test:textColor=&quot;#ff00ff&quot;/&gt; 5.5、float：浮点值12345678910111213&lt;declare-styleable name = &quot;AlphaAnimation&quot;&gt; &lt;attr name = &quot;fromAlpha&quot; format = &quot;float&quot; /&gt; &lt;attr name = &quot;toAlpha&quot; format = &quot;float&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;alpha android:fromAlpha = &quot;1.0&quot; android:toAlpha = &quot;0.7&quot;/&gt; 5.6、string：字符串12345678910111213&lt;declare-styleable name = &quot;MapView&quot;&gt; &lt;attr name = &quot;apiKey&quot; format = &quot;string&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;com.google.android.maps.MapView android:layout_width = &quot;fill_parent&quot; android:layout_height = &quot;fill_parent&quot; android:apiKey = &quot;0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g&quot; /&gt; 5.7、integer：整型值 || fraction：百分数123456789101112131415161718192021&lt;declare-styleable name = &quot;AnimatedRotateDrawable&quot;&gt; &lt;attr name = &quot;visible&quot; /&gt; &lt;attr name = &quot;frameDuration&quot; format=&quot;integer&quot; /&gt; &lt;attr name = &quot;framesCount&quot; format=&quot;integer&quot; /&gt; &lt;attr name = &quot;pivotX&quot; format = &quot;fraction&quot;/&gt; &lt;attr name = &quot;pivotY&quot; format = &quot;fraction&quot;/&gt; &lt;attr name = &quot;drawable&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;animated-rotate xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; android:drawable = &quot;@drawable/图片ID&quot; android:pivotX = &quot;50%&quot; android:pivotY = &quot;50%&quot; android:framesCount = &quot;12&quot; android:frameDuration = &quot;100&quot; /&gt; 5.8、enum：枚举值1234567891011121314151617&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;orientation&quot;&gt; &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;vertical&quot; value=&quot;1&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;eg:&lt;LinearLayout xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; android:orientation = &quot;vertical&quot; android:layout_width = &quot;fill_parent&quot; android:layout_height = &quot;fill_parent&quot;&gt;&lt;/LinearLayout&gt; 5.9、flag 位或运算12345678910111213141516171819202122232425262728 &lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;windowSoftInputMode&quot;&gt; &lt;flag name = &quot;stateUnspecified&quot; value = &quot;0&quot; /&gt; &lt;flag name = &quot;stateUnchanged&quot; value = &quot;1&quot; /&gt; &lt;flag name = &quot;stateHidden&quot; value = &quot;2&quot; /&gt; &lt;flag name = &quot;stateAlwaysHidden&quot; value = &quot;3&quot; /&gt; &lt;flag name = &quot;stateVisible&quot; value = &quot;4&quot; /&gt; &lt;flag name = &quot;stateAlwaysVisible&quot; value = &quot;5&quot; /&gt; &lt;flag name = &quot;adjustUnspecified&quot; value = &quot;0x00&quot; /&gt; &lt;flag name = &quot;adjustResize&quot; value = &quot;0x10&quot; /&gt; &lt;flag name = &quot;adjustPan&quot; value = &quot;0x20&quot; /&gt; &lt;flag name = &quot;adjustNothing&quot; value = &quot;0x30&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;eg:&lt;activity android:name = &quot;.StyleAndThemeActivity&quot; android:label = &quot;@string/app_name&quot; android:windowSoftInputMode = &quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name = &quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 6、属性定义时可以同时定义多种类型值12345678910111213&lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;background&quot; format = &quot;reference|color&quot; /&gt;&lt;/declare-styleable&gt;eg:&lt;ImageView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:background = &quot;@drawable/图片ID|#00FF00&quot; /&gt; 7、参考文章Android中attrs.xml文件的使用详解Android中自定义属性（attrs.xml，TypedArray的使用）","tags":[]},{"title":"Android报错——this Activity already has an action bar supplied by the window decor. Do not request Wind","date":"2022-03-30T08:18:51.000Z","path":"2022/03/30/Android报错——this-Activity-already-has-an-action-bar-supplied-by-the-window-decor-Do-not-request-Wind/","text":"1、问题日志今天在 Android 12 新版本手机上跑一个demo出现崩溃，崩溃日志如下 123456java.lang.IllegalStateException: This Activity already has an action bar supplied by the window decor. Do not requestWindow.FEATURE_SUPPORT_ACTION_BAR and set windowActionBar to false in your theme t 2、问题原因由于我在代码中使用了ToolBar，并在activity中调用了setSupportActionBar(toolbar);在这里插入图片描述 3、解决方案给报错的activity增加对应的theme或者修改theme主题 12345&lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 4、备注我做的这个Activity是用Toolbar来替代ActionBar，因此需要指定一个不带ActionBar的theme主题。 通常有两种可以选择：Theme.AppCompat.NoActionBarTheme.AppCompat.Light.NoActionBar第一个表示深色主题，它会将界面的主题颜色设置成深色，陪衬颜色设为淡色。第二种表示淡色主题，她会将界面的主题颜色设置为淡色，而陪衬颜色设置为深色。 5、参考文献小温同学ing大果梨qq_35224673","tags":[]},{"title":"SVN项目迁移到GIT并保留commit记录 && 获取Git提交计数","date":"2022-01-24T06:17:13.000Z","path":"2022/01/24/SVN项目迁移到GIT并保留commit记录-获取Git提交计数/","text":"@[toc] 一、SVN项目迁移到GIT并保留commit记录1. 编辑userinfo.txt格式为svn_username=git_username，提交记录里出现的所有svn_user都要有对应git_user svn用户 = GitLab用户&lt;GitLab用户邮箱&gt; 12svn_user1 = git_user1 &lt;git_user1@xxx.com&gt;svn_user2 = git_user2 &lt;git_user2@xxx.com&gt; 2. 从svn拉取代码配置git信息： 12git config --global user.name &quot;YOUR_USERNAME&quot;git config --global user.email &quot;YOUR_EMAIL&quot; 查看配置: 1git config --list 拉取代码（项目越大，花费时间越多）： 1git svn clone -r 282506:HEAD svn_url --no-metadata -A userinfo_path local_path -r 282506:HEAD 代表从svn的282506版本到最新版本的提交记录，避免从第一个版本拉取数据量过大，操作耗时高。 如果需要拉取所有记录，可去除 -r 282506:HEAD svn_url 你的svn项目地址 –no-metadata 防止git拉取无用的SVN附加信息 local_path 为git clone下来的svn目录，会自动新建 -A userinfo_path 你的userinfo.txt路径 3. 提交代码到gita. 使用http传输：项目总大小不大于50M12cd localpathgit remote add origin https://gitee.com/xxx/xxx.git 查看关联情况: 1git remote -v 如果关联有误，可以删除关联： 1git remote rm origin b. 使用ssh传输：项目总大小大于50M生成公钥： 12ssh-keygen –t rsa –C &quot;YOUR_EMAIL&quot;cat ~/.ssh/id_rsa.pub 将生成的公钥，复制到你的gitee/gitlab ssh公钥设置 测试是否能用ssh登录git： 1ssh -T git@gitee.com 提交代码： 1git remote set-url origin git@gitee.com:xxxx/xxx.git 4. push代码到远端1git push -u origin master 5.操作实例123456789git config --global user.name &quot;zhanghan&quot;git config --global user.email &quot;zhanghan@gdyd.com&quot;git svn clone --no-metadata -A userinfo.txt https://10.66.0.1/eip-ng/branches/eip-docx docxcd docxssh-keygen –t rsa –C &quot;zhanghan@gdyd.com&quot;cat ~/.ssh/id_rsa.pub在gitee官网添加ssh公钥git remote set-url origin git@gitee.com:gdydit_eip/docx.gitgit push -u origin master 二、获取Git提交计数获取Git存储库的提交次数，有点像SVN版本号,目标是将其用作唯一的，递增的内部版本号。 1git log --pretty=format:&#x27;&#x27; | wc -l 12345要获取所有分支的提交计数：git rev-list --all --count要获取修订的提交计数（HEAD，，master提交哈希）：git rev-list --count &lt;revision&gt; 123456返回按提交者分组的提交计数：git shortlog -s输出：14 John lennon9 Janis Joplin 三、参考文献SVN项目迁移到GIT并保留commit记录如何获取Git提交计数","tags":[]},{"title":"Windows和Mac命令行查看文件的MD5｜一般用于校验文件一致性","date":"2022-01-11T02:56:59.000Z","path":"2022/01/11/Windows和Mac命令行查看文件的MD5｜一般用于校验文件一致性/","text":"@[toc] 一、Windows自带命令行查看文件的MD5、SHA1、SHA2561234//D:\\1.exe 为待测试文件路径 certutil -hashfile D:\\1.exe MD5certutil -hashfile D:\\1.exe SHA1certutil -hashfile D:\\1.exe SHA256 二、Mac命令行生成文件的MD51、Mac命令行生成「字符串」的MD5 使用echo和管道 12echo &quot;string&quot; | md5b80fa55b1234f1935cea559d9efbc39a 直接使用md5 12md5 &lt;&lt;&lt; &quot;string&quot;b80fa55b1234f1935cea559d9efbc39a 使用md5 -s “string” 12md5 -s &quot;string&quot;MD5 (&quot;string&quot;) = b45cffe084dd3d20d928bee85e7b0f21 第三个的结果和前两个的结果不通的原因是 echo 默认会在行尾追加一个换行符，可以通过echo -n “string” 或者 echo “string\\c”来去掉换行符 12345echo -n &quot;string&quot; | md5b45cffe084dd3d20d928bee85e7b0f21 echo &quot;string\\c&quot; | md5b45cffe084dd3d20d928bee85e7b0f21 2、Mac命令行生成「文件」的MD5 直接 md5+文件路径 12apple@fenglolodeMacBook-Pro ~ % md5 /Users/apple/Desktop/index.html MD5 (/Users/apple/Desktop/index.html) = 4732e3fb9a9999a658fe1cbb429fc545","tags":[]},{"title":"Android中一个app启动另一个app｜从浏览器打开app","date":"2022-01-10T01:59:29.000Z","path":"2022/01/10/Android中一个app启动另一个app｜从浏览器打开app/","text":"@[toc] 一、应用A中点击按钮，跳转到应用B 备注：这里是默认启动应用B的启动页面 123456789101112// 通过包名获取要跳转的app，创建intent对象 Intent intent = getPackageManager().getLaunchIntentForPackage(&quot;com.example.db_demo&quot;);// 这里如果intent为空，就说名没有安装要跳转的应用嘛 if (intent != null) &#123; // 这里跟Activity传递参数一样的嘛，不要担心怎么传递参数，还有接收参数也是跟Activity和Activity传参数一样// intent.putExtra(&quot;name&quot;, &quot;Liu xiang&quot;);// intent.putExtra(&quot;birthday&quot;, &quot;1983-7-13&quot;); startActivity(intent); &#125; else &#123; // 没有安装要跳转的app应用，提醒一下 ToastUtils.success(&quot;哟，赶紧下载安装这个APP吧&quot;); &#125; 二、应用A中点击按钮，跳转到应用B中的指定Activity——(scheme方式)1.应用A中，点击按钮123startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;scheme_db://123123123&quot;))); 2.应用B中，AndroidManifest.xml的配置如下123456789&lt;activity android:name=&quot;.ui.WCDBActivity&quot; android:launchMode=&quot;singleInstance&quot;&gt; //多窗口，可添加android:launchMode=&quot;singleInstance&quot; &lt;intent-filter&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;data android:scheme=&quot;scheme_db&quot;/&gt; //通过scheme名称，可启动WCDBActivity &lt;/intent-filter&gt;&lt;/activity&gt; 3.在应用B中，WCDBActivity中可获取应用A中传递过来的数据1234getIntent().getScheme();//获得Scheme名称String data = getIntent().getDataString();//获得Uri全部路径Toast.makeText(this, data+&quot;&quot;,Toast.LENGTH_LONG).show(); 三、应用A点击按钮，跳转到应用B的指定Activity——(指定包名和Activity全路径)1.应用A中，点击123456789/**指定包名和带包名的Activity的名字*/ComponentName componentName = new ComponentName(&quot;com.example.db_demo&quot;, &quot;com.example.db_demo.ui.SQLiteActivity&quot;);Intent intent = new Intent();intent.putExtra(&quot;id&quot;, 1001);intent.setComponent(componentName);startActivity(intent); 2.应用B中，AndroidManifest.xml需要修改123456&lt;activity android:name=&quot;.ui.SQLiteActivity&quot; android:exported=&quot;true&quot; //必须配置，否则不能被其他应用开启 //如果想要在相邻窗口打开，则修改启动模式singleTask或者singleInstance android:launchMode=&quot;singleTask&quot;/&gt; 四、通过浏览器打开Android App 应用 原理同方法二，使用scheme 1、首先做成HTML的页面，页面内容格式例如以下：1&lt;a href=&quot;[scheme]://[host]/[path]?[query]&quot;&gt;启动应用程序&lt;/a&gt; 各个项目含义例如以下所看到的：scheme：判别启动的App。 ※具体后述host：适当记述path：传值时必须的key ※没有也能够query：获取值的Key和Value ※没有也能够 作为测试例如以下： 1&lt;a href=&quot;myapp://jp.app/openwith?name=zhangsan&amp;age=26&quot;&gt;启动应用程序&lt;/a&gt; 2、app应用中，待打开的Activity在AndroidManifest.xml的配置如下：123456789&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;myapp&quot; android:host=&quot;jp.app&quot; android:pathPrefix=&quot;/openwith&quot;/&gt; &lt;/intent-filter&gt; 3、接下来在Activity中须要取值的地方加入下面代码：12345678910Intent i_getvalue = getIntent(); String action = i_getvalue.getAction(); if(Intent.ACTION_VIEW.equals(action))&#123; Uri uri = i_getvalue.getData(); if(uri != null)&#123; String name = uri.getQueryParameter(&quot;name&quot;); String age= uri.getQueryParameter(&quot;age&quot;); &#125; &#125;","tags":[]},{"title":"Android Intent传递数据使用getIntent()接收不到，Intent传递数据与Activity启动模式singleTask的关系","date":"2021-12-13T03:27:44.000Z","path":"2021/12/13/Android-Intent传递数据使用getIntent-接收不到，Intent传递数据与Activity启动模式singleTask的关系/","text":"@[toc] 1、常规Intent传递数据12345678910111、MainActivity传参// Intent构造函数：Intent来源；Intent目的。Intent intent =new Intent(MainActivity.this,otherActivity.class);intent.putExtra(&quot;data&quot;, &quot;当前是页面2，信息来自页面1&quot;);startActivity(intent);//启动Activity2、otherActivity接收参数//通过Activity.getIntent()获取当前页面接收到的Intent。Intent intent = getIntent();//getXxxExtra方法获取Intent传递过来的数据String msg=intent.getStringExtra(&quot;data&quot;); 2、Activity启动模式为singleTask时，Intent传递数据2.1、首先需要在 onNewIntent(Intent intent) 方法中，使用 setIntent(intent) 方法，把最新的intent数据导入；2.2、再使用 getIntent() 方法即可获取最新的intent数据。 1234567891011121314@Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); &#125; @Override protected void onResume() &#123; super.onResume(); //通过Activity.getIntent()获取当前页面接收到的Intent。 Intent intent = getIntent(); //getXxxExtra方法获取Intent传递过来的数据 String msg=intent.getStringExtra(&quot;data&quot;); &#125;","tags":[]},{"title":"Android 获取屏幕截图（可视控件、布局） 获取控件截图（不可视控件、布局）","date":"2021-11-24T08:30:56.000Z","path":"2021/11/24/Android-获取屏幕截图（可视控件、布局）-获取控件截图（不可视控件、布局）/","text":"@[TOC] 1、 获取可视控件、布局的截图1.1 方法：view.getDrawingCache()1.2 demo：获取屏幕截屏12345678910111213141516171819202122232425262728293031 /** * 获取当前屏幕截图，不包含状态栏 */ public static Bitmap screenShotWithoutStatusBar(Activity activity) &#123; //通过window的源码可以看出：检索顶层窗口的装饰视图，可以作为一个窗口添加到窗口管理器 View view = activity.getWindow().getDecorView(); //SYSTEM_UI_FLAG_FULLSCREEN表示全屏的意思，也就是会将状态栏隐藏 //设置系统UI元素的可见性 view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN); //启用或禁用绘图缓存 view.setDrawingCacheEnabled(true); //创建绘图缓存 view.buildDrawingCache(); //拿到绘图缓存 Bitmap bitmap = view.getDrawingCache(); Rect frame = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); //状态栏高度 int statusBarHeight = frame.top; int width = ScreenUtils.getScreenWidth(); int height = ScreenUtils.getScreenHeight(); Bitmap bp = null;// bp = Bitmap.createBitmap(bitmap, 0, 0, width, height - statusBarHeight); bp = Bitmap.createScaledBitmap(bitmap, width, height - statusBarHeight,true); view.destroyDrawingCache(); view.setSystemUiVisibility(View.VISIBLE); return bp; &#125; 2、 获取不可视控件、布局的截图2.1 方法：Bitmap.createBitmap()2.2 demo：把一个xml布局文件转成bitmap1234567891011121314151617181920212223242526272829/** * view转bitmap * * @param view view * @return Bitmap */ private Bitmap createBitmapByView() &#123; View view = LayoutInflater.from(activity).inflate(R.layout.img_qrcode, null, false); //计算设备分辨率 WindowManager manager = activity.getWindowManager(); DisplayMetrics metrics = new DisplayMetrics(); manager.getDefaultDisplay().getMetrics(metrics); int width = metrics.widthPixels; int height = metrics.heightPixels; //测量使得view指定大小 int measureWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measureHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.AT_MOST); view.measure(measureWidth, measureHeight); //调用layout方法布局后，可以得到view的尺寸 view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); final Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.WHITE); view.draw(canvas); return bitmap; &#125; 3、view.getDrawingCache() 为 null 解决方案12345678910111213141516171819202122232425262728public static BitmapWithHeight getSimpleViewToBitmap(final View view, int width) throws OutOfMemoryError &#123; if (view.getWidth() &lt;= 0 || view.getHeight() &lt;= 0) &#123; view.measure(View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); &#125; view.destroyDrawingCache(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); Bitmap map = view.getDrawingCache(); if (view.getHeight() &gt; 0 &amp;&amp; map == null) map = getViewBitmap(view); return new BitmapWithHeight(map, view.getMeasuredWidth(), view.getMeasuredHeight()); &#125; public static Bitmap getViewBitmap(View view) &#123; Bitmap bitmap; if (view.getWidth() &gt; 0 &amp;&amp; view.getHeight() &gt; 0) bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); else if (view.getMeasuredWidth() &gt; 0 &amp;&amp; view.getMeasuredHeight() &gt; 0) bitmap = Bitmap.createBitmap(view.getMeasuredWidth(), view.getMeasuredHeight(), Bitmap.Config.ARGB_8888); else bitmap = Bitmap.createBitmap(com.blankj.utilcode.utils.ScreenUtils.getScreenWidth(), com.blankj.utilcode.utils.ScreenUtils.getScreenHeight() * 2, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); view.draw(canvas); return bitmap; &#125;","tags":[]},{"title":"Android view转Bitmap（将布局文件转成Bitmap）&& Bitmap保存到本地相册","date":"2021-11-24T07:13:04.000Z","path":"2021/11/24/Android-view转Bitmap（将布局文件转成Bitmap）-Bitmap保存到本地相册/","text":"@[toc] 一、view转Bitmap1、使用LayoutInflater导入布局1View view = LayoutInflater.from(activity).inflate(R.layout.img_qrcode, null, false); 2、测量计算view大小1234567891011121314//计算设备分辨率 WindowManager manager = activity.getWindowManager(); DisplayMetrics metrics = new DisplayMetrics(); manager.getDefaultDisplay().getMetrics(metrics); int width = metrics.widthPixels;int height = metrics.heightPixels; //测量使得view指定大小 int measureWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measureHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.AT_MOST); view.measure(measureWidth, measureHeight); //调用layout方法布局后，可以得到view的尺寸 view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); 3、把view转成图片Bitmap1234final Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.WHITE); view.draw(canvas); 二、将Bitmap保存到本地相册123456789101112131415161718192021222324252627/** * 保存bitmap到相册 */ private void saveBitmapToAlbum(Bitmap bitmap) &#123; final File appDir = new File(activity.getExternalCacheDir(), &quot;image&quot;); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; final String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; final File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); try &#123; bitmap.compress(Bitmap.CompressFormat.JPEG, 90, fos); fos.flush(); &#125; finally &#123; fos.close(); &#125; //把文件插入到系统相册 MediaStore.Images.Media.insertImage(activity.getContentResolver(), file.getAbsolutePath(), fileName, null); //通知图库更新 //activity.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + file.getAbsolutePath()))); activity.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(file.getPath())))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 三、代码实现demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SaveBitmap&#123; public void qrCode() &#123; View view = LayoutInflater.from(activity).inflate(R.layout.img_qrcode, null, false); Bitmap saveBitmap = createBitmapByView(view); saveBitmapToAlbum(saveBitmap); &#125; /** * view转bitmap * * @param view view * @return Bitmap */ private Bitmap createBitmapByView(View view) &#123; //计算设备分辨率 WindowManager manager = activity.getWindowManager(); DisplayMetrics metrics = new DisplayMetrics(); manager.getDefaultDisplay().getMetrics(metrics); int width = metrics.widthPixels; int height = metrics.heightPixels; //测量使得view指定大小 int measureWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measureHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.AT_MOST); view.measure(measureWidth, measureHeight); //调用layout方法布局后，可以得到view的尺寸 view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); final Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.WHITE); view.draw(canvas); return bitmap; &#125; /** * 保存bitmap到相册 */ private void saveBitmapToAlbum(Bitmap bitmap) &#123; final File appDir = new File(activity.getExternalCacheDir(), &quot;image&quot;); if (!appDir.exists()) &#123; appDir.mkdir(); &#125; final String fileName = System.currentTimeMillis() + &quot;.jpg&quot;; final File file = new File(appDir, fileName); try &#123; FileOutputStream fos = new FileOutputStream(file); try &#123; bitmap.compress(Bitmap.CompressFormat.JPEG, 90, fos); fos.flush(); &#125; finally &#123; fos.close(); &#125; //把文件插入到系统相册 MediaStore.Images.Media.insertImage(activity.getContentResolver(), file.getAbsolutePath(), fileName, null); //通知图库更新 //activity.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + file.getAbsolutePath()))); activity.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(new File(file.getPath())))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","tags":[]},{"title":"Android项目迁移到 AndroidX","date":"2021-09-30T08:12:04.000Z","path":"2021/09/30/Android项目迁移到-AndroidX/","text":"使用 Android Studio 迁移现有项目使用 Android Studio 3.2 及更高版本，您只需从菜单栏中依次选择 Refactor &gt; Migrate to AndroidX，即可将现有项目迁移到 AndroidX。 重构命令使用两个标记。默认情况下，这两个标记在 gradle.properties 文件中都设为 true： 12//Android 插件会使用对应的 AndroidX 库而非支持库。android.useAndroidX=true 12//Android 插件会通过重写现有第三方库的二进制文件，自动将这些库迁移为使用 AndroidX。android.enableJetifier=true 注释 1、如果要迁移未使用任何第三方库但带有需要转换的依赖项的现有项目，可以将 android.useAndroidX 标记设置为true，并将 android.enableJetifier 标记设置为 false。 2、执行迁移之前，请先将应用更新到最新版本。 我们建议您将项目更新为使用支持库的最终版本：版本 28.0.0。 这是因为，1.0.0 版本的 AndroidX 工件是与支持库 28.0.0 工件等效的二进制文件。 参考官方文档：迁移到 AndroidX","tags":[]},{"title":"Android软键盘——InputMethodManager使用：显示、隐藏软键盘","date":"2021-09-28T07:26:15.000Z","path":"2021/09/28/Android软键盘——InputMethodManager使用：显示、隐藏软键盘/","text":"@[toc] 1、InputMethodManager介绍 InputMethodManager是一个用于控制显示或隐藏输入法面板的类。 获取InPutMethodManager的方法很简单： 1InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); 2、InputMethodManager用法2.1、显示软键盘12345678//et获取焦点et.requestFocus();//获取immfinal InputMethodManager imm = (InputMethodManager) et.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);if (null != imm) &#123; //显示软键盘 imm.showSoftInput(et,InputMethodManager.SHOW_FORCED);&#125; 2.2、隐藏软键盘12345678910//et获取焦点et.requestFocus();//获取immfinal InputMethodManager imm = (InputMethodManager) et.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);if (null != imm) &#123; //隐藏软键盘 imm.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(),InputMethodManager.HIDE_NOT_ALWAYS); //or imm.hideSoftInputFromWindow(et.getWindowToken(),InputMethodManager.HIDE_NOT_ALWAYS);&#125; 2.3、实现输入法在窗口上切换显示，如果输入法在窗口已经显示，则隐藏；如果已经隐藏，则显示软键盘。12345678//et获取焦点et.requestFocus();//获取immfinal InputMethodManager imm = (InputMethodManager) et.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);if (null != imm) &#123; //输入法在窗口已经显示，则隐藏；如果已经隐藏，则显示软键盘 imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);&#125; 2.4、判断当前软键盘状态是打开 or 关闭123InputMethodManager imm =(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);boolean isOpen=imm.isActive();//isOpen为true，则当前输入法是打开的；反之则是关闭的。","tags":[]},{"title":"Git 常用命令整理","date":"2021-09-22T02:16:05.000Z","path":"2021/09/22/Git-常用命令整理/","text":"@[toc] Git 常用命令整理1.仓库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 3.增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 4.代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 5.分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 6.标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 7.查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 8.远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 9.撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 10.其他12# 生成一个可供发布的压缩包$ git archive","tags":[]},{"title":"Android Studio 查看项目中jar包依赖关系 依赖树 父子级","date":"2021-09-02T09:02:00.000Z","path":"2021/09/02/Android-Studio-查看项目中jar包依赖关系-依赖树-父子级/","text":"命令行方法 windos 版 studio里命令行(Terminal)输入gradlew -q app:dependencies mac 版 输入 ./gradlew -q app:dependencies或者 bash gradlew -q app:dependencies 把输入打印到a.txt文件中：bash gradlew -q app:dependencies &gt;&gt; a.txt","tags":[]},{"title":"启动AndroidStudio报错Missing essential plugin:org.jetbrains.android Please reinstall Android Studio...","date":"2021-08-26T02:27:26.000Z","path":"2021/08/26/启动AndroidStudio报错Missing-essential-plugin-org-jetbrains-android-Please-reinstall-Android-Studio/","text":"问题今天升级Android Studio 后，打算重新启动，却发现启动报错如下： 123Missing essential plugin:org.jetbrains.androidPlease reinstall Android Studio from scratch. 在这里插入图片描述 分析 导致这个问题最主要的问题可能是版本不一致或插件等问题 解决1、Windows版本Android Studio下解决方案 如下图所示：1、打开windows目录下该路径，其中AppData默认是隐藏文件，需要先打开查看隐藏文件；2、打开 disabled_plugins.txt文件，删除文件中org.jetbrains开头的文件字样即可。 在这里插入图片描述 2、Mac版本Android Studio下解决方案 1、打开Mac下如下目录：/Users/apple/Library/Application Support/Google/AndroidStudio2020.3/disabled_plugins.txt。其中：（1）apple -&gt; 代表用户，AndroidStudio2020.3 -&gt; 代表使用的as版本（2）Library -&gt; 指资源库，默认为隐藏文件不可见，需要打开查看隐藏文件。2、打开该文件，如下图所示，删除引起问题的配置即可 disabled_plugins.txt： 12com.vladsch.idea.multimarkdownorg.jetbrains.kotlin 我的项目本次报错为Kotlin插件引起的，所以只需要删除“org.jetbrains.kotlin”这行，然后重新启动Android Studio即可。对应的如果你明确知道是因为哪个插件报错，删除对应插件配置即可。","tags":[]},{"title":"构建项目报错：Task ‘xxx’ not found in root project ‘xxx’. Some candidate…","date":"2021-08-24T02:03:13.000Z","path":"2021/08/24/构建项目报错：Task-‘xxx’-not-found-in-root-project-‘xxx’-Some-candidate…/","text":"问题 Task ‘xxx’ not found in root project ‘xxx’. Some candidate… 解决方案 方案1close项目，重新import，不是open，是import ；删除.idea、删除.gradle 然后关闭项目；从新从目录打开项目； 方案2在根目录的build.gradle文件的首行加入:task assemble&#123;&#125;","tags":[]},{"title":"Mac之——命令行快速入门","date":"2021-08-18T08:56:46.000Z","path":"2021/08/18/Mac之——命令行快速入门/","text":"@[toc] 1.常用命令整理 pwd:打印工作目录，也可叫做输出工作目录，英文全称：print working directory mkdir:创建目录，英文全称：make directory touch:创建空文件 rmdir:删除路径 rm:删除文件 cd:更改目录 ls:列出目录下的内容 pushd:推入路径 popd:弹出路径 cp:复制 mv:移动文件/重命名 less:查看文件内容 cat:显示文件内容 find:寻找文件 echo:打印一些参数 exit:退出 sudo:成为超级用户或root，英文全称：super user do 2.命令行实现及注意事项 pwd 打印工作目录 当你键入太多命令，一下找不到自己现在所处于的路径时，pwd可以帮你很好的找到 在这里插入图片描述 mkdir 新建目录 新建目录，可以是以前没有的目录，也可以在已有的目录下追加新的目录，但是值得注意的是，只用mkdir不能同时创建父子目录，如下图中tmp11还没有存在的情况下，不能直接创建,tmp111,如需同时创建多层目录，可以使用mkdir -p 在这里插入图片描述 touch 创建空文件 创建空文件,注意这种方式不能用来创建文件夹 在这里插入图片描述 rmdir 删除路径 删除路径,值得注意的是，在删除路径的时候需要指定到它的上一级目录，要不会报错，如下图，指定到了tmp1,可以rmdir下面的tmp11,但是当目录退到tmp时，就不能删除tmp11了，如果遇到你确定是空目录但是它拒绝删除改目录时，可以键入rm -rf&lt; dir &gt;即可，其中dir 用实际的目录名替代就可以 在这里插入图片描述 rm 删除文件 删除文件 在这里插入图片描述 cd 更改目录 更改目录，其实也就是指定到对应的目录，这种指定不能跳跃式的，必须一步步的往下指定，如下图不能直接指定到tmp1,要先指定到tmp,在指定到tmp1,也可以直接cd tmp/tmp1 ,可以使用cd直接回到最开始目录，也可以使用cd ..回到上一层目录 在这里插入图片描述在这里插入图片描述 ls 列出目录下的内容 列出目录下的内容 在这里插入图片描述 pushd和popd pushd保存当前路径并转到一个新的路径popd回到先前保存的路径 在这里插入图片描述 cp 复制 复制,如果是文件，可以直接复制，如果是复制整个文件夹，则用cp -r 在这里插入图片描述 mv 移动文件/重命名 移动文件,换种说法就是重命名 在这里插入图片描述 less 查看文件内容 查看文件内容，可以查询某个路径下的文件内容，查看后按q退出 在这里插入图片描述 cat 显示文件内容 显示文件内容 在这里插入图片描述","tags":[]},{"title":"Android 11 「外部存储」权限适配方案——权限申请框架推荐","date":"2021-08-08T09:26:22.000Z","path":"2021/08/08/Android-11-「外部存储」权限适配方案——权限申请框架推荐/","text":"@[toc] 1.权限种类1.1权限种类区分-普通权限、危险权限、特殊权限 首先 Android 的权限大致分为三种：普通权限：只需要在清单文件中注册即可危险权限：需要在代码中动态申请，以弹系统 Dialog 的形式进行请求特殊权限：需要在代码中动态申请，以跳系统 Activity 的形式进行请求 1.2存储权限-变化 存储权限：在 Android 6.0 之后就变成了危险权限；在 Android 11 上面变成了特殊权限；申请方式的发生了不同 2.外部存储和内部存储对比2.1外部存储在手机哪个位置？ Android4.4之前：内部存储在手机ROM上的一块存储区域；外部存储在SD卡上； Android4.4之后：内部存储在手机ROM上的一块存储区域；外部存储也在手机ROM上的一块存储区域； 在这里插入图片描述 2.2外部存储和内部存储的访问权限区别在这里插入图片描述 3.外部存储适配方案3.1 Android 10.0 以下外部存储权限适配 升级 targetSdkVersion 12345android defaultConfig &#123; targetSdkVersion 23 &#125;&#125; 添加清单权限 12&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 如果 targetSdkVersion &gt;= 29 上，还需要在清单文件中加上 12&lt;application android:requestLegacyExternalStorage=&quot;true&quot;&gt; 代码动态申请 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class PermissionActivity extends AppCompatActivity &#123; private static final int REQUEST_CODE = 1024; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestPermission(); &#125; private void requestPermission() &#123; //判断版本大于等于android 6.0 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; // 先判断有没有权限 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) &#123; writeFile(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_CODE); &#125; &#125; else &#123; writeFile(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == REQUEST_CODE) &#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) &#123; writeFile(); &#125; else &#123; ToastUtils.show(&quot;存储权限获取失败&quot;); &#125; &#125; &#125; /** * 模拟文件写入 */ private void writeFile() &#123; ToastUtils.show(&quot;写入文件成功&quot;); &#125;&#125; 3.2 Android 11 及以上申请外部存储权限 升级 targetSdkVersion 12345android defaultConfig &#123; targetSdkVersion 30 &#125;&#125; 添加清单权限 123&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; /&gt; 代码动态申请 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class PermissionActivity extends AppCompatActivity &#123; private static final int REQUEST_CODE = 1024; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestPermission(); &#125; private void requestPermission() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123; // 先判断有没有权限 if (Environment.isExternalStorageManager()) &#123; writeFile(); &#125; else &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION); intent.setData(Uri.parse(&quot;package:&quot; + context.getPackageName())); startActivityForResult(intent, REQUEST_CODE); &#125; &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; // 先判断有没有权限 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) &#123; writeFile(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_CODE); &#125; &#125; else &#123; writeFile(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == REQUEST_CODE) &#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) &#123; writeFile(); &#125; else &#123; ToastUtils.show(&quot;存储权限获取失败&quot;); &#125; &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123; if (Environment.isExternalStorageManager()) &#123; writeFile(); &#125; else &#123; ToastUtils.show(&quot;存储权限获取失败&quot;); &#125; &#125; &#125; /** * 模拟文件写入 */ private void writeFile() &#123; ToastUtils.show(&quot;写入文件成功&quot;); &#125;&#125; 4.权限申请框架推荐4.1 XXPermissions4.1 AndPermission","tags":[]},{"title":"SQLite数据库——分页搜索查询","date":"2021-08-04T08:50:23.000Z","path":"2021/08/04/SQLite数据库——分页搜索查询/","text":"@[toc] 1.常用SQl查询语句1.1查询所有数据1String sql = &quot;Select * From history&quot;; 1.2倒序查询desc1String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; order by &quot; + HistoryHelper.ID + &quot; desc &quot;; 1.3分页查询Limit、Offset这里查询12条，从0到11 1String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; Limit 11 Offset 0&quot;; 1.4倒序分页查询1String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; order by &quot; + HistoryHelper.ID + &quot; desc &quot; + &quot; Limit &#x27;&quot; + pageCount + &quot;&#x27; Offset &#x27;&quot; + ((page - 1) * pageCount) + &quot;&#x27;&quot;; 注意：order by和desc要写在Limit前面，同时非字符串的值需要加上单引号’ ‘，如” Limit ‘“ + pageCount + “’”;pageCount这个值我们就需要用’ ‘。 1.5倒序分页查询-搜索匹配关键字where…like搜索用where条件， LIKE 运算符是用来匹配 通配符 指定模式的文本值下面的sql语句我们匹配了我们数据表的time字段是否包含s文本值 1String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; where &quot; + HistoryHelper.Time + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; order by &quot; + HistoryHelper.ID + &quot; desc &quot; + &quot; Limit &#x27;&quot; + pageCount + &quot;&#x27; Offset &#x27;&quot; + ((page - 1) * pageCount) + &quot;&#x27;&quot;; 2.源码2.1分页查询demo 查询上一页、下一页的方法： pageCount为你需要多少条数据 page表示当前第几页，默认为1 当用户点击下一页，我们可以使用currentPage+=1，然后调用此方法 同理上一页我们可以使用currentPage-=1 当然还要判断是不是第一页和最后一页 123456789101112131415161718192021222324252627282930313233343536373839404142//如果我要去11-20的Account表的数据 //Select * From Account Limit 9 Offset 10; //以上语句表示从Account表获取数据，跳过10行，取9行 /** * context 上下文 * pageCount 查询多少条数据 * page 第几页，默认为1 */ public static List&lt;CarResultMap&gt; getHistory(Activity context, int pageCount, int page) &#123; HistoryHelper mHelper = new HistoryHelper(context); SQLiteDatabase db = mHelper.getReadableDatabase(); List&lt;CarResultMap&gt; carResultMap = new ArrayList&lt;CarResultMap&gt;(); try &#123; String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; order by &quot; + HistoryHelper.ID + &quot; desc &quot; + &quot; Limit &#x27;&quot; + pageCount + &quot;&#x27; Offset &#x27;&quot; + ((page - 1) * pageCount) + &quot;&#x27;&quot;; Cursor cursor = db.rawQuery(sql, new String[]&#123;&#125;); if (cursor.moveToFirst()) &#123; do &#123; CarResultMap carResult = new CarResultMap(cursor.getString(cursor.getColumnIndex(HistoryHelper.Time + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.CODE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.CARTYPE + &quot;&quot;)), cursor.getInt(cursor.getColumnIndex(HistoryHelper.TYPE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.USER + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.PRESSURE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.LEAKAGE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.UNIT + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.RESULT + &quot;&quot;))); carResultMap.add(carResult); &#125; while (cursor.moveToNext()); &#125; cursor.close(); db.close(); &#125; catch (Exception e) &#123; db.close(); e.printStackTrace(); return carResultMap; &#125; return carResultMap; &#125; 2.2分页查询-搜索关键字demo 搜索框 输入想要查询的关键字根据用户输入的文本s返回我们需要的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * context 上下文 * pageCount 查询多少条数据 * page 第几页，默认为1 * s 想要匹配的关键字 */public static List&lt;CarResultMap&gt; getSearchHistory(Activity context, int pageCount, int page, String s) &#123; HistoryHelper mHelper = new HistoryHelper(context); SQLiteDatabase db = mHelper.getReadableDatabase(); List&lt;CarResultMap&gt; carResultMap = new ArrayList&lt;CarResultMap&gt;(); try &#123; String sql = &quot;Select * From &quot; + HistoryHelper.TABLE_NAME + &quot; where &quot; + HistoryHelper.USER + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.Time + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.USER + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.TYPE + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.CARTYPE + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.CODE + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.PRESSURE + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.LEAKAGE + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; or &quot; + HistoryHelper.RESULT + &quot; like &#x27;%&quot; + s + &quot;%&#x27;&quot; + &quot; order by &quot; + HistoryHelper.ID + &quot; desc &quot; + &quot; Limit &#x27;&quot; + pageCount + &quot;&#x27; Offset &#x27;&quot; + ((page - 1) * pageCount) + &quot;&#x27;&quot;; Cursor cursor = db.rawQuery(sql,new String[]&#123;&#125;); if (cursor.moveToFirst()) &#123; do &#123; CarResultMap carResult = new CarResultMap(cursor.getString(cursor.getColumnIndex(HistoryHelper.Time + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.CODE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.CARTYPE + &quot;&quot;)), cursor.getInt(cursor.getColumnIndex(HistoryHelper.TYPE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.USER + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.PRESSURE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.LEAKAGE + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.UNIT + &quot;&quot;)), cursor.getString(cursor.getColumnIndex(HistoryHelper.RESULT + &quot;&quot;))); carResultMap.add(carResult); &#125; while (cursor.moveToNext()); &#125; cursor.close(); db.close(); &#125; catch (Exception e) &#123; db.close(); e.printStackTrace(); &#125; return carResultMap; &#125;","tags":[]},{"title":"Android File文件「重命名」和「删除」操作","date":"2021-07-09T08:28:03.000Z","path":"2021/07/09/Android-File文件「重命名」和「删除」操作/","text":"@[toc] 前言 最近做项目遇到一个需求：1.要求当app版本升级覆盖安装后，清除app部分功能的本地缓存。正好需要用到「重命名文件」和「删除文件」操作。 1. 重命名文件renameTo 方法 1234567891011121314151617181920/** * 重命名文件： * oldPath 和 newPath必须是新旧文件的绝对路径 */ public static boolean renameFile(String oldPath, String newPath) &#123; if (TextUtils.isEmpty(oldPath)) &#123; return false; &#125; if (TextUtils.isEmpty(newPath)) &#123; return false; &#125; File oldFile = new File(oldPath); File newFile = new File(newPath); if (newFile.exists()) &#123; return false; &#125; //重命名 return oldFile.renameTo(newFile); &#125; 2. 删除文件delete 方法 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 对文件夹下的文件进行清扫 * * @param topDir 文件夹目录 * @param skips 需要保存不被清扫的文件 * @param rmTopDir 是否清扫父文件 true：清扫 false：不清扫 * @return 清扫结果 */ public static boolean cleanupDirFiles(@NonNull final String topDir, @NonNull final Set&lt;String&gt; skips, boolean rmTopDir) &#123; final File file = new File(topDir); if (!file.exists()) &#123; return false; &#125; else &#123; if (file.isDirectory()) &#123; //获取子文件列表 final File[] childFiles = file.listFiles(); if ((null == childFiles) || (childFiles.length &lt;= 0)) &#123; //判断是否包含不被清扫的文件，如果包含，则不delete if (!skips.contains(file.getAbsolutePath())) &#123; return file.delete(); &#125; else &#123; return true; &#125; &#125; //遍历 for (File f : childFiles) &#123; final String absPath = f.getAbsolutePath(); //判断是否包含不被清扫的文件，如果包含，则不delete if (!skips.contains(absPath)) &#123; if (!cleanupDirFiles(absPath, skips, true)) &#123; return false; &#125; &#125; &#125; &#125; //判断是否清扫父文件 if (rmTopDir &amp;&amp; (!skips.contains(file.getAbsolutePath()))) &#123; return file.delete(); &#125; &#125; return true; &#125;","tags":[]},{"title":"使用shell命令校验Android apk的签名信息、校验apk是否使用v1v2v3v4签名","date":"2021-07-07T03:17:14.000Z","path":"2021/07/07/使用shell命令校验Android-apk的签名信息、校验apk是否使用v1v2v3v4签名/","text":"@[toc] 前言 最近项目打包新增v2签名，于是想在打包完成后校验是否已经成功使用了v2签名故打算写一个shell脚本来执行校验 1. 查看apk文件的签名类型的shell命令shell命令： 1apksigner verify --verbose xx.apk 输出结果： 12345678VerifiesVerified using v1 scheme (JAR signing): trueVerified using v2 scheme (APK Signature Scheme v2): trueVerified using v3 scheme (APK Signature Scheme v3): falseVerified using v4 scheme (APK Signature Scheme v4): falseVerified for SourceStamp: falseNumber of signers: 1 从结果中可以看出：该apk使用了v1和v2签名，没有使用v3和v4签名。 2. 自动校验签名并输出的完整脚本 由于项目使用Jenkins自动打包，既然有了shell命令，不妨让命令直接帮我做完，免得每次打完包还需要手动检测。在Jenkins打包命令完成后，再配置校验签名的shell命令即可。 2.1 命令脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//本地apksigner的目录export ROOT_DOR=/Users/apple/Library/Android/sdk/build-tools/30.0.2 //待验证签名的apk目录export ROOT_DIR=/Users/apple/Documents/MyWork/androidCode/workCode/ZjnxEbankUat_Scan/app/uat/debug//遍历寻找该目录下的apk文件，可能有多个apkfind $&#123;ROOT_DIR&#125; -name &quot;*.apk&quot; | while read linedo //apk文件 FILE=$&#123;line&#125; //查看apk的签名信息 $&#123;ROOT_DOR&#125;/apksigner verify --verbose &quot;$&#123;FILE&#125;&quot; | while read line2 do //校验是否使用v1签名 str1=&quot;Verified using v1 scheme&quot; if [[ $&#123;line2&#125; =~ $str1 ]] then echo &quot;****************&quot; V1_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V1_SIGN&#125;&quot; ] then echo &quot;v1签名成功&quot; else echo &quot;v1签名失败&quot; fi echo &quot;****************&quot; fi //校验是否使用v2签名 str2=&quot;Verified using v2 scheme&quot; if [[ $&#123;line2&#125; =~ $str2 ]] then echo &quot;****************&quot; V2_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V2_SIGN&#125;&quot; ] then echo &quot;v2签名成功&quot; else echo &quot;v2签名失败&quot; fi echo &quot;****************&quot; fi //校验是否使用v3签名 str3=&quot;Verified using v3 scheme&quot; if [[ $&#123;line2&#125; =~ $str3 ]] then echo &quot;****************&quot; V3_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V3_SIGN&#125;&quot; ] then echo &quot;v3签名成功&quot; else echo &quot;v3签名失败&quot; fi echo &quot;****************&quot; fi //校验是否使用v4签名 str4=&quot;Verified using v4 scheme&quot; if [[ $&#123;line2&#125; =~ $str4 ]] then echo &quot;****************&quot; V4_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V4_SIGN&#125;&quot; ] then echo &quot;v4签名成功&quot; else echo &quot;v4签名失败&quot; fi echo &quot;****************&quot; fi donedone 这样配置完成后，Jenkins日志就会自动输出签名信息。 2.2 命令脚本更新版2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117export ROOT_DOR=/Users/apple/Library/Android/sdk/build-tools/30.0.2 #export ROOT_DIR=/Users/apple/Documents/MyWork/androidCode/workCode/ZjnxEbankUat_Scan/app/uat/debugexport ROOT_DIR=/Users/apple/Desktop/qqqfind $&#123;ROOT_DIR&#125; -name &quot;*.apk&quot; | while read linedo # 默认没有进行v1v2v3v4签名 v1=&quot;false&quot; v2=&quot;false&quot; v3=&quot;false&quot; v4=&quot;false&quot; FILE=$&#123;line&#125; # 内部域分隔符：此处做换行处理 IFS=&quot;&quot; for line2 in `$&#123;ROOT_DOR&#125;/apksigner verify --verbose &quot;$&#123;FILE&#125;&quot;` do str1=&quot;Verified using v1 scheme&quot; if [[ $&#123;line2&#125; =~ $str1 ]] then v1=&quot;true&quot; echo &quot;****************&quot; V1_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V1_SIGN&#125;&quot; ] then echo &quot;校验v1签名成功&quot; else echo &quot;校验v1签名失败&quot; exit -1 fi echo &quot;****************&quot; fi str2=&quot;Verified using v2 scheme&quot; if [[ $&#123;line2&#125; =~ $str2 ]] then v2=&quot;true&quot; echo &quot;****************&quot; V2_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V2_SIGN&#125;&quot; ] then echo &quot;校验v2签名成功&quot; else echo &quot;校验v2签名失败&quot; exit -1 fi echo &quot;****************&quot; fi str3=&quot;Verified using v3 scheme&quot; if [[ $&#123;line2&#125; =~ $str3 ]] then v3=&quot;true&quot; echo &quot;****************&quot; V3_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V3_SIGN&#125;&quot; ] then echo &quot;校验v3签名成功&quot; else echo &quot;校验v3签名失败&quot; fi echo &quot;****************&quot; fi str4=&quot;Verified using v4 scheme&quot; if [[ $&#123;line2&#125; =~ $str4 ]] then v4=&quot;true&quot; echo &quot;****************&quot; V4_SIGN=$&#123;line2: 0-4&#125; if [ &quot;true&quot; == &quot;$&#123;V4_SIGN&#125;&quot; ] then echo &quot;校验v4签名成功&quot; else echo &quot;校验v4签名失败&quot; fi echo &quot;****************&quot; fi done if [[ &quot;false&quot; == $v1 ]] then echo &quot;****************&quot; echo &quot;没有检测到有效的v1签名&quot; echo &quot;****************&quot; exit -1 fi if [[ &quot;false&quot; == $v2 ]] then echo &quot;****************&quot; echo &quot;没有检测到有效的v2签名&quot; echo &quot;****************&quot; exit -1 fi if [[ &quot;false&quot; == $v3 ]] then echo &quot;****************&quot; echo &quot;没有检测到有效的v3签名&quot; echo &quot;****************&quot; fi if [[ &quot;false&quot; == $v4 ]] then echo &quot;****************&quot; echo &quot;没有检测到有效的v4签名&quot; echo &quot;****************&quot; fidone 3. 本文中使用到的shell命令小结3.1 shell 查看apk的签名信息1apksigner verify --verbose xx.apk 3.2 shell 字符串包含12345678strA=&quot;helloworld&quot;strB=&quot;low&quot;if [[ $strA =~ $strB ]]then echo &quot;包含&quot;else echo &quot;不包含&quot;fi 3.3 shell if…fi语句1234567891011121314#!/bin/sha=10b=20if [ $a == $b ]then echo &quot;a is equal to b&quot;fiif [ $a != $b ]then echo &quot;a is not equal to b&quot;fi 3.4 Shell 字符串截取Shell字符串截取完整命令 3.4.1 从字符串左边开始计数1$&#123;string: start :length&#125; 例如： 12url=&quot;c.biancheng.net&quot;echo $&#123;url: 2: 9&#125; 结果为biancheng 3.4.2 从右边开始计数1$&#123;string: 0-start :length&#125; 从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维） 例如： 12url=&quot;c.biancheng.net&quot;echo $&#123;url: 0-13: 9&#125; 结果为biancheng。从右边数，b是第 13 个字符 3.5 内部域分隔符IFS123456# 内部域分隔符：此处做换行处理 IFS=&quot;&quot; for line2 in `$&#123;ROOT_DOR&#125;/apksigner verify --verbose &quot;$&#123;FILE&#125;&quot;`# 相当于：执行apksigner verify --verbose 获取apk的签名信息，并且以# “换行”作为条件进行循环输出给line2；我们就可以逐行对line2进行判断处理即可。","tags":[]},{"title":"x++ 与 ++x 的区别整理","date":"2021-06-25T02:33:12.000Z","path":"2021/06/25/x-与-x-的区别整理/","text":"@[toc] x++与++x的区别 ==简单的表达式== 中x++和++x表示着相同的意思，比如常用于for循环语句中； 当 ==递增== 或者 ==递减== 的运算结果被直接用在其他表达式中，x++与++x就代表着 不同 的意思了 ++x：变量 ==x的值先增加== ，再 ==计算整个表达式的值== ；x++：变量x的值在 ==表达式计算后== 再增加； 实例演示12345x = 1;y = ++x;//x的值先增加结果：x=2，y=2 12345x = 1;y = x++;//先执行表达式，再增加结果：x=2，y=1","tags":[]},{"title":"Android中的MVP模式学习","date":"2021-06-18T06:48:34.000Z","path":"2021/06/18/Android中的MVP模式学习/","text":"@[toc] 1. MVP模式简介1.1 MVP所对应的意义MVP所对应的意义：M-Model-模型、V-View-视图、P-Presenter-表示器。 M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控View与Model之间的间接交互。MVP关系模型 2. MVP模式的应用2.1 model层描述和具体代码提供==想要展示在view层的数据==和==具体业务逻辑处理的实现== 1234567891011121314151617181920package com.fw.mvp.mvp.model;import com.fw.mvp.callback.MCallback;/** * description :Model层接口 * author : apple * date : 2021/6/16 15:19 */public interface IMVPModel &#123; /** * 成功：返回数据 * 失败：回调失败 * * @param name * @param mCallback */ void getAcountData(String name, MCallback mCallback);&#125; 123456789101112131415161718192021222324252627282930313233343536package com.fw.mvp.mvp.model;import com.fw.mvp.bean.Acount;import com.fw.mvp.callback.MCallback;import java.util.Random;/** * description :Model层实现 * author : apple * date : 2021/6/16 11:06 */public class MVPModel implements IMVPModel &#123; /** * 成功：返回数据 * 失败：回调失败 * * @param name * @param mCallback */ @Override public void getAcountData(String name, MCallback mCallback) &#123; Random random = new Random(); boolean isSuccess = random.nextBoolean(); if (isSuccess) &#123; Acount acount = new Acount(); acount.setName(name); acount.setLevel(111); mCallback.onSuccess(acount); &#125; else &#123; mCallback.onFail(); &#125; &#125;&#125; 2.2 view层描述和具体代码负责==显示数据==、==提供友好界面==跟用户交互 123456789101112131415161718192021222324252627282930package com.fw.mvp.mvp.view;import com.fw.mvp.bean.Acount;/** * description :View层接口，其具体实现类为MVPActivity * author : apple * date : 2021/6/16 11:03 */public interface IMVPView &#123; /** * 获取输入内容 * * @return */ String getInputText(); /** * 展示成功结果 * * @param acount */ void showSuccessPage(Acount acount); /** * 展示失败结果 */ void showFail();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.fw.mvp.mvp;import android.annotation.SuppressLint;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;import com.fw.mvp.R;import com.fw.mvp.bean.Acount;import com.fw.mvp.mvp.presenter.IMVPPresenter;import com.fw.mvp.mvp.presenter.MVPPresenter;import com.fw.mvp.mvp.view.IMVPView;/** * description :View层实现类 * author : apple * date : 2021/6/15 21:04 */public class MVPActivity extends AppCompatActivity implements IMVPView, View.OnClickListener &#123; private EditText editText; private Button button; private TextView textView; private IMVPPresenter mvpPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_mvp); initView(); initData(); &#125; private void initView() &#123; editText = findViewById(R.id.et); button = findViewById(R.id.btn); textView = findViewById(R.id.tv); &#125; private void initData() &#123; button.setOnClickListener(this); mvpPresenter = new MVPPresenter(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.btn) &#123; mvpPresenter.onClick(getInputText()); &#125; &#125; @Override public String getInputText() &#123; return editText.getText().toString().trim(); &#125; @SuppressLint(&quot;SetTextI18n&quot;) @Override public void showSuccessPage(Acount acount) &#123; textView.setText(acount.getName() + &quot; | &quot; + acount.getLevel()); &#125; @Override public void showFail() &#123; textView.setText(&quot;数据获取失败&quot;); &#125;&#125; 2.3 presenter层描述和具体代码Presenter扮演着view和model的中间层的角色。 获取model层的数据之后构建view层；也可以收到view层UI上的反馈命令后分发处理逻辑，交给model层做业务操作。 12345678910111213141516package com.fw.mvp.mvp.presenter;/** * description :Presenter层接口 * author : apple * date : 2021/6/16 15:24 */public interface IMVPPresenter &#123; /** * 点击事件 * * @param name */ void onClick(String name);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.fw.mvp.mvp.presenter;import com.fw.mvp.bean.Acount;import com.fw.mvp.callback.MCallback;import com.fw.mvp.mvp.model.IMVPModel;import com.fw.mvp.mvp.model.MVPModel;import com.fw.mvp.mvp.view.IMVPView;/** * description :Presenter层实现 * author : apple * date : 2021/6/16 11:11 */public class MVPPresenter implements IMVPPresenter &#123; private IMVPView mView; private IMVPModel mModel; public MVPPresenter(IMVPView mView) &#123; this.mView = mView; mModel = new MVPModel(); &#125; @Override public void onClick(String name) &#123; //调用model去进行逻辑处理 mModel.getAcountData(name, new MCallback() &#123; @Override public void onSuccess(Acount acount) &#123; //通知view层进行UI构建刷新 mView.showSuccessPage(acount); &#125; @Override public void onFail() &#123; //通知view层进行UI构建刷新 mView.showFail(); &#125; &#125;); &#125;&#125; 2.4 使用到的自定义的接口123456789101112131415package com.fw.mvp.callback;import com.fw.mvp.bean.Acount;/** * description :回调接口 * author : apple * date : 2021/6/16 11:30 */public interface MCallback &#123; void onSuccess(Acount acount); void onFail();&#125; 3. demo代码流程3.1 代码流程 demo的代码流程：（请参考下面的类图）1、 MVPActivity做了一些UI初始化的东西，需要实例化对应IMVPPresenter的引用，和实现 IMVPView的接口，监听界面动作；2、 button按钮按下后出发点击事件，在onClick里接收到即通过MVPPresenter的引用把它交给MVPPresenter处理；3、 然后MVPPresenter把逻辑交给Model层去处理，也就是这里面的MVPModel；4、 MVPModel处理完逻辑之后，结果通过回调通知MVPPresenter；5、MVPPresenter再把结果返回给View层的MVPActivity，最后MVPActivity显示结果。 3.2 代码流程图例在这里插入图片描述","tags":[]},{"title":"TortoiseGit 使用教程","date":"2021-06-09T08:19:12.000Z","path":"2021/06/09/TortoiseGit-使用教程/","text":"@[toc] 前言 作为一个软件开发人员，不可能不知道Git。Git作为一个复杂的版本控制系统，命令之多，即使经常使用，一些命令也记不住，一般只记住几个常用的命令，不是所有使用Git命令行都是高效的。本教程不讲Git命令，而是先让你用上git，再去学习git。本教程应该称作TortoiseGit入门指南。因为下面要借助一个图形化的软件，TortoiseGit来操作git。用GUI（图形界面）再谈CLI（命令行），我相信这会更容易让人接受。 该文章转自：https://www.cnblogs.com/anayigeren/p/10177027.html TortoiseGit 简介 TortoiseGit 简称 tgit， 中文名海龟Git。TortoiseGit是一个开放的GIT版本控制系统的源客户端。 TortoiseGit 支持Winxp/vista/win7/Win10，提供有中文版支持。 TortoiseGit 可以恢复您的文件的旧版本，并研究如何以及合适改变了历史数据，谁改变了它。下面教程针对使用TortoiseGit的用户。 下载安装Git及Tortoisegit 环境安装，需要依次安装以下：在这里插入图片描述 第1步： 下载Git，下载地址：https://git-for-windows.github.io/在这里插入图片描述 Git 安装过程不详述，可参考：https://www.cnblogs.com/wj-1314/p/7993819.html第2步： 下载安装Tortoisegit及中文语言包（Tortoisegit及语言包下载 ，Tortoisegit 安装教程）在这里插入图片描述 Tortoisegit 配置 第1步： 首先，请选定一个存放Git项目的目录，这样方便管理. 如: E:\\Git，然后在资源管理器中打开：在这里插入图片描述 第2步： 在空白处点击鼠标右键，选择 –&gt; TortoiseGit –&gt; Settings，然后就可以看到配置界面：在这里插入图片描述 第3步： 选中General，在右边的 Language中选择简体中文(当然,你也可以继续使用英文)。取消勾选升级检查的复选框，可能还需要指定 git.exe 文件的路径，如 “D:\\Program Files\\Git\\bin”。完成后，点击应用，确定关闭对话框。在这里插入图片描述 第4步： 配置用户，用户作为你操作git的个人标识，进入设置，点选左边的Git标签，可以发现,右边可以配置用户的名字与Email信息. 如下图所示：在这里插入图片描述 因为当前还没有本地项目,所以 “编辑本地 .git/config(L)” 按钮处于灰色不可用状态， 如果在某个本地Git项目下打开配置对话框，那么这个按钮就可用,然后就可以编辑 此项目的一些属性。 点击 “编辑全局 .git/config(O)”按钮,会使用记事本打开全局配置文件，在全局配置文 件中，在后面加上下面的内容（记住密码）: [credential]helper = store 完成后保存，关闭记事本，确定即可。 则当你使用 HTTPS URL 方式推送项目到GitHub等在线仓库时，海龟git会记住你输 入的用户名和密码（这里不是用户的姓名和Email哦），可以避免每次提交都要输入 用户名和密码。（还有种方式，通过使用 SSH URL 来提交代码便可以一劳永逸了 ~~~） 如果你编辑的是 本地 .git/config(L)，其实这个翻译为本地有点问题，应该叫局部， 也就是在某个项目下面设置，只对此项目有效，配置是一样的。 Tortoisegit 使用示例 克隆一个项目（分别从github仓库、自己搭建的gitblit 仓库上获取） 教程开始之前，补充一个知识点： 本地仓库和远程git仓库的连接方式有两种：HTTPS 和 SSH，很多时候都是直接使用 HTTPS URL方式克隆项目到本地，当然也有有些人使用SSH URL克隆到本地。这两种方式的主要区别在于： HTTPS：使用起来不用配置，对初学者来说会比较方便，只要复制HTTPS URL然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次 fetch 和 push代码都需要输入账号和密码，这也是HTTPS方式的麻烦之处。SSH：使用SSH URL方式需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。多数介绍Git的博客里面采用的都是https的方式作为案例，今天主要是记录如何配置并在海龟git中使用SSH方式来提交和克隆代码。 第1步： 此处介绍通过SSH URL方式传输，使用之前需要先将本地的 SSH 公钥配置到 Git 服务器上。 先查看SSH Key。在C盘用户主目录用户目录下，看看有没有.ssh目录，如果有 再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接 到第2步。 在这里插入图片描述 如果没有上述文件，则需要创建一个SSH Key，在任意文件夹下点击右键，选择 Git GUI Here。在弹出的程序中选择主菜单的【Help】→【Show SSH Key】： 在这里插入图片描述 如果没有Key，则点击“Generate Key”生成一个SSH Key： 在这里插入图片描述 把生成的全部内容拷出来。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub 两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去， id_rsa.pub是公钥，可以放心地告诉任何人。（其他创建SSH Key方式：通过Shell 命令方式创建） 第2步： 把 SSH Key 填到Git 服务器的配置中。 GitHub服务器：登陆GitHub，【头像】→【Settings】→【SSH and GPG Keys】 →【New SSH Key】，填入上一步的复制的SSHKey，然后【Add SSH Key】： 在这里插入图片描述 Gitblit 服务器（自己搭建 Git 服务器，Gitblit的安装教程请看这里），登录 Gitblit账 户，在【头像】→【用户中心】→【SSH Keys】，填入上一步的复制的SSHKey， 然后【添加】 在这里插入图片描述 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送 的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥， 就可以确认只有你自己才能推送。 第3步： 要克隆 GitHub 或 Gitblit 上的项目，先要获取对应远程存储库的路径（注意：此处使用 SSH URL 方式）： GitHub仓库：从 GitHub项目页面上得到对应存储库的 giturl 路径：在这里插入图片描述 Gitblit 仓库：在存储库页面这个位置得到存储库的 giturl 路径：在这里插入图片描述 第4步： 在本地文件夹的空白位置处，右击鼠标，在菜单中选择【Git克隆】： 在这里插入图片描述 把git 路径填写到URL，并选择本地文件目录，点击【确定】，弹出下载进度窗口。 （服务器端至少要有一个文件，否则 pull的时候会报错 fatal: Couldn&#39;t find remote ref HEAD） 在这里插入图片描述 克隆成功，则在文件夹上就可以看到角标标识： 在这里插入图片描述 将代码提交到服务器Git的使用类似TFS、SVN等源代码或者文件管理器，惯例的流程：在这里插入图片描述 第1步： 改动，修改本地项目中的某些文件，如修改 README.md 内容，还可以增加一些文件， 如Hello.txt。 第2步： 提交本地，在本地项目的空白处点击鼠标右键，选择 【Git提交(C) -&gt; “master”…】 在这里插入图片描述 在弹出提交（Commit）对话框中完成提交说明信息，和选择需要提交的文件，可根 据需要新建分支，然后点击 【提交】 按钮，将修改提交到本地仓库： 在这里插入图片描述 弹出提交进度窗口，提交成功后还需要“推送”将本地仓库的修改推送到远程仓库。 在这里插入图片描述 第3步： 同步拉取，在实际工作中，如果多人协作或者多个客户端进行修改，那么我们还要拉取别人推送到在线仓库的内容，所以在推送之前需要先执行同步拉取(Pull …)操作。在本地仓库文件夹上【右击鼠标】→【Git同步】： 在这里插入图片描述 打开Git同步窗口（包括常规操作及日志，同右击菜单快捷操作一样），点击【拉取 (P)】，将远程分支拉取到本地： 在这里插入图片描述 如果服务器上的文件没有被修改过，就会直接提示已经更新到最新，那你就可以直 接进行下一步“推送(H)”操作了： 在这里插入图片描述 反之，如果服务器上的文件被修改过了（本地文件修改前不是最新版本），就会提 示冲突。先要解决冲突，然后再提交结果： 在这里插入图片描述 需要注意的是，和使用TFS、SVN的习惯一样，你在修改本地内容之前，最好先 拉 取（pull）一下，减少冲突的可能。 第四步： 推送远程，将提交到本地仓库的修改推送到远程仓库，可以直接在提交成功后的提示窗口上点击【推送(H)…】，或者在Git同步窗口点击【推送(H)…】，鼠标右击的菜单上也有相应的快捷操作：选择 【TortoiseGit(T)】→【推送(H)…】 弹出推送(push)对话框： 在这里插入图片描述 一般保持默认,点击 “确定” 按钮 然后弹出推送进度界面，可能要求你输入用户名，点击【确定】，然后要求输入密 码，密码输入正确后，显示推送成功界面： 在这里插入图片描述 如果你按照上一小节Tortoisegit 配置的设置操作，则输入密码以后会记住密码。密 码会明文保存在C:\\Users\\用户名\\.git-credentials 这个文件中，请小心保存。","tags":[]},{"title":"bash: ./gradlew: Permission denied 报错","date":"2021-06-08T09:14:35.000Z","path":"2021/06/08/bash-gradlew-Permission-denied-报错/","text":"问题： 在mac版的Android studio的Terminal命令行中执行./gradlew命令报错bash: ./gradlew: Permission denied 解决方案 1$ chmod +x gradlew 其实就是因为没有权限了，用ls -l查看是否有对应的平台的该执行文件是否有权限执行，如果没有权限的话可以执行 chmod +x gradlew 或者 chmod 777 gradlew","tags":[]},{"title":"华为HMS Scankit 扫码SDK集成-实现扫一扫功能","date":"2021-06-07T00:10:24.000Z","path":"2021/06/07/华为HMS-Scankit-扫码SDK集成-实现扫一扫功能/","text":"华为HMS Scankit 扫码SDK集成-实现扫一扫功能 @[toc] 一、集成HMS Core SDK1.添加当前应用的AppGallery Connect配置文件 在华为开发者联盟注册成为开发者-创建应用-下载agconnect-services.json文件 在这里插入图片描述2.将“agconnect-services.json”文件拷贝到应用级根目录下在这里插入图片描述3.配置HMS Core SDK的Maven仓地址 打开Android Studio项目级“build.gradle”文件。 添加HUAWEI agcp插件以及Maven代码库。 在“buildscript &gt; repositories”中配置HMS Core SDK的Maven仓地址。在“allprojects &gt; repositories”中配置HMS Core SDK的Maven仓地址。如果App中添加了“agconnect-services.json”文件则需要在“buildscript &gt;dependencies”中增加agcp配置。 在这里插入图片描述4.添加编译依赖 打开应用级的“build.gradle”文件。 引用SDK，Scan Kit提供两种SDK，您可以根据需求选择合适的SDK。 1234dependencies&#123; implementation &#x27;com.huawei.hms:scan:1.3.2.300&#x27; implementation &#x27;com.huawei.hms:scanplus:1.3.2.300&#x27; &#125; 说明如果在非华为手机使用多码能力接口，请使用Scan SDK-Plus，否则会影响识别。com.huawei.hms:scanplus:{version} 添加AGC插件配置。请根据实际情况选择： 方式一：在文件头部声明下一行添加如下配置 1apply plugin: &#x27;com.huawei.agconnect&#x27; 方式二：在plugins中添加如下配置。 12345plugins &#123; id &#x27;com.android.application&#x27; //添加如下配置 id &#x27;com.huawei.agconnect&#x27;&#125; 二、配置混淆脚本 在应用级根目录下打开混淆配置文件“proguard-rules.pro”，加入排除HMS Core SDK的混淆配置脚本。 123456789-ignorewarnings-keepattributes *Annotation*-keepattributes Exceptions-keepattributes InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable-keep class com.huawei.hianalytics.**&#123;*;&#125;-keep class com.huawei.updatesdk.**&#123;*;&#125;-keep class com.huawei.hms.**&#123;*;&#125; 如果您使用了AndResGuard，需要在应用级的“build.gradle”文件中加入AndResGuard允许清单。 12345678910111213&quot;R.string.hms*&quot;,&quot;R.string.connect_server_fail_prompt_toast&quot;,&quot;R.string.getting_message_fail_prompt_toast&quot;,&quot;R.string.no_available_network_prompt_toast&quot;,&quot;R.string.third_app_*&quot;,&quot;R.string.upsdk_*&quot;,&quot;R.layout.hms*&quot;,&quot;R.layout.upsdk_*&quot;,&quot;R.drawable.upsdk*&quot;,&quot;R.color.upsdk*&quot;,&quot;R.dimen.upsdk*&quot;,&quot;R.style.upsdk*&quot;, &quot;R.string.agc*&quot; 三、指定权限 AndroidManifest.xml中指定相应的权限 代码中动态申请一下权限 校验是否开启相应的权限，决定是否继续扫码 1234&lt;!--相机权限--&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;!--读文件权限--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 12//CAMERA_REQ_CODE为用户自定义，用于接收权限校验结果ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE&#125;, CAMERA_REQ_CODE); 123456789//实现“onRequestPermissionsResult”函数接收校验权限结果@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //判断“requestCode”是否为申请权限时设置请求码CAMERA_REQ_CODE，然后校验权限开启状态 if (requestCode == CAMERA_REQ_CODE &amp;&amp; grantResults.length == 2 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED) &#123; //调用扫码接口，构建扫码能力，需您实现 ... &#125;&#125; 四、调用扫码功能调用HMS Core SDK的“startScan”扫码接口，启动扫码界面 五、官方文档demo官方文档Demo","tags":[]},{"title":"TortoiseSVN 打Tags","date":"2021-06-03T08:36:51.000Z","path":"2021/06/03/TortoiseSVN-打Tags/","text":"TortoiseSVN打Tags TortoiseSvn打Tag的坑： 必须把svn上的代码拉到本地，然后在本地代码上“右键”选择brandh/tag。 步骤： 把svn上需要打Tag的代码拉到本地； 进入代码目录，在想要打tag的文件夹上右键依次选择“TortoiseSVN” —-&gt; “Branch/tag…”，如下所示：在这里插入图片描述 修改Tag目录：把Tag保存到自己需要的目录下。 注意：「该目录」必须在svn中存在，否则会报错。 比如：保存目录为 ../code/trunk/tag/1.0/myProject但是，svn中只有../code/trunk/tag，tag目录下并没有「1.0」这个目录，就会报错。","tags":[]},{"title":"Android Studio 引入aar文件","date":"2021-05-25T08:06:02.000Z","path":"2021/05/25/Android-Studio-引入aar文件/","text":"方法一：在app目录下导入aar 在app-libs目录下导入aar在这里插入图片描述 在app-build.gradle中配置 12345repositories &#123; flatDir &#123; dir &#x27;libs&#x27; &#125; &#125; 1implementation(name:&#x27;Test_debug&#x27;, ext:&#x27;aar&#x27;) 构建项目，在External Libraries目录下会生成该依赖在这里插入图片描述 方法二、在项目根目录下导入aar（该方法更加实用，如果某一个library想依赖该aar，只需要在其build.gradle中引入即可） 在项目根目录新建一个文件夹（此处测试用repositories命名），并把aar放在该目录下在这里插入图片描述 在项目根build.gradle文件中配置 1234567allprojects &#123; repositories &#123; flatDir &#123; dirs &#x27;../repositories&#x27; &#125; &#125;&#125; 在library-build.gradle中导入配置aar即可（此处测试在app中导入aar） 1implementation(name:&#x27;Test_debug_2&#x27;, ext:&#x27;aar&#x27;) 在这里插入图片描述","tags":[]},{"title":"Android String字符串截取方法总结","date":"2021-05-25T02:29:05.000Z","path":"2021/05/25/Android-String字符串截取方法总结/","text":"Android String字符串截取方法总结 指定字符，截取字符串，返回字符串数组： 1234String str = &quot;abcd.efg.123456.hijk.345&quot;;String[] strs=str.split(&quot;.&quot;); 指定索引号，截取字符串： 将字符串从索引号为3开始截取，一直到字符串末尾（索引值从0开始）: 1234String str = &quot;abcdefghijklmnopqrstuvwxyz&quot;;str.substring(3); 从索引号1开始到索引好7结束（并且不包含索引7截取在内，也就是说实际截取的是1、2、3、4、5、6号字符）: 1234String str = &quot;abcdefghijklmnopqrstuvwxyz&quot;;str.substring(1, 7); indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 12345678910String str = &quot;abcde.fghi.jkl.mno.pqrstu.vwxyz&quot;//截取 0-第一次遇到“.”的字符串str.substring(0, str.indexOf(&quot;.&quot;));//截取 0-最后一次遇到“.”的字符串str.substring(0, str.lastIndexOf(&quot;.&quot;));//从第7位开始，截取第一次遇到“.”的字符串str.substring(7, str.indexOf(&quot;.&quot;, 7));//截取“mno”之后的字符str.substring(str.indexOf(&quot;mno&quot;));","tags":[]},{"title":"Mac OS系统怎么修改mac地址","date":"2021-05-06T09:15:21.000Z","path":"2021/05/06/Mac-OS系统怎么修改mac地址/","text":"有时候我们需要指定固定的mac地址上网 具体方法： 1networksetup -listallhardwareports //查看当前所有端口Mac地址 123sudo ifconfig en0 ether e4:ce:8f:32:51:82 //修改ifconfig en1 | grep ether //查看是否修改成功,这里修改的是虚拟Mac,看硬件是看不出来的 demo案例：修改en8的mac地址 1、查看当前所有端口mac地址 123456789101112131415161718192021222324252627282930313233343536apple@fenglolodeMacBook-Pro ~ % networksetup -listallhardwareportsHardware Port: USB EthernetDevice: en8Ethernet Address: 00:0e:c6:68:7d:c1Hardware Port: Wi-FiDevice: en0Ethernet Address: 78:4f:43:83:5a:5aHardware Port: Bluetooth PANDevice: en5Ethernet Address: 78:4f:43:84:d0:d8Hardware Port: Thunderbolt 1Device: en1Ethernet Address: 82:c9:93:e2:54:01Hardware Port: Thunderbolt 2Device: en2Ethernet Address: 82:c9:93:e2:54:00Hardware Port: Thunderbolt 3Device: en3Ethernet Address: 82:c9:93:e2:54:05Hardware Port: Thunderbolt 4Device: en4Ethernet Address: 82:c9:93:e2:54:04Hardware Port: Thunderbolt BridgeDevice: bridge0Ethernet Address: 82:c9:93:e2:54:01VLAN Configurations=================== 2、修改en8的mac地址为98:ee:cb:a3:8d:bf 12apple@fenglolodeMacBook-Pro ~ % sudo ifconfig en8 ether 98:ee:cb:a3:8d:bfPassword: 3、查看修改后的en8的mac地址，确认是否修改成功。 12apple@fenglolodeMacBook-Pro ~ % ifconfig en8 | grep ether ether 98:ee:cb:a3:8d:bf","tags":[]},{"title":"Android OkHttp请求报错：java.net.UnknownServiceException：..not permitted by network security policy","date":"2021-04-29T09:07:33.000Z","path":"2021/04/29/Android-OkHttp请求报错：java-net-UnknownServiceException：-not-permitted-by-network-security-policy/","text":"问题在Android 9.0手机使用OkHttp请求一个http地址，会报如下错误。 java.net.UnknownServiceException: CLEARTEXT communication to **** not permitted by network security policy 原因是Android 9.0以后，Google官方解释： 为保证用户数据和设备的安全，Google针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P系统的安卓设备无论是接收或者发送流量，未来都不能明码传输。 三种解决办法 APP 改用 https 请求 argetSdkVersion 降到27以下更改 网络安全配置 其中前两种方法不用过多解释，主要讲一下第三种方法实现。 在res文件夹下创建一个xml文件夹，然后在xml目录下创建一个network_security_config.xml文件，文件内容如下： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 在AndroidManifest.xml文件下的application标签增加属性 1android:networkSecurityConfig=&quot;@xml/network_security_config&quot; 配置完毕，就可以访问http地址了。","tags":[]},{"title":"LitePal的使用——Android开源数据库","date":"2021-04-28T06:26:40.000Z","path":"2021/04/28/LitePal的使用——Android开源数据库/","text":"本文知识点 LitePal的集成 LitePal实现数据库的增删改查 LitePal常用的API 1. LitePal的集成 引入相应的类库 创建litepal.xml 更换继承的Application 1.1 引入相应的类库 12//litepal数据库 implementation &#x27;org.litepal.guolindev:core:3.2.3&#x27; 1.2 创建litepal.xml litepal.xml是在assets文件夹下，项目main路径下New-&gt;Folder-&gt;AssetsFolder就可以创建相应的assets文件夹，然后在assets文件夹下创建一个相应的litepal.xml文件夹。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt; &lt;!--数据库名--&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;!--数据库版本号--&gt; &lt;version value=&quot;1&quot; /&gt; &lt;!--映射模型--&gt; &lt;list&gt; &lt;mapping class=&quot;com.fw.androidone.sqlitelitepal.entity.Book&quot; /&gt; &lt;/list&gt;&lt;/litepal&gt; dbname标签是相应的数据库名称 version标签是相应的数据库的版本 （当里面引用的内容发生改变的时候,要升级相应的版本） list标签哪些对象需要数据库管理 （mapping里面的路径一定要是全路径名称） （list标签中的实体类都应该继承LitePalSupport这个类） 1.3 更换继承的Application （1）已经有继承的Application（2）直接继承LitePalApplication （1）已经有继承的Application 直接在Application的onCreate方法中对数据库进行初始化 123456@Override public void onCreate() &#123; super.onCreate(); //数据库初始化 LitePal.initialize(this); &#125; （2）直接继承LitePalApplication 直接继承相应的LitePalApplication这里就不用在onCreate()中调用LitePal.initialize(this);在application标签中添加Application的时候要这样写android:name=&quot;org.litepal.LitePalApplication&quot; 2.LitePal中实现增删改查2.1 新增数据 使用save()方法 1234Book book = new Book();book.setAuthor(&quot;王天一&quot;);book.setName(&quot;王天一的第一本书&quot;);book.save(); 2.2 删除数据 delete()或者deleteAll()进行删除 12345Book book = new Book();book.setAuthor(&quot;王天二&quot;);book.setName(&quot;王天二的第一本书&quot;);book.save();book.delete(); 12//删除book表中price=44.6786的这条数据LitePal.deleteAll(Book.class, &quot;name = ?&quot;, &quot;王天二&quot;); 2.3 更新数据 1、更改完相应的数据直接save保存2、updateAll方法实现 123456789//方式一：对已经存储的数据进行更新Book book = new Book();book.setAuthor(&quot;王天二&quot;);book.setName(&quot;王天二的第一本书&quot;);book.save();// 重新修改价格，然后点用save方法，// 此时，litapal数据库中会发现该数据之前已经存储在数据库中，所以进行更新价格操作。而不会重新插入一条数据。book.setName(&quot;王天三&quot;);book.save(); 1234//方式二：updateAll方法实现Book book1 = new Book();book1.setPrice(44.6786);book1.updateAll(&quot;name = ? and author = ?&quot;, &quot;王天二的第一本书&quot;, &quot;王天二&quot;); 2.4 查询数据 主要用到find()和findAll()等相应的方法、 1234567891011121314151617181920212223242526272829303132333435//查询所有数据List&lt;Book&gt; bookList = LitePal.findAll(Book.class);//查询第一条数据Book firstBook = LitePal.findFirst(Book.class);//查询最后一条数据Book lastBook = LitePal.findLast(Book.class);//按照条件查询//(1）select()方法用于指定查询哪几列的数据，对应sql中的select关键字List&lt;Book&gt; books = LitePal.select(&quot;name&quot;, &quot;author&quot;).find(Book.class);//(2) where()用于指定查询的约束条件，对应了sql中的where关键字List&lt;Book&gt; books1 = LitePal.where(&quot;page &gt; ?&quot;, &quot;100&quot;).find(Book.class);//(3) order()方法用于指定结果的排序方式，对应了sql当中的order by 关键字List&lt;Book&gt; books2 = LitePal.order(&quot;price desc&quot;).find(Book.class);//(4) limint()方法用于指定查询结果的数量List&lt;Book&gt; books3 = LitePal.limit(3).find(Book.class);//查询表中前3条数据//(5)offset() 方法用于指定查询结果的偏移量List&lt;Book&gt; books4 = LitePal.limit(3).offset(1).find(Book.class);//查询表中第2条、第3条、第4条数据//(6) 组合使用查询List&lt;Book&gt; books5 = LitePal.select(&quot;name&quot;, &quot;author&quot;) .where(&quot;page &gt; ?&quot;, &quot;100&quot;) .order(&quot;price&quot;) .limit(3) .offset(2) .find(Book.class);//查询Book表中第3～5条满足page&gt;100页这个条件的name、author这两列数据，并且查询结果按照price升序排序//LitePal使用原声SQL查询Cursor cursor = LitePal.findBySQL(&quot;select * form Book where page &gt; ? and price &lt; ?&quot;, &quot;100&quot;, &quot;60&quot;); 3.LitePal常用的API 查询第一条数据LitePal.findFirst(Book.class); 查询最后一条数据LitePal.findLast(Book.class); select()方法用于指定查询哪几列的数据，对应sql中的select关键字 LitePal.select(“name”,”author”).find(Book.class); where()用于指定查询的约束条件，对应了sql中的where关键字LitePal.where(“page &gt; ?”, “100”).find(Book.class); order()方法用于指定结果的排序方式，对应了sql当中的order by 关键字 LitePal.order(“price desc”).find(Book.class); limint()方法用于指定查询结果的数量LitePal.limit(3).find(Book.class);//查询表中前3条数据 offset() 方法用于指定查询结果的偏移量LitePal.limit(3).offset(1).find(Book.class);//查询表中第2条、第3条、第4条数据","tags":[]},{"title":"Android Studio 使用Lambda表达式「详细配置」","date":"2021-04-27T07:53:53.000Z","path":"2021/04/27/Android-Studio-使用Lambda表达式「详细配置」/","text":"前言： Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。 配置： 1、安装java 8，并在android studio中配置使用；在这里插入图片描述2、app build.gradle中配置 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; 3、解决用JDK1.8 Lambda表达式中文乱码的问题 gradle.properties文件中配置 1org.gradle.jvmargs=-Dfile.encoding=UTF-8 使用：demo： 12345678910111213//普通写法adapter.setItemClickListener(new SelectAdapter.ItemClickListener() &#123; @Override public void onClick(int position) &#123; Select select = list.get(position); startActivity(new Intent(SelectActivity.this, select.getActivity().getClass())); &#125; &#125;); //使用Lambda表达式 adapter.setItemClickListener(position -&gt; &#123; Select select = list.get(position); startActivity(new Intent(SelectActivity.this, select.getActivity().getClass())); &#125;); 12345678910111213141516//普通写法listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Intent intent = new Intent(MainActivity.this, SelectActivity.class); intent.putExtra(&quot;type&quot;, position + 1); startActivity(intent); &#125; &#125;); //使用Lambda表达式 listView.setOnItemClickListener((parent, view, position, id) -&gt; &#123; Intent intent = new Intent(MainActivity.this, SelectActivity.class); intent.putExtra(&quot;type&quot;, position + 1); startActivity(intent); &#125;);","tags":[]},{"title":"Android中EditText优先弹出数字输入法","date":"2021-04-26T05:48:55.000Z","path":"2021/04/26/Android中EditText优先弹出数字输入法/","text":"Android中EditText优先弹出数字输入法当一个EditText使用数字的频率很高，比如用来输入手机号等等，但是有时候可能也需要使用到输入英文和汉字的需求。这个时候，我们默认当EditText弹出时，优化弹出数字键盘比较好。 解决方案 123//默认直接显示数字键盘editText.setInputType(InputType.TYPE_CLASS_TEXT);editText.setRawInputType(InputType.TYPE_CLASS_NUMBER); setInputType和setRawInputType的不同之处是：前者是输入内容限制，后者是改变输入法格式 如果想限制输入的格式，比如只能输入“0123456789abc”这些字符，该怎么办呢？这个时候就需要使用到setKeyListener属性。 1234567//这里自定义过滤规则，比如只能输入0-9和小写abcString digits = &quot;0123456789abc&quot;;editText.setInputType(InputType.TYPE_CLASS_TEXT);editText.setKeyListener(DigitsKeyListener.getInstance(digits));editText.setRawInputType(InputType.TYPE_CLASS_NUMBER);","tags":[]},{"title":"Android 11 调用手机系统摄像头新策略 IMAGE_CAPTURE","date":"2021-03-30T09:02:56.000Z","path":"2021/03/30/Android-11-调用手机系统摄像头新策略-IMAGE-CAPTURE/","text":"前言 android 11 调用系统摄像头有了新的策略，需兼容才可行 1、在Android11之前调用系统摄像头代码： 12Intent captureIntent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); if (captureIntent.resolveActivity(this.getPackageManager()) != null) &#123;&#125; 2、在Android11之后，captureIntent.resolveActivity(this.getPackageManager())方法将返回null，导致调用相机失败。 123456Starting in Android 11, only pre-installed system camera apps can respond to the following intent actions:android.media.action.VIDEO_CAPTUREandroid.media.action.IMAGE_CAPTUREandroid.media.action.IMAGE_CAPTURE_SECUREIf more than one pre-installed system camera app is available, the system presents a dialog for the user to select an app. If you want your app to use a specific third-party camera app to capture images or videos on its behalf, you can make these intents explicit by setting a package name or component for the intent. 优化方案 在manifest中配置queries 1234567&lt;manifest package=&quot;your.package.name&quot;&gt; &lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot; /&gt; &lt;/intent&gt; &lt;/queries&gt;&lt;/manifest&gt;","tags":[]},{"title":"Android 防止按钮(View)多次重复点击之「防重复点击」——2.0（控制view的click事件）","date":"2021-03-10T03:34:34.000Z","path":"2021/03/10/Android-防止按钮-View-多次重复点击之「防重复点击」——2-0（控制view的click事件）/","text":"前言 为了防止“按钮”的点击事件在短时间内多次点击从而触发了多次处理操作；比如：快速点击“登录按钮”发送了多次登录接口，导致程序在短时间内进行多次数据提交or数据处理，这样的体验就不太好了。 方法 123456789101112131415161718192021public class ClickHelper &#123; private static final android.os.Handler mHandler = new android.os.Handler(android.os.Looper.getMainLooper()); public static void isFastDoubleClick(@NonNull final View view, @NonNull final View.OnClickListener listener) &#123; view.setOnClickListener(null); final WeakReference&lt;View&gt; weakReference = new WeakReference&lt;&gt;(view); final WeakReference&lt;View.OnClickListener&gt; listeneWeakReference = new WeakReference&lt;&gt;(listener); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; final View view1 = weakReference.get(); final View.OnClickListener listener1 = listeneWeakReference.get(); if (null != view1 &amp;&amp; null != listener1) &#123; view1.setOnClickListener(listener1); &#125; &#125; &#125;, 1000);//延迟一秒 &#125;&#125; 方法原理 1）当用户点击view之后，传入view和其listener；2）设置view.setOnClickListener(null)，使其点击事件失效；3）把传入的view和listener使用弱引用（weakReference）保存；4）使用handler延迟一秒之后执行操作；5）从weakReference中获取view和listener，若view和listener都存在，则设置view1.setOnClickListener(listener1)；重新给view设置点击事件； 为什么要使用弱引用？为了不把传入的view和listener绑定死，故使用弱引用；","tags":[]},{"title":"Android-沉浸式状态栏的实现","date":"2021-01-21T02:40:41.000Z","path":"2021/01/21/Android-沉浸式状态栏的实现/","text":"1、取得状态栏的高度值 通过反射获取状态栏高度（部分手机可能获取不到） 1234567891011121314151617181920212223/** * 获取状态栏的高度 * @return */ protected int getStatusBarHeight()&#123; try &#123; //通过反射获取到类 Class&lt;?&gt; aClass = Class.forName(&quot;com.android.internal.R$dimen&quot;); //创建对象 Object o = aClass.newInstance(); //拿取属性 Field status_bar_height = aClass.getField(&quot;status_bar_height&quot;); //获取值 Object o1 = status_bar_height.get(o); int height = Integer.parseInt(o1.toString()); // return getResources().getDimensionPixelSize(height); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return 0 ; &#125; 2、设置沉浸式状态栏（状态栏设置透明后，将顶层布局高度动态增加状态栏的高度） 1234567891011121314151617181920212223242526/** * 系统版本4.4或以上才可以设置沉浸式状态栏 * * 设置沉浸式状态栏 */ private void setStatus()&#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; //设置状态栏透明 getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //设置导航栏透明（如需要设置导航栏） getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); title_bar = (ViewGroup) findViewById(R.id.title_bar); final int statusBarHeight = getStatusBarHeight(); title_bar.post(new Runnable() &#123; @Override public void run() &#123; int height = title_bar.getHeight(); ViewGroup.LayoutParams layoutParams = title_bar.getLayoutParams(); layoutParams.height = statusBarHeight + height ; title_bar.setLayoutParams(layoutParams); &#125; &#125;); &#125; &#125;","tags":[]},{"title":"HashMap和LinkedHashMap的比较使用","date":"2021-01-14T07:55:32.000Z","path":"2021/01/14/HashMap和LinkedHashMap的比较使用/","text":"前言Hashmap 1&gt; Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，**取得数据的顺序是完全随机的**。2&gt; HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 LinkedHashMap 1&gt; LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，**先得到的记录肯定是先插入的**.也可以在构造时用带参数，按照应用次数排序。2&gt; 在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 测试案例 1234567891011121314151617181920212223public void hashTest() &#123; System.out.println(&quot;*************************LinkedHashMap*************&quot;); Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;String, String&gt;(); linkedHashMap.put(&quot;小红&quot;, &quot;fkdks&quot;); linkedHashMap.put(&quot;张三&quot;, &quot;pshad&quot;); linkedHashMap.put(&quot;李浩&quot;, &quot;jfhen&quot;); linkedHashMap.put(&quot;王武&quot;, &quot;kkkdn&quot;); for (Map.Entry&lt;String,String&gt; entry : linkedHashMap.entrySet()) &#123; System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue()); &#125; System.out.println(&quot;*************************HashMap*************&quot;); Map&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;(); hashMap.put(&quot;小红&quot;, &quot;fkdks&quot;); hashMap.put(&quot;张三&quot;, &quot;pshad&quot;); hashMap.put(&quot;李浩&quot;, &quot;jfhen&quot;); hashMap.put(&quot;王武&quot;, &quot;kkkdn&quot;); for (Map.Entry&lt;String,String&gt; entry : hashMap.entrySet()) &#123; System.out.println(entry.getKey() + &quot;-&quot; + entry.getValue()); &#125; &#125; 输出结果如下 12345678910I/System.out: *************************LinkedHashMap*************I/System.out: 小红-fkdksI/System.out: 张三-pshadI/System.out: 李浩-jfhenI/System.out: 王武-kkkdnI/System.out: *************************HashMap*************I/System.out: 张三-pshadI/System.out: 王武-kkkdnI/System.out: 李浩-jfhenI/System.out: 小红-fkdks 可以得出： HashMap获取数据是乱序的；LinkedHashMap获取数据的有序的。","tags":[]},{"title":"HashSet和LinkedHashSet的比较使用","date":"2021-01-14T06:35:07.000Z","path":"2021/01/14/HashSet和LinkedHashSet的比较使用/","text":"前言HashSet HashSet有以下特点—— 不能保证元素的排列顺序，顺序有可能发生变化—— 不是同步的—— 集合元素可以是null,但只能放入一个null当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相 等注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSet LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，**LinkedHashSet将会以元素的添加顺序访问集合的元素**。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 测试案例 123456789101112131415161718192021222324public void hashTest()&#123; // HashSet不保证集合的迭代顺序；也许在某些时间迭代的顺序与插入顺序一致，但是不保证该顺序恒久不变。 Set&lt;String&gt; mSetString = new HashSet&lt;String&gt;(); // LinkedHashSet按照元素插入的顺序进行迭代，LinkedHashSet不是线程安全的。 Set&lt;String&gt; mLinkedSetString = Collections.synchronizedSet(new LinkedHashSet&lt;String&gt;()); for (int i = 0; i &lt; 30; i++) &#123; mSetString.add(String.valueOf(i)); mLinkedSetString.add(String.valueOf(i)); &#125; System.out.println(&quot;***********HashSet for String***************&quot;); Iterator&lt;String&gt; setStringIt = mSetString.iterator(); while(setStringIt.hasNext()) &#123; System.out.print(setStringIt.next() + &quot; &quot;); &#125; System.out.println(); System.out.println(&quot;***********LinkedHashSet for String***************&quot;); Iterator&lt;String&gt; linkedSetStringIt = mLinkedSetString.iterator(); while(linkedSetStringIt.hasNext()) &#123; System.out.print(linkedSetStringIt.next() + &quot; &quot;); &#125; System.out.println(); &#125; 输出日志如下 12342021-01-14 14:21:39.154 32383-32383/com.zjrc.cba2 I/System.out: ***********HashSet for String***************2021-01-14 14:21:39.156 32383-32383/com.zjrc.cba2 I/System.out: 22 23 24 25 26 27 28 29 10 11 12 13 14 15 16 17 18 19 0 1 2 3 4 5 6 7 8 9 20 21 2021-01-14 14:21:39.156 32383-32383/com.zjrc.cba2 I/System.out: ***********LinkedHashSet for String***************2021-01-14 14:21:39.157 32383-32383/com.zjrc.cba2 I/System.out: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 从输出结果看： HastSet迭代的顺序与插入的顺序不一致；LinkedHashSet迭代的顺序与插入的顺序一致；","tags":[]},{"title":"Mac AndroidStudio 中安装plantUML插件","date":"2021-01-13T07:33:06.000Z","path":"2021/01/13/Mac-AndroidStudio-中安装plantUML插件/","text":"Mac版 AS 安装plantUML插件 1、打开setting面板；2、找到Plugins；3、在搜索框中输入plantUML，进行搜索；在这里插入图片描述4、点击安装插件，并重启AS；5、File双击 -&gt; New，就可以看到一个PlantUML File了。6、新建一个PlantUML File格式的文件，就可以用代码来愉快的画图了。在这里插入图片描述 PlantUML语法使用详见 https://blog.csdn.net/fenglolo/article/details/112562026","tags":[]},{"title":"PlantUML-程序员绘图工具「流程图、用例图、时序图等等」","date":"2021-01-13T07:12:35.000Z","path":"2021/01/13/PlantUML-程序员绘图工具「流程图、用例图、时序图等等」/","text":"前言 1、PlantUML 是一个开源项目，支持快速绘制时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。2、PlantUML拥有独立的一套语法，实现代码控制画图，便于后期的修改等操作 参考文献1、https://plantuml.com/zh/activity-diagram-beta2、https://www.yuque.com/yuque/help/editor-puml PlantUML语法 简单活动图 活动标签(activity label)以冒号开始，以分号结束。 123456@startuml:Hello world;:这是一个测试步骤;@enduml 在这里插入图片描述 开始/结束 你可以使用关键字 start 和 stop 表示图示的开始和结束。 12345678910@startumlstart:Hello world;:这是一个测试步骤;stop@enduml 在这里插入图片描述也可以使用 end 关键字。 12345678910@startumlstart:Hello world;:这是一个测试步骤;end@enduml 在这里插入图片描述 条件语句 在图示中可以使用关键字if，then和else设置分支测试。标注文字则放在括号中。 12345678910111213@startumlstart if(是否已经吃饭) then(是) :不再吃饭; else(否) :去吃饭; endif stop@enduml 在这里插入图片描述 也可以使用关键字elseif设置多个分支测试。 12345678910111213141516171819@startumlstart if(条件a) then(yes) :do 条件a; elseif(条件b) then(yes) :do 条件b; end elseif(条件c) then(yes) :do 条件c; elseif(条件d) then(yes) :do 条件d; else(nothing) :do nothing; endifstop@enduml 在这里插入图片描述如果想要中段一个判断，可以使用kill或者detach关键字。 123456789@startumlif (条件满足?) then #pink:error; killendif#palegreen:action;@enduml 123456789@startumlif (条件满足?) then #pink:error; detachendif#palegreen:action;@enduml 在这里插入图片描述 重复循环 你可以使用关键字repeat和repeat while和backward进行重复循环。 12345678910111213@startumlstartrepeat :开始; :步骤1; :步骤2;backward:返回到开始;repeat while (返回?)stop@enduml 在这里插入图片描述 while循环 可以使用关键字while和end while进行while循环。 123456789@startuml:i = 5;while (i = 2 ?) is (no) :i--;endwhile (yes):next;@enduml 在这里插入图片描述 注释 使用floating关键字给流程添加注释。 123456789101112131415161718@startumlstart:步骤1;floating note left: 这是一个注释:步骤2;note right 这是一个注释 //lines// and can contain &lt;b&gt;HTML&lt;/b&gt; ==== * Calling the method &quot;&quot;foo()&quot;&quot; is prohibitedend notestop@enduml 在这里插入图片描述 颜色 123456789@startumlstart:步骤1;#HotPink:步骤2;#AAAAAA:步骤3;@enduml 在这里插入图片描述","tags":[]},{"title":"Android 调试桥 (adb)","date":"2020-11-30T06:48:56.000Z","path":"2020/11/30/Android-调试桥-adb/","text":"Android 调试桥 (adb)1- 基本用法 1.1- 命令语法 adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s ] 这一部分，直接使用 adb 。 如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;**serialNumber**&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s 参数，serialNumber 可以通过 adb devices 命令获取 1.2- 启动/停止 启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 1.3- 查看 adb 版本 1adb version 示例输出： 1234apple@fenglolodeMacBook-Pro ~ % adb devices -lList of devices attached8b112f28 device usb:336658432X product:virgo model:MI_NOTE_LTE device:virgo transport_id:3 1.4- 以 root 权限运行 adbd adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 1.5- 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 2- 设备连接管理 2.1- 查询已连接设备/模拟器 命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 3- 应用管理 3.1- 查看应用列表 查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：| 参数 | 显示列表 ||–|–|| 无 | 所有应用 || -f| 显示应用关联的 apk 文件 || -d | 只显示 disabled 的应用|| -e | 只显示 enabled 的应用 || -s | 只显示系统应用 || -3 | 只显示第三方应用 || -i | 显示应用的 installer || -u | 包含已卸载应用 || &lt;**FILTER**&gt; | 包名包含 &lt;**FILTER**&gt; 字符串 | 所有应用 命令： 1adb shell pm list packages 系统应用 命令： 1adb shell pm list packages -s 第三方应用 命令： 1adb shell pm list packages -3 3.2- 安装 APK 命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=”true” 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 3.3- 卸载应用 命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;**packagename**&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 3.4- 清除应用数据与缓存 命令： 1adb shell pm clear &lt;packagename&gt; &lt;**packagename**&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 3.5- 查看应用详细信息 命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;**packagename**&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268Activity Resolver Table: Schemes: ytmbank: 67a95af com.zjrc.cba/com.yitong.mobile.biz.launcher.app.SplashActivity Non-Data Actions: android.intent.action.MAIN: 67a95af com.zjrc.cba/com.yitong.mobile.biz.launcher.app.SplashActivity cn.jiguang.privates.intent.PushActivity: 273dbc com.zjrc.cba/cn.jiguang.privates.push.ui.PushActivity cn.jiguang.privates.intent.JNotifyActivity: ecc145 com.zjrc.cba/cn.jiguang.privates.push.service.JNotifyActivityReceiver Resolver Table: Non-Data Actions: cn.jpush.android.intent.WakedReceiver: 80f809a com.zjrc.cba/.push.biz.PushWakedResultReceiver com.xiaomi.mipush.MESSAGE_ARRIVED: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.xiaomi.mipush.ERROR: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.huawei.android.push.intent.REGISTRATION: b0879a8 com.zjrc.cba/com.huawei.hms.support.api.push.PushReceiver android.net.conn.CONNECTIVITY_CHANGE: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver fd50c66 com.zjrc.cba/com.xiaomi.push.service.receivers.NetworkStatusReceiver com.huawei.intent.action.PUSH_DELAY_NOTIFY: 4618ba7 com.zjrc.cba/com.huawei.hms.support.api.push.PushMsgReceiver cn.jiguang.privates.intent.NOTIFICATION_RECEIVED_PROXY: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver com.zjrc.cba.config.action: 3f8854 com.zjrc.cba/.config.biz.ConfigReceiver com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver cn.jiguang.privates.intent.RECEIVE_MESSAGE: 31588f2 com.zjrc.cba/.push.biz.PushMessageReceiver com.huawei.android.push.intent.RECEIVE: b0879a8 com.zjrc.cba/com.huawei.hms.support.api.push.PushReceiver com.meizu.c2dm.intent.RECEIVE: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.vivo.pushclient.action.RECEIVE: d113b43 com.zjrc.cba/cn.jiguang.privates.push.vivo.receiver.VivoMessageReceiver com.meizu.cloud.pushservice.action.PUSH_SERVICE_START: 936d5c0 com.zjrc.cba/com.meizu.cloud.pushsdk.SystemReceiver com.meizu.flyme.push.intent.MESSAGE: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.meizu.c2dm.intent.REGISTRATION: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver android.intent.action.USER_PRESENT: 79d2cc1 com.zjrc.cba/cn.jiguang.privates.core.service.PushReceiver com.xiaomi.push.PING_TIMER: 3f9b2f9 com.zjrc.cba/com.xiaomi.push.service.receivers.PingReceiver com.xiaomi.mipush.RECEIVE_MESSAGE: 8e4ddcb com.zjrc.cba/cn.jiguang.privates.push.xiaomi.receiver.XiaomiMessageReceiver com.meizu.flyme.push.intent.REGISTER.FEEDBACK: b8ed3fd com.zjrc.cba/cn.jiguang.privates.push.meizu.receiver.MeizuMessageReceiver com.huawei.intent.action.PUSH: 4618ba7 com.zjrc.cba/com.huawei.hms.support.api.push.PushMsgReceiverService Resolver Table: Non-Data Actions: com.huawei.push.msg.NOTIFY_MSG: b6f423e com.zjrc.cba/com.huawei.hms.support.api.push.service.HmsMsgService cn.jpush.android.intent.DaemonService: e82489f com.zjrc.cba/cn.jpush.android.service.DaemonService com.heytap.mcs.action.RECEIVE_MCS_MESSAGE: 9938dec com.zjrc.cba/cn.jiguang.privates.push.oppo.service.OppoHeytapService com.coloros.mcs.action.RECEIVE_MCS_MESSAGE: 99985b5 com.zjrc.cba/cn.jiguang.privates.push.oppo.service.OppoColorosService com.huawei.push.msg.PASSBY_MSG: b6f423e com.zjrc.cba/com.huawei.hms.support.api.push.service.HmsMsgService cn.jiguang.privates.intent.USER_SERVICE: c19444a com.zjrc.cba/.push.biz.PushService com.huawei.push.action.MESSAGING_EVENT: 4cccfbb com.zjrc.cba/cn.jiguang.privates.push.huawei.service.HuaweiMessageServicePermissions: Permission [com.zjrc.cba.permission.PROCESS_PUSH_MSG] (8219cd8): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;b29c831 com.zjrc.cba.permission.PROCESS_PUSH_MSG&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.PUSH_WRITE_PROVIDER] (b6eac97): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;a7fae84 com.zjrc.cba.permission.PUSH_WRITE_PROVIDER&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.push.permission.MESSAGE] (da1b66d): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;8be12a2 com.zjrc.cba.push.permission.MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.JPUSH_MESSAGE] (de77b33): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;f8b2ef0 com.zjrc.cba.permission.JPUSH_MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.C2D_MESSAGE] (4304c69): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;20eb6ee com.zjrc.cba.permission.C2D_MESSAGE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.config.send] (614978f): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;48c4a1c com.zjrc.cba.config.send&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.MIPUSH_RECEIVE] (bf84625): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature perm=Permission&#123;3b353fa com.zjrc.cba.permission.MIPUSH_RECEIVE&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125; Permission [com.zjrc.cba.permission.PUSH_PROVIDER] (44d1dab): sourcePackage=com.zjrc.cba uid=10091 gids=null type=0 prot=signature|privileged perm=Permission&#123;121ec08 com.zjrc.cba.permission.PUSH_PROVIDER&#125; packageSetting=PackageSetting&#123;2af5b16 com.zjrc.cba/10091&#125;Registered ContentProviders: com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider: Provider&#123;78c1fa1 com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider&#125; com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider: Provider&#123;fd2b5c6 com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider&#125; com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider: Provider&#123;d3de987 com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider&#125; com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider: Provider&#123;5edc0b4 com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider&#125; com.zjrc.cba/cn.jpush.android.service.DownloadProvider: Provider&#123;62a14dd com.zjrc.cba/cn.jpush.android.service.DownloadProvider&#125; com.zjrc.cba/android.support.v4.content.FileProvider: Provider&#123;2346852 com.zjrc.cba/android.support.v4.content.FileProvider&#125; com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider: Provider&#123;9859723 com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider&#125; com.zjrc.cba/com.yitong.mobile.framework.utils.YTFileProvider: Provider&#123;a003420 com.zjrc.cba/com.yitong.mobile.framework.utils.YTFileProvider&#125;ContentProvider Authorities: [com.zjrc.cba.DownloadProvider]: Provider&#123;62a14dd com.zjrc.cba/cn.jpush.android.service.DownloadProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.miniprogram.provider]: Provider&#123;fd2b5c6 com.zjrc.cba/com.yitong.miniprogram.framework.android.provider.YTFileProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.hms.update.provider]: Provider&#123;78c1fa1 com.zjrc.cba/com.huawei.hms.update.provider.UpdateProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.huawei.push.provider]: Provider&#123;d3de987 com.zjrc.cba/com.huawei.hms.support.api.push.PushProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.provider]: Provider&#123;2346852 com.zjrc.cba/android.support.v4.content.FileProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.AGCInitializeProvider]: Provider&#123;9859723 com.zjrc.cba/com.huawei.agconnect.core.provider.AGConnectInitializeProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; [com.zjrc.cba.DataProvider]: Provider&#123;5edc0b4 com.zjrc.cba/cn.jiguang.privates.core.service.DataProvider&#125; applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125;Key Set Manager: [com.zjrc.cba] Signing KeySets: 198Packages: Package [com.zjrc.cba] (2af5b16): userId=10091 pkg=Package&#123;98cb79e com.zjrc.cba&#125; codePath=/data/app/com.zjrc.cba-1 dexoptNeeded=false resourcePath=/data/app/com.zjrc.cba-1 legacyNativeLibraryDir=/data/app/com.zjrc.cba-1/lib primaryCpuAbi=armeabi-v7a secondaryCpuAbi=null versionCode=100 targetSdk=30 versionName=1.1.0 splits=[base] applicationInfo=ApplicationInfo&#123;2b821d9 com.zjrc.cba&#125; flags=[ DEBUGGABLE HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] dataDir=/data/user/0/com.zjrc.cba supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-23 16:09:48 firstInstallTime=2020-11-23 16:10:03 lastUpdateTime=2020-11-23 16:10:03 signatures=PackageSignatures&#123;310827f [304724c]&#125; installPermissionsFixed=true installStatus=1 pkgFlags=[ DEBUGGABLE HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] declared permissions: com.zjrc.cba.config.send: prot=signature, INSTALLED com.zjrc.cba.permission.PROCESS_PUSH_MSG: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.PUSH_PROVIDER: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.PUSH_WRITE_PROVIDER: prot=signature|privileged, INSTALLED com.zjrc.cba.permission.JPUSH_MESSAGE: prot=signature, INSTALLED com.zjrc.cba.push.permission.MESSAGE: prot=signature, INSTALLED com.zjrc.cba.permission.C2D_MESSAGE: prot=signature, INSTALLED com.zjrc.cba.permission.MIPUSH_RECEIVE: prot=signature, INSTALLED requested permissions: android.permission.READ_PHONE_STATE android.permission.ACCESS_NETWORK_STATE android.permission.INTERNET android.permission.WRITE_EXTERNAL_STORAGE android.permission.CALL_PHONE android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_WIFI_STATE android.permission.CHANGE_WIFI_STATE android.permission.ACCESS_COARSE_LOCATION android.permission.USE_FINGERPRINT android.permission.REQUEST_INSTALL_PACKAGES android.permission.VIBRATE android.permission.SYSTEM_ALERT_WINDOW android.permission.CAMERA android.permission.FLASHLIGHT android.permission.READ_CONTACTS android.permission.READ_EXTERNAL_STORAGE android.permission.GET_TASKS android.permission.RESTART_PACKAGES android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.WAKE_LOCK android.permission.RECEIVE_USER_PRESENT android.permission.MOUNT_UNMOUNT_FILESYSTEMS android.permission.ACCESS_BACKGROUND_LOCATION android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.READ_PRECISE_PHONE_STATE com.zjrc.cba.permission.PROCESS_PUSH_MSG com.zjrc.cba.permission.PUSH_PROVIDER com.huawei.appmarket.service.commondata.permission.GET_COMMON_DATA android.permission.WRITE_CONTACTS android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR com.zjrc.cba.permission.JPUSH_MESSAGE com.meizu.flyme.push.permission.RECEIVE com.zjrc.cba.push.permission.MESSAGE com.meizu.c2dm.permission.RECEIVE com.zjrc.cba.permission.C2D_MESSAGE com.coloros.mcs.permission.RECIEVE_MCS_MESSAGE com.heytap.mcs.permission.RECIEVE_MCS_MESSAGE com.zjrc.cba.permission.MIPUSH_RECEIVE install permissions: android.permission.RESTART_PACKAGES: granted=true com.zjrc.cba.permission.PROCESS_PUSH_MSG: granted=true com.zjrc.cba.push.permission.MESSAGE: granted=true android.permission.BLUETOOTH: granted=true android.permission.GET_TASKS: granted=true android.permission.INTERNET: granted=true com.zjrc.cba.permission.JPUSH_MESSAGE: granted=true android.permission.BLUETOOTH_ADMIN: granted=true com.zjrc.cba.permission.C2D_MESSAGE: granted=true com.zjrc.cba.permission.MIPUSH_RECEIVE: granted=true android.permission.ACCESS_LOCATION_EXTRA_COMMANDS: granted=true android.permission.CHANGE_WIFI_STATE: granted=true android.permission.FLASHLIGHT: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.USE_FINGERPRINT: granted=true com.zjrc.cba.permission.PUSH_PROVIDER: granted=true android.permission.VIBRATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true android.permission.REQUEST_INSTALL_PACKAGES: granted=true android.permission.WAKE_LOCK: granted=true User 0: installed=true hidden=false stopped=true notLaunched=false enabled=0 gids=[3002, 3003, 3001] runtime permissions: android.permission.READ_PHONE_STATE: granted=true android.permission.CAMERA: granted=true disabledComponents: com.xiaomi.push.service.XMPushService enabledComponents: cn.jpush.android.service.DaemonService cn.jpush.android.service.DownloadProvider 3.6- 查看应用安装路径 命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 4- 文件管理 4.1- 复制设备里的文件到电脑 命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到sdcard，然后 adb pull /sdcard/filename /path/on/pc。 4.2- 复制电脑里的文件到设备 命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc/sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp/sdcard/filename /path/on/device。 5- 查看日志 5.1- Android 日志 命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 5.1.1- 按级别过滤日志 Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多）D —— DebugI —— InfoW —— WarningE —— ErrorF —— FatalS —— Silent（最高，啥也不输出）按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat “*:W”，不然会报错 nomatches found: *:W。） 5.1.2- 按 tag 和级别过滤日志 可以由多个 [:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 5.2- 常用打印日志命令 命令行打印日志1adb logcat -v time 输出日志到本地 log.txt 文件 1adb logcat -v time &gt;log.txt 清空日志 1adb logcat -c 6- 查看设备信息 6.1- 型号 命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 6.2- 电池状况 命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 6.3- 屏幕分辨率 命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 6.4- android_id 命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 6.5- Android 系统版本 命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 7- 实用功能 7.1- 屏幕截图 截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 7.2- 屏幕录制 录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 7.3- 重启手机 命令： 1adb reboot 7.4- 检测设备是否已 root 命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 7.5- 使用 Monkey 进行压力测试 Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 指定的应用程序发送 500 个伪随机事件。","tags":[]},{"title":"Mac下jenkins安装步骤","date":"2020-11-18T02:45:22.000Z","path":"2020/11/18/Mac下jenkins安装步骤/","text":"前言 本文写的是在自己本机上部署jenkins，如果是要部署到服务器，则需要另外配置一些东西。 jenkins下载、安装、配置、新建项目 1、从官网https://jenkins.io/ 上下载最新的pkg安装包,进行安装。 然后一直点击next…就行在这里插入图片描述 2、安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080 在这里插入图片描述这个时候可能会报一个错误。如果出现了这面的问题。这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080会出现下图的重设初始密码的界面。 实际操作过程中分两种情况：一、如果出现/Users/Shared/Jenkins/Home/这样的路径 在这里插入图片描述 按照提示，找到 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录 和initialAdminPassword文件是没有读写权限的,将权限更改成读与写 在这里插入图片描述在这里插入图片描述点击右下角 锁的标志可以修改权限 在这里插入图片描述打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图 在这里插入图片描述二、如果出现的/Users/zhaoziliang/.jenkins/……这样的路径 在这里插入图片描述在/Users/zhaoziliang目录下是找不到.jenkins目录可以通过终端 输入open .jenkins 来打开.jenkinds目录找到initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了 在这里插入图片描述3、安装 在这里插入图片描述在这里插入图片描述在这里插入图片描述4、设置用户名和密码 在这里插入图片描述在这里插入图片描述5、在建立项目之前开始设置,选择系统管理 在这里插入图片描述再选择Global Tool Configuration 在这里插入图片描述配置JDK,Gradle,Git, Gradle版本要和项目里面的Gradle版本一致,否则会报错 在这里插入图片描述在这里插入图片描述在这里插入图片描述在这里插入图片描述JDK 的JAVA_HOME从下图找到 在这里插入图片描述git Path to Git executable 从下图找到 在这里插入图片描述Gradle的 GRADLE_HOME从下图找到 在这里插入图片描述 SDK设置 在这里插入图片描述在这里插入图片描述在这里插入图片描述6、新建项目 在这里插入图片描述填写项目名称选择构建自由风格的项目 在这里插入图片描述将项目地址填进去,填上用户名和密码（项目在git托管的地址和自己的git.feinno的账号密码） 在这里插入图片描述项目中设置周期打包每天六点钟多H 6 * * * 在这里插入图片描述选择Gradle版本 在这里插入图片描述7、fir.im Jenkins 插件使用方法 https://www.jianshu.com/p/9a245918a219 8、注意事项: 构建时,注意自己的项目在Gradle文件里需要配置如下,否则遇到元素重复的时候,直接Error编译不过去.lintOptions {//设置编译的lint开关，程序在buid的时候，会执行lint检查，有任何的错误或者警告提示，都会终止构建abortOnError false 在AndroidStudio里面需要配置的,将签名文件放在app目录下 在这里插入图片描述在build.gradle文件里, 根据自己的项目配置签名文件的信息 . 1234567signingConfigs &#123; release &#123; keyAlias &#x27;&#x27; keyPassword &#x27;&#x27; storeFile file(&#x27;&#x27;) storePassword &#x27;&#x27;&#125;","tags":[]},{"title":"安卓自动化测试工具：「appium + vscode」 安装、配置、使用","date":"2020-11-11T05:50:06.000Z","path":"2020/11/11/安卓自动化测试工具：「appium-vscode」-安装、配置、使用/","text":"一、Appium 1、Appium简介 Appium是一个开源测试自动化框架，可用于原生，混合和移动Web应用程序测试。 它使用WebDriver协议驱动IOS，Android和Windows应用程序。 2、关于Appium的文档 Appium官网 Appiumgithub主页 官方中文文档 3、下载及使用Appium 3.1、到appium官网下载安装即可 3.2、参考文档 安卓平台自动化测试之Appium工具 3.3、配置appium 3.3.1、打开appium 在这里插入图片描述3.3.2、配置sdk和jdk路径 在这里插入图片描述配置完成后，点击 Save and Restart 即可。 3.4、使用appium （1）电脑连接测试机后（也可以使用模拟器），打开appium，点击下图中红框中的按钮 在这里插入图片描述（2）点击下图中编辑按钮，填写连接的手机的信息，格式如下。然后点击Save As…，下次直接可以在Saved找到方便使用 在这里插入图片描述 123456&#123; &quot;platformName&quot;: &quot;Android&quot;, &quot;platformVersion&quot;: &quot;9&quot;, &quot;appPackage&quot;: &quot;com.test.cbaa&quot;, &quot;appActivity&quot;: &quot;com.yitong.mobile.biz.launcher.app.SplashActivity&quot;&#125; 1234platformName //设备类型，我们用的是androidplatformVersion //设备的系统版本号，我用的是安卓9版本的测试机appPackage //我们测试的app的包名appActivity //我们测试的app的启动页路径 （3）然后点击 Start Session 就可以打开我们的app了 在这里插入图片描述 左边是应用程序的屏幕截图，可以在应用程序中使用鼠标来模拟操作。 中间是应用程序的层次结构，表示为XML。您可以通过单击它，或者通过点击屏幕快照视图中的元素来导航这棵树，会被强调。 右侧是细节视图，当一个元素被突出显示时，它的信息会出现在检查器右侧的细节视图中。这个细节视图包括对元素的潜在操作，以及元素属性的表。这些属性在决定如何使用特定的Appium定位策略访问元素时是有价值的。选择一个元素，还可以“Tap”元素，或者“发送键”到元素(如果它是一个文本字段)。 （4）录制脚本 点击下图中的「录制按钮」，然后「鼠标操作」左侧的app，再点击后侧的「Tap按钮」即可录制脚本。每一步操作后，就会生成对应的脚本代码，脚本可支持多种语言选择。 在这里插入图片描述 二、VS Code 1、下载VS Code 下载地址 安装完成后，打开软件会自动提示你安装一些重要插件，如中文语言包，Git等，这里可以直接选择安装Python插件(也可以使用Ctrl+Shift+X可以打开扩展商店然后输入Python搜索)。 vs code如何设置中文 在这里插入图片描述 2、homebrew安装python 2.1、安装 Python3 1brew install python3 2.2、确认安装 123456~ $ python3 --versionPython 3.7.2~ $ which python3/usr/local/bin/python3~ $ which python/usr/bin/python 2.3、确认pip的版本 12345~ $ pip --versionpip 19.0.1 from /Library/Python/2.7/site-packages/pip-19.0.1-py2.7.egg/pip (python 2.7)~ $ pip3 --versionpip 18.1 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) 3、使用VS Code开发Python 3.1、VS Code中下载Python插件 由于Python插件服务器在国外，所以需要配置国内镜像下载比较快。在VS Code命令行中配置更换pip源到国内镜像 在这里插入图片描述 在这里插入图片描述 3.2、选取Python解释器 使用Ctrl+Shift+P打开命令板，输入Python: Select Interpreter进行搜索。接下来会显示VS Code所能找到的全部解释器，选择你需要的哪个就好。 在这里插入图片描述3.3、使用VS Code运行脚本：实现自动化测试 刚刚我们使用appium生成了脚本，现在就派上用场了。 比如刚生成的脚本叫 untitled111.py 使用VS Code打开 untitled111.py 在这里插入图片描述 在空白处右键选择在「终端运行Python文件」，就可以看到运行结果了。 当然也可以debug运行单步调试。 只要电脑连接上测试手机或者模拟器，启动运行脚本，则可以实现自动化测试app啦。","tags":[]},{"title":"Mac通过命令行编辑保存文件","date":"2020-11-09T11:07:51.000Z","path":"2020/11/09/Mac通过命令行编辑保存文件/","text":"1. cd 文件所在目录 2. vi 文件名.文件后缀 3. 输入i，进入insert模式编辑文本 4. esc退出插入模式 5. shift + ：wq 保存文件并退出文本编辑模式","tags":[]},{"title":"博客工具:「hexo+github博客」安装、配置、编写blog","date":"2020-11-09T11:07:51.000Z","path":"2020/11/09/博客工具-「hexo-github博客」安装、配置、编写blog/","text":"前言 hexo+github是一个博客框架,可以很简洁的在本地搭建一个属于自己的blog,有各种不同的自定义风格,同时可以把自己的blog同步到github进行保存 安装+配置 直接给链接,博主写的非常详细1&gt; Mac 系统下搭建hexo个人博客2&gt;Github+Hexo搭建个人博客 hexo主题 有的小伙伴想定制自己独特的主题风格,hexo也可以满足你哦1&gt;hexo官方提供的主题推荐 编写blog 一个blog最主要还是编辑文章,主页搭建的再好看也的需要有干货才行啊是不 1、创建新的文章 1hexo new &quot;name blog的标题&quot; 2、编写blog 1open . 在这里插入图片描述 打开文件夹,在 sourse-_posts 目录下打开刚刚新建的 “name blog的标题” 的文件. 编辑markdown文件，可以使用markdown神器typora。可以看到markdown文件，里面自动生成了题目和时间，还可以写标签，这些我们先不去修改，这些是yaml内容，一般不去修改，修改不好会报错。我们直接在下面编辑一些内容。 3、发布文章至博客 12hexo ghexo d or 1hexo g -d 4、查看blog (1)在本地的hexo中查看 1hexo s 然后打开 http://localhost:4000/ (2)在github中查看 打开自己的github项目即可 hexo常用命令 1234567891011121314151617181920npm install hexo -g //安装 npm update hexo -g //升级 hexo version //查看hexo的版本hexo init nodejs-hexo //创建nodejs-hexo 名字的本地文件hexo init nodejs-hexo //创建博客hexo init blog //初始化，生成文件夹为blogcd blog //进入blog文件夹npm install //安装依赖库hexo generate //生成一套静态网页hexo server //运行测试,浏览器打开地址，http://localhost:4000/hexo deploy //进行部署hexo new &quot;new article&quot; //新建文章‘new article’hexo new page &quot;about&quot; //新建页面 ‘about’hexo n &quot;我的博客&quot;` == `hexo new` &quot;我的博客&quot; //新建文章hexo g == hexo generate //生成`hexo s == hexo server //启动服务预览hexo d == hexo deploy //部署","tags":[]},{"title":"Android 内存泄漏「检测工具」之——LeakCanary2.0","date":"2020-10-23T07:26:25.000Z","path":"2020/10/23/Android-内存泄漏「检测工具」之——LeakCanary2-0/","text":"前言 在Android的性能优化中，内存优化是必不可少的点，而内存优化最重要的一点就是解决内存泄漏的问题，在Android的内存泄漏分析工具也不少，比如PC端的有：AndroidStudio自带的Android Profiler、MAT等工具；手机端也有，就是我们今天要介绍的LeakCanary LeakCanary2.0原理 详见LeakCanary官网文档 LeakCanary2.0使用 1. 集成 LeakCanary2.0只需要在build.gradle中添加依赖即可 1234dependencies&#123; // debugImplementation because LeakCanary should only run in debug builds. debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:2.4&#x27;&#125; 官方给出的这种依赖方式，是为了防止在release环境中使用LeakCanary。 一般开发我们会有debug和release两种buildType，但是如果你想额外创建一个buildType也是可以的，也可以为这个buildType单独设置LeakCanary2.0的依赖。 1234567891011121314151617buildTypes &#123; release &#123; debuggable false //是否开启debug模式 ... &#125; &#125; debug &#123; debuggable true //是否开启debug模式 ... &#125; &#125; debug2 &#123;//新建的一个buildType debuggable true //是否开启debug模式 ... &#125; &#125; &#125; 为debug2单独设置LeakCanary2.0： 123dependencies&#123; debug2Implementation &#x27;com.squareup.leakcanary:leakcanary-android:2.4&#x27;&#125; 2.确认LeakCanary是否运行 在LogCat控制台查看如下日志确认LeakCanary已经运行 1D LeakCanary: LeakCanary is running and ready to detect leaks 参考文献1、LeakCanary原理解析2、LeakCanary2.0使用及原理分析3、leakcanary以及leakcanary2.0使用方法总结4、内存分析工具之LeakCanary2.4使用整理","tags":[]},{"title":"Android monkey测试adb命令","date":"2020-10-23T07:25:51.000Z","path":"2020/10/23/Android-monkey测试adb命令/","text":"Android monkey测试 通用monkey测试命令：adb shell monkey-p com.hoomsun.hxb（包名）–throttle 100–ignore-crashes（忽略崩溃可设置）–ignore-timeouts （忽略超时可设置）–ignore-security-exceptions（索引越界）–ignore-native-crashes–monitor-native-crashes -v -v -v 10000&gt;monkeysss.txt 一、理解monkey测试 1、Monkey测试是Android自动化测试的一种手段。Monkey测试本身非常简单，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。 2、当Monkey程序在模拟器或真实设备运行的时候，程序会产生一定数量或一定时间内的随机模拟用户操作的事件, 如点击，按键，手势等， 以及一些系统级别的事件。通常也称随机测试或者稳定性测试。 二、查看设备连接、包名、和入口Activity 1、进入cmd查看设备连接状态： 1adb devices 2、查看包名、和入口Activity 1234进入cd D:\\Program Files\\adt-bundle-windows-x86_64-20130917\\sdk\\build-tools\\android-4.3 目录下执行下条命令aapt dump badging apk安装包绝对路径 三、运行monkey测试 //不间断操作500次 1adb shell monkey -p 包名 -v 500 //每个操作间隔500ms，共执行100次 1adb shell monkey -p 包名 -v-v --throttle 500 100 //每个操作间隔100ms,共执行1000次 ，其中点击事件占比50%，轨迹50% 1adb shell monkey -p 包名 -v-v --pct-touch 50 --pct-trackball 50 --throttle 100 1000 //日志重定向到桌面文件夹 1adb shell monkey -p 包名 -v-v --pct-touch 50 --pct-trackball 50 --throttle 100 1000 &gt;C:\\Users\\xyp\\Desktop\\Android脚本\\1.log //每个操作间隔500ms、崩溃、超时、许可错误继续执行 1adb shell monkey -p 包名 --throttle 500 --ignore-crashes --ignore-timeouts --ignore-security-exceptions --ignore-native-crashes --monitor-native-crashes -v-v-v 1000000&gt;C:\\Users\\xyp\\Desktop\\Android脚本\\1.log 四、停止monkey测试 重新打开一个cmd窗口进入adb shellps | grep monkey //查找monkey进程kill 进程号 //结束monkey 五、结果分析 得到Monkey测试的log之后，我们可以通过几个关键词来判断测试是否通过。 1、Monkey finished用记事本打开LOG，查看log的最下端，是否有类似以下字段： 12## Network stats: elapsed time=3799ms (3799ms mobile, 0ms wifi, 0ms not connected)// Monkey finished 这个字段表明本次的Monkey测试通过，没有异常 2、CRASH同样，在得到LOG后，搜索”CRASH”字段，如果搜索到有结果，则表明，在测试过程中，测试对象出现了报错现象，因此测试失败。 1// CRASH: com.onekchi.downloadmanager (pid 12919) 3、NOT RESPONDING在log中搜素该字段，如果有搜索有结果，则表示测试过程中，测试对象出现了进程无响应的现象，因此测试失败。 4、无法搜索到上述信息出现这种情况，一般都是外界原因而非程序本身原因。比如测试过程中，电脑断电关机。或者测试过程中内存不足等等，结果作废，需要重新测试。 六、monkey说明 123456789101112131415161718192021--throttle 时间间隔--ignore-crashes 忽略崩溃--ignore-timeouts 忽略超时--ignore-security-exceptions 忽略许可错误--ignore-native-crashes 忽略本地崩溃--monitor-native-crashes 监控本地崩溃 --pct-touch 触摸、点击--pct-motion 调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)--pct-trackball 调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)--pct-nav 调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)--pct-majornav 调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键)--pct-syskeys 调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)--pct-appswitch 调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法--pct-flip 调整“键盘翻转”事件的百分比。--pct-anyevent 调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等 注意：各事件类型的百分比总数不能超过100%。","tags":[]},{"title":"mac安装adb工具","date":"2020-10-23T07:25:14.000Z","path":"2020/10/23/mac安装adb工具/","text":"homebrew是macOS的一个包管理工具 1、安装homebrew 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2、安装adb 1brew cask install android-platform-tools 3、运行adb 1adb devices","tags":[]},{"title":"点击非Edittext触发EditText焦点和自动弹出软键盘","date":"2020-10-23T07:24:23.000Z","path":"2020/10/23/点击非Edittext触发EditText焦点和自动弹出软键盘/","text":"前言 最近做项目时遇到要求点击非EditText时，使该EditText获取焦点并自动弹出软键盘的需求。由于一般情况下我们点击EditText时会自动弹出系统键盘，而对与点击其他button触发EditText的弹出键盘没做过，于是记录下。 实用场景1、点击button时，触发EditText的获取焦点和自动弹出软键盘2、点击某个话题的选项卡，会弹出一个popupwindow，或开启新的ACTIVITY。里面有诸如 评论、回复的选项，你点击这个选项的时候，需要定位到EditText编辑框，并且自动弹出输入法。 方法 12345editText.requestFocus();InputMethodManager imm = (InputMethodManager) login_phone_et.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);if (null != imm) &#123; imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);&#125; 1、通过requestFocus();获取焦点；2、通过InputMethodManager强制弹出键盘； 参考文献 1、事件触发EditText焦点和自动弹出键盘以及InputMethodManager输入法简介","tags":[]},{"title":"Android 获取屏幕、状态栏、标题栏的高度详解","date":"2020-10-23T07:22:18.000Z","path":"2020/10/23/Android-获取屏幕、状态栏、标题栏的高度详解/","text":"前言 如下图：绿色区域：屏幕区域蓝色区域：状态栏区域红色区域：标题栏区域黄色区域：view绘制区域 在这里插入图片描述1.Android手机屏幕的高度（绿色区域） 方法一 123DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);Log.e(&quot;TAG&quot;, &quot;屏幕高:&quot; + dm.heightPixels); 方法二 12DisplayMetrics displayMetrics = getResources().getDisplayMetrics();Log.e(&quot;TAG&quot;,&quot;screenHeight&quot;+displayMetrics.heightPixels); 2.Android手机状态栏的高度（蓝色区域） 方法一 12345678int statusBarHeight1 = -1;//获取status_bar_height资源的IDint resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);if (resourceId &gt; 0) &#123; //根据资源ID获取响应的尺寸值 statusBarHeight1 = getResources().getDimensionPixelSize(resourceId);&#125;Log.e(&quot;TAG&quot;, &quot;方法1:&quot; + statusBarHeight1); 方法二：通过反射 1234567891011int statusBarHeight2 = -1;try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object object = clazz.newInstance(); int height = Integer.parseInt(clazz.getField(&quot;status_bar_height&quot;) .get(object).toString()); statusBarHeight2 = getResources().getDimensionPixelSize(height);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;Log.e(&quot;TAG&quot;, &quot;方法2:&quot; + statusBarHeight2); 方法三：状态栏高度 = 屏幕高度 - 应用区高度 123456789//屏幕DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);//应用区域Rect outRect1 = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);//状态栏高度=屏幕高度-应用区域高度int statusBar = dm.heightPixels - outRect1.height(); Log.e(&quot;TAG&quot;, &quot;方法3:&quot; + statusBar); 3.Android手机应用区域（红+黄区域） 1234//应用区域Rect outRect1 = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);Log.e(&quot;TAG&quot;, &quot;应用区高&quot; + outRect1.height()); 4.Android手机标题高度（红色区域） 12int viewTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();Log.e(&quot;TAG&quot;, &quot;标题栏：&quot; + viewTop); 5.Android手机绘制区域高度(黄色区域) 123Rect outRect2 = new Rect();getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(outRect2);Log.e(&quot;TAG&quot;, &quot;View绘制区域高度：&quot; + outRect2.height()); 参考文献 Android如何获取屏幕、状态栏及标题栏的高度详解","tags":[]},{"title":"Android 硬件加速 4种方式","date":"2020-10-23T07:21:16.000Z","path":"2020/10/23/Android-硬件加速-4种方式/","text":"前言： 硬件加速可以在一下四个级别开启或关闭：（1）Application（2）Activity（3）Window（4）View 1、Application级别 在应用程序AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启硬件加速： 1&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; 2、Activity级别 可以控制每个activity是否开启硬件加速，只需在activity元素中添加android:hardwareAccelerated属性即可办到。比如下面的例子，在application级别开启硬件加速，但在某个activity上关闭硬件加速。 12345&lt;application android:hardwareAccelerated=&quot;true&quot;&gt; &lt;activity ... /&gt; &lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt;&lt;/application&gt; 3、Window级别 如果需要更小粒度的控制，可以使用如下代码开启某个window的硬件加速： 123getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4、View级别 可以在运行时用以下的代码关闭单个view的硬件加速： 1testView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);","tags":[]},{"title":"Android 全面屏显示\\沉浸式状态栏","date":"2020-10-23T07:19:56.000Z","path":"2020/10/23/Android-全面屏显示-沉浸式状态栏/","text":"前言： 之前做项目为了达到全面屏显示，设置了一个theme主题样式，如下： 1234&lt;!-- 应用全屏样式 --&gt; &lt;style name=&quot;AppFullWindowTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 但是在部分手机上会出现一个坑爹的现象：虽然状态栏隐藏了，但是原状态栏位置上会被黑条占领。（没错，就是在万恶的小米手机上出现了…） 解决方案： 方案1:在代码中设置 1234567891011WindowManager.LayoutParams lp = activity.getWindow().getAttributes(); lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; activity.getWindow().setAttributes(lp); View decorView = activity.getWindow().getDecorView(); int systemUiVisibility = decorView.getSystemUiVisibility(); int flags =View.SYSTEM_UI_FLAG_HIDE_NAVIGATION//隐藏导航栏 | View.SYSTEM_UI_FLAG_FULLSCREEN;//隐藏状态栏 systemUiVisibility |= flags; activity.getWindow().getDecorView().setSystemUiVisibility(systemUiVisibility); 方案2:在xml中设置theme 12345&lt;style name=&quot;AppFullTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowLayoutInDisplayCutoutMode&quot;&gt;shortEdges&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 注解1: Android P版本为我们提供了解决方法，我们可以通过对Window设置layoutInDisplayCutoutMode来达到我们的目的，先来看一下layoutInDisplayCutoutMode的几种属性： LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：默认情况下，全屏窗口不会使用到刘海区域，非全屏窗口可正常使用刘海区域LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：窗口不允许和刘海屏重叠LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES：该窗口始终允许延伸到屏幕短边上的DisplayCutout区域。 注解2: 了解一下几个设置沉浸式状态栏的基础属性： 1.View.SYSTEM_UI_FLAG_LOW_PROFILE：低调模式, 会隐藏不重要的状态栏图标；2.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏导航栏；3.View.SYSTEM_UI_FLAG_FULLSCREEN：状态栏隐藏（高度不变）；4.View.SYSTEM_UI_FLAG_LAYOUT_STABLE：保持整个View稳定, 常和控制System UI悬浮, 隐藏的Flags共用, 使View不会因为System UI的变化而重新layout；5.View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：视图延伸至导航栏区域，导航栏覆盖在视图之上（在style中设置windowTranslucentNavigation）；6.View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ：视图延伸至状态栏区域，状态栏覆盖在视图之上（在style中设置windowTranslucentStatus）；7.View.SYSTEM_UI_FLAG_IMMERSIVE：配合2或3同时使用，假设同时设置了2和7，状态栏隐藏，此时在状态栏顶部下滑，系统清除2设置，重新唤出状态栏，导航栏同理，滑动方向为由下至上；8.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY：作用与7相似，但是设置并未被清楚，所以状态栏与导航栏在被唤出3s后或再次点击时，再次隐藏。","tags":[]},{"title":"Mac 电脑查看本机的mac地址和ip地址","date":"2020-10-23T07:18:44.000Z","path":"2020/10/23/Mac-电脑查看本机的mac地址和ip地址/","text":"Mac电脑：获取mac地址和ip地址 方法1：通过「命令行」获取 打开命令行，输入ifconfig，然后找到en0，找到ether对应的就是mac地址，找到inet对应的就是ip地址。 在这里插入图片描述 方法2：通过「查看关于本机信息」获取 打开关于本机 -&gt; 系统报告 -&gt; 左侧找到“WIFI” -&gt; 右边找到“en0”目录下的MAC地址 在这里插入图片描述 在这里插入图片描述在这里插入图片描述方法三：通过「系统偏好设置」获取 打开“系统偏好设置” -&gt; “网络” -&gt; “高级” -&gt; “TCP/IP”查看ip -&gt; “硬件”查看mac地址 在这里插入图片描述在这里插入图片描述在这里插入图片描述在这里插入图片描述","tags":[]},{"title":"Android 防止按钮多次重复点击之「防重复点击」","date":"2020-10-23T07:17:47.000Z","path":"2020/10/23/Android-防止按钮多次重复点击之「防重复点击」/","text":"前言 为了防止“按钮”的点击事件在短时间内多次点击从而触发了多次处理操作；比如：快速点击“登录按钮”发送了多次登录接口，导致程序在短时间内进行多次数据提交or数据处理，这样的体验就不太好了。 方法 判断用户点击按钮间隔时间，如果间隔时间太短，则认为是无效操作，否则进行相关业务处理 1234567891011121314151617181920/** * 判断两次点击事件的间隔 */public class ClickHelper &#123; private static long lastClickTime = 0; /** * 判断事件出发时间间隔是否超过预定值 * 如果小于间隔（目前是1000毫秒）则返回true，否则返回false */ public static boolean isFastDoubleClick() &#123; long time = System.currentTimeMillis(); long timeD = time - lastClickTime; if (0 &lt; timeD &amp;&amp; timeD &lt; 1000) &#123; return true; &#125; lastClickTime = time; return false; &#125;&#125; 调用demo 123456789btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (ClickHelper.isFastDoubleClick()) &#123;//连续点击 return; &#125; ...//此处添加点击按钮后的触发事件处理 &#125; &#125;);","tags":[]},{"title":"macOS Catalina(10.15.6)双网卡同时连内外网","date":"2020-10-23T07:17:03.000Z","path":"2020/10/23/macOS-Catalina-10-15-6-双网卡同时连内外网/","text":"前提 使用网线连接内网，此时不能连接外网，无线可以连接外网，却又不能完成部分在内网才能完成的操作 1、修改无线网卡的优先级，使之大于有线网卡 在这里插入图片描述在这里插入图片描述 进入系统偏好设置，网络，左下角的齿轮，更改服务顺序，拖动wifi到有线网卡上面就可以了（我的有线网卡是AX8817） 此时变成的状态是连着无线，插着网卡，以无线网卡优先，即上不了内网，可以上外网（苹果默认的是插上有线网络有线优先） 2、设置路由修改连接内网使用的网卡 由于公司里内外网分两个路由，只需要修改前往公司内网地址的网关就可以了，比如你需要访问的内网地址是158.220.155.188和158.220.21.39，而公司的内网网关是158.223.13.254，那么就这样写 12345678910$ sudo route delete -net 158.220.155.188 $ sudo route -n add -net 158.220.155.188 158.223.13.254 $ sudo route delete -net 158.220.21.39 $ sudo route -n add -net 158.220.21.39 158.223.13.254 # 列出全部的路由信息$ sudo netstat -nr 如果公司里内外网是一个路由，或者两个路由在同一个网段之内。此时需要有线网卡转发内网链接，无线网卡转发外网链接，写法如下： 123$ sudo route delete -net 158.220.155.188 $ sudo route add -net 158.220.155.188 -netmask 255.255.255.0 -interface en10 3、如何自动在每次启动的时候都切换到当前的路由表 当mac每次重启的时候，路由表都会被重置；或者拔了网线之后再连接网线，也会重置。这时候避免每次我们都需要执行命令行，可以使用macOS里好用的小机器人 Automator来帮我们。在这里插入图片描述 在这里插入图片描述点击右上角的「运行」就OK了。 参考链接 Macbook利用双网卡同时连内外网","tags":[]},{"title":"Android dp和px之间相互转换","date":"2020-10-23T07:16:23.000Z","path":"2020/10/23/Android-dp和px之间相互转换/","text":"前言 android中在xml布局中我们可以使用dp和px都可以；但是在代码中，很多方法只提供了设置px的方法，这时候就需要用到dp和px相互切换了。 方法 123456789101112131415161718192021/** * dp和px之间进行转换 */public class DensityHelper &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125;","tags":[]},{"title":"Android 限制EditText输入的文本行数为1","date":"2020-10-23T07:12:49.000Z","path":"2020/10/23/Android-限制EditText输入的文本行数为1/","text":"前言： android Edittext默认是可以换行的，但当我们用来作为输入账号、密码的时候，是希望它作为一行来展示，并不想让它可以换行。 方法1： 「不建议」 xml设置maxlines属性： 1android:maxlines=&quot;1&quot; 此属性设置为1，发现仅仅是显示1行，但按下回车仍然生效，可以换行输入。 方法2：「不建议」 xml设置singleLine属性： 1android:singleLine=&quot;true&quot; 可以保证EditText为单行，但此方法在Android 7.0的环境下过期了 **方法3:**「实用」 xml设置lines和inputType属性： 12android:inputType=&quot;text&quot;android:lines=&quot;1&quot; 两项属性如上配置，可实现EditText输入框屏蔽回车键，按下回车键为换行的功能。 方法4: 动态用addTextChangedListener去监听控件中文本的变化： 需要实现的函数有三个： 12345public void beforeTextChanged(CharSequence A, int B, int C,int D)public void onTextChanged(CharSequence A, int B, int C, int D)public void afterTextChanged(Editable A) 这个三个函数描述了editText控件的一次输入过程： beforeTextChanged 字符串A中从索引B位置开始的C个字符将被D个字符替换onTextChanged 字符串A中从索引B位置开始的C个字符刚刚被D个字符替afterTextChanged 控件中现在的字符 这里beforeTextChanged ，onTextChanged 这两个函数中是不能对控件内容进行重新的设定的，但是afterTextChanged 是可以递归的，当然要能正确的结束递归过程。 1234567891011121314151617181920212223242526272829303132EditText.addTextChangedListener @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // TODO Auto-generated method stub &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; // TODO Auto-generated method stub &#125; @Override public void afterTextChanged(Editable s) &#123; // TODO Auto-generated method stub int lines = editText.getLineCount(); // 限制最大输入行数 if (lines &gt; MAXLINES) &#123; String str = s.toString(); int cursorStart = editText.getSelectionStart(); int cursorEnd = editText.getSelectionEnd(); if (cursorStart == cursorEnd &amp;&amp; cursorStart &lt; str.length() &amp;&amp; cursorStart &gt;= 1) &#123; str = str.substring(0, cursorStart-1) + str.substring(cursorStart); &#125; else &#123; str = str.substring(0, s.length()-1); &#125; // setText会触发afterTextChanged的递归 editText.setText(str); // setSelection用的索引不能使用str.length()否则会越界 editText.setSelection(editText.getText().length()); &#125; &#125;","tags":[]},{"title":"MAC下Apktool、dex2jar、jd-gui的安装和反编译、回编译、重新签名简单使用","date":"2020-10-23T07:12:11.000Z","path":"2020/10/23/MAC下Apktool、dex2jar、jd-gui的安装和反编译、回编译、重新签名简单使用/","text":"一、安装 1、安装Apktool 方法1：普通下载安装 下载Apktool 下载Apktool安装包脚本 macOS：下载Mac 包装器脚本（右键单击，将链接另存为apktool）下载apktool-2（在这里找到最新的）将下载的jar重命名为 apktool.jar将两个文件（apktool.jar＆apktool）移动到/usr/local/bin（需要root）确保两个文件均可执行（chmod +x）尝试apktool通过cli 运行 12$：cd /usr/local/bin$：chmod +x apktool 方法2:使用homebrew安装 或者您可以通过Homebrew安装apktool ：如本页所述安装Homebrewbrew install apktool在终端中执行命令（无需root）。最新版本将安装/usr/local/Cellar/apktool/[version]/并链接到/usr/local/bin/apktool。尝试apktool通过cli 运行注意 -包装脚本不是必需的，但很有用，因此您不必java -jar apktool.jar一遍又一遍地输入。 123brew install apktool# 验证安装结果apktool -version 2、安装dex2jar 需要注意的是，假如使用dex2jar遇到报错 com.googlecode.d2j.DexException: not support version。则说明你安装的版本不兼容，所以尽量安装最新版本。 下载地址：https://github.com/pxb1988/dex2jar/tree/2.1-nightly-28 在这里插入图片描述点击右下角的Latest按钮，选择最新版本进行下载； 在这里插入图片描述最后点击下载zip文件，解压就OK了。我比较懒，直接把dex2jar放在了桌面，也方便我使用。 3、安装JD-GUI 官网下载地址：http://java-decompiler.github.io/ 在这里插入图片描述把app文件拖到Application文件夹下就ok了。 二、反编译流程 现在桌面上有一个demo.apk文件，我们复制一份，demo副本.apk将副本文件名的后缀改为zip，即demo副本.zip 1. 获取xml反编译文件和smail代码 启动终端 12$：cd /Users/apple/Desktop $：apktool d demo.apk 注意，demo.apk 要在控制台的当前目录下，因为demo.apk 在桌面，所以我先cd到了桌面的目录。 其中d是decode的意思，表示我们要对Demo.apk这个文件进行解码。那除了这个基本用法之外，我们还可以再加上一些附加参数来控制decode的更多行为：· f 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。·o 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹。·s 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。·r 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）。常用用法就这么多了，那么上述命令的执行结果如下图所示：原文链接：https://blog.csdn.net/u013082948/article/details/52195514 2. 反编译calss.dex文件 刚刚的demo副本.zip解压获得demo副本文件夹，进入文件夹后拷贝classes.dex(如果解压失败，换一个解压软件，不用系统自带的) 打开dex2jar 解压的目录，将classes.dex文件复制进去 由于我的dex2jar文件夹在桌面上，所以终端直接执行： 12apple@fenglolodeMacBook-Pro ~ % cd /Users/apple/Desktop/dex-tools-2.1 apple@fenglolodeMacBook-Pro dex-tools-2.1 % ./d2j-dex2jar.sh classes.dex 如果没有执行权限 123apple@fenglolodeMacBook-Pro ~ % cd /Users/apple/Desktop/dex-tools-2.1 apple@fenglolodeMacBook-Pro dex-tools-2.1 % chmod +x ./*apple@fenglolodeMacBook-Pro dex-tools-2.1 % ./d2j-dex2jar.sh classes.dex 这个时候文件夹下回多出一个jar文件classes-dex2jar.jar 3. 查看jar文件代码 打开 JD-GUI ，将 jar 拖拽到 JD-GUI 区域就可以看代码了（该代码是混淆之后的） 三、回编译流程 以demo.apk通过 apktool d demo.apk 反编译生成的demo文件为例：命令行窗口输入 1apktool b demo 新生成的apk会在demo/dist/目录下面。若报错则输入apktool -r b name,资源文件不反编译，避免资源报错 四、apk 签名，打包 命令行窗口输入 12jarsigner -verbose -keystore 签名文件名字 -signedjar newName.apk oldName.apk 签名文件名字输入密钥库的密码短语: 备注：签名文件名字：如abc.keystorenewName.apk：签名后的apk的名字，可自定义oldName.apk：需要被签名的apk的名字，如我的案例中应为demo.apk 然后输入你的签名文件的密码就开始重新签名了，签名后的apk为你自定义的newName.apk。","tags":[]},{"title":"记录wget使用详解 & Mac安装wget","date":"2020-10-23T07:11:37.000Z","path":"2020/10/23/记录wget使用详解-Mac安装wget/","text":"一、记录wget使用详解 1、什么是wget 百度百科介绍的wget 2、wget命令详解 来自大牛随性i的文章介绍的wget命令详解 二、Mac安装wget的两种方法 1、手动下载并终端安装 从ftp://ftp.gnu.org/gnu/wget/下载到最新的wget安装包到本地 将解压的安装包放到自己想要保管的路径下，然后在终端进入对应的安装包位置，如果不知道文件的路径可查看文件的简介-位置 或者直接把文件拖进终端即可显示文件路径 打开终端，进入wget文件路径，然后在终端依次输入：./configure、 make 以及 make install 命令 2、直接终端使用homebrew安装 执行安装brew（homebrew官网地址） 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 安装 wget 1brew install wget","tags":[]},{"title":"Android Dialog 去掉透明遮罩层「全透明」","date":"2020-10-23T07:10:07.000Z","path":"2020/10/23/Android-Dialog-去掉透明遮罩层「全透明」/","text":"dialog即使设置透明背景也会有一个蒙层（遮罩层），有时候因为UI设计并不想要这个蒙层。 一行代码搞定 1dialog.getWindow().setDimAmount(0f);","tags":[]},{"title":"Android 使用简单帧动画实现一个自定义动态等待层","date":"2020-10-23T07:09:27.000Z","path":"2020/10/23/Android-使用简单帧动画实现一个自定义动态等待层/","text":"前言 项目中有时候需要自定义等待层，使用帧动画实现一个动态的等待层还是不错的。 一、简单帧动画实现 1.在drawable下创建loading_view.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/loading_001&quot; android:duration=&quot;50&quot;/&gt; &lt;item android:drawable=&quot;@drawable/loading_002&quot; android:duration=&quot;50&quot;/&gt; &lt;item android:drawable=&quot;@drawable/loading_003&quot; android:duration=&quot;50&quot;/&gt;&lt;/animation-list&gt; 2.在xml布局中调用loading_view 123456&lt;ImageView android:id=&quot;@+id/img_loading_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:src=&quot;@drawable/loading_view&quot; /&gt; 3、在代码中调用 12345ImageView imgLoadingView = (ImageView) view.findViewById(R.id.img_loading_view);AnimationDrawable animationDrawable = (AnimationDrawable) imgLoadingView.getDrawable();animationDrawable.start();//开启动画animationDrawable.stop();//关闭动画 二、帧动画等待层 只需要自定义一个dialog，xml布局中使用以上帧动画即可。当开启等待层时调用： animationDrawable.start();//开启动画 当关闭等待层时调用： animationDrawable.stop();//关闭动画","tags":[]},{"title":"Android 自定义dialog学习之——自定义一个提示框","date":"2020-10-23T07:05:42.000Z","path":"2020/10/23/Android-自定义dialog学习之——自定义一个提示框/","text":"前言 最近项目中觉的Android系统的dialog样式太丑，确实也不太好看，就打算自定义一个dialog来使用。 自定义dialog实例demo 1、布局dialog_alert 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;@dimen/dp_550&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@drawable/new_dialog_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题--&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_80&quot; android:layout_marginLeft=&quot;@dimen/dp_60&quot; android:layout_marginRight=&quot;@dimen/dp_60&quot; android:gravity=&quot;center|bottom&quot; android:text=&quot;@string/title&quot; android:textColor=&quot;@color/color_222222&quot; android:textSize=&quot;@dimen/dp_32&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;!--提示信息--&gt; &lt;TextView android:id=&quot;@+id/tv_msg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;@dimen/dp_60&quot; android:layout_marginTop=&quot;@dimen/dp_36&quot; android:layout_marginRight=&quot;@dimen/dp_60&quot; android:layout_marginBottom=&quot;@dimen/dp_50&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/color_222222&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_1&quot; android:background=&quot;@color/color_E8E8E8&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp_92&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;!--取消按钮--&gt; &lt;TextView android:id=&quot;@+id/tv_cancel&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/tv_cancel&quot; android:textColor=&quot;@color/color_666666&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;View android:id=&quot;@+id/v_line&quot; android:layout_width=&quot;@dimen/dp_1&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/color_E8E8E8&quot; /&gt; &lt;!--确认按钮--&gt; &lt;TextView android:id=&quot;@+id/tv_ok&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/tv_ok&quot; android:textColor=&quot;@color/color_00A1C1&quot; android:textSize=&quot;@dimen/dp_28&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; new_dialog_bg 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 边框的宽度和颜色 --&gt; &lt;stroke android:width=&quot;@dimen/dp_1&quot; android:color=&quot;#E8E8E8&quot; /&gt; &lt;!-- 圆角的半径 --&gt; &lt;corners android:radius=&quot;@dimen/dp_12&quot; /&gt; &lt;!-- 填充颜色 --&gt; &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&lt;/shape&gt; 2、代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class MyDialog extends Dialog implements View.OnClickListener &#123; private TextView tv_title; private TextView tv_msg; private TextView tv_cancel; private TextView tv_ok; private View v_line; private OkOnClickListener okOnClickListener; private CancelOnClickListener cancelOnClickListener; public MyDialog(@NonNull Context context) &#123; this(context, R.style.BaseDialogStyle); &#125; public MyDialog(@NonNull Context context, int themeResId) &#123; super(context, themeResId); setContentView(R.layout.dialog_alert); initView(); initAction(); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); WindowManager m = getWindow().getWindowManager(); Display d = m.getDefaultDisplay(); WindowManager.LayoutParams p = getWindow().getAttributes(); p.width = d.getWidth(); //设置dialog的宽度为当前手机屏幕的宽度 getWindow().setAttributes(p); &#125; private void initView() &#123; tv_title = findViewById(R.id.tv_title); tv_msg = findViewById(R.id.tv_msg); tv_cancel = findViewById(R.id.tv_cancel); tv_ok = findViewById(R.id.tv_ok); v_line = findViewById(R.id.v_line); tv_ok.setOnClickListener(this); tv_cancel.setOnClickListener(this); &#125; //默认设置ok和cancel按钮都不可见：这样可以代码动态设置只显示一个按钮或者两个按钮，使控件更加实用 private void initAction() &#123; tv_cancel.setVisibility(View.GONE); tv_ok.setVisibility(View.GONE); v_line.setVisibility(View.GONE); &#125; //设置title public MyDialog setTitle(String title) &#123; if (this.tv_title != null) &#123; this.tv_title.setText(StringUtil.isEmpty(title) ? this.getContext().getResources().getString(R.string.title) : title); &#125; return this; &#125; //设置msg public MyDialog setMessage(String message) &#123; if (this.tv_msg != null) &#123; this.tv_msg.setText(StringUtil.isEmpty(message) ? &quot;&quot; : message); &#125; return this; &#125; //设置ok按钮点击事件 public MyDialog setPositiveButton(String okMsg, OkOnClickListener okOnClickListener) &#123; if (this.tv_ok != null) &#123; this.tv_ok.setVisibility(View.VISIBLE); this.tv_ok.setText(StringUtil.isEmpty(okMsg) ? this.getContext().getResources().getString(R.string.tv_ok) : okMsg); this.okOnClickListener = okOnClickListener; &#125; return this; &#125; //设置cancel按钮点击事件 public MyDialog setNegativeButton(String cancelMsg, CancelOnClickListener cancelOnClickListener) &#123; if (this.tv_cancel != null) &#123; this.tv_cancel.setVisibility(View.VISIBLE); this.v_line.setVisibility(View.VISIBLE); this.tv_cancel.setText(StringUtil.isEmpty(cancelMsg) ? this.getContext().getResources().getString(R.string.tv_cancel) : cancelMsg); this.cancelOnClickListener = cancelOnClickListener; &#125; return this; &#125; @Override public void onClick(View v) &#123; dismiss(); int id = v.getId(); if (id == R.id.tv_ok) &#123; if (okOnClickListener != null) &#123; okOnClickListener.confirm(); &#125; &#125; else if (id == R.id.tv_cancel) &#123; if (cancelOnClickListener != null) &#123; cancelOnClickListener.cancel(); &#125; &#125; &#125; public interface OkOnClickListener &#123; void confirm(); &#125; public interface CancelOnClickListener &#123; void cancel(); &#125;&#125; 3、调用dialog我们写一个工具类来调用，这样全局只需要调用工具类就ok了，不用每次都new一个dialog对象来调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//工具类public class DialogHelper &#123; /** * 单按钮dialog弹出框 * * @param context 上下文 * @param title 标题 * @param msg 内容 * @param cancelOutSide 是否可以点击dialog外部时关闭dialog * @param ok 确认按钮 * @param okOnClickListener 确认回调 */ public static void showDialog(Context context, String title, String msg, boolean cancelOutSide, String ok, MyDialog.OkOnClickListener okOnClickListener) &#123; showDialog(context, title, msg, true, cancelOutSide, ok, okOnClickListener, &quot;&quot;, null); &#125; /** * 双按钮dialog弹出框 * * @param context 上下文 * @param title 标题 * @param msg 内容 * @param hideCancel 是否隐藏“取消”按钮 * @param cancelOutSide 是否可以点击dialog外部时关闭dialog * @param ok 确认按钮 * @param okOnClickListener 确认回调 * @param cancel 取消按钮 * @param cancelOnClickListener 取消回调 */ public static void showDialog(Context context, String title, String msg, boolean hideCancel, boolean cancelOutSide, String ok, MyDialog.OkOnClickListener okOnClickListener, String cancel, MyDialog.CancelOnClickListener cancelOnClickListener) &#123; MyDialog dialog = new MyDialog(context); dialog.setTitle(title); dialog.setMessage(msg); dialog.setCanceledOnTouchOutside(cancelOutSide); dialog.setCancelable(cancelOutSide); dialog.setPositiveButton(ok, okOnClickListener); if (!hideCancel) &#123; dialog.setNegativeButton(cancel, cancelOnClickListener); &#125; dialog.show(); &#125;&#125; 4、最后附上自定义dialog的样式 在这里插入图片描述","tags":[]},{"title":"Mac 中 Android Studio使用内存调整方法","date":"2020-10-23T07:05:01.000Z","path":"2020/10/23/Mac-中-Android-Studio使用内存调整方法/","text":"Mac下调整Android Studio可使用内存大小 前言 当使用 MAC 安装完 AS 后，系统会给AS的内存值分配一个默认值，这个默认值是一个通用的，不可能去适配到每台机器。默认的值在/Applications/Android Studio.app/Contents/bin/studio.vmoptions这个文件里面 12345678910111213141516171819-Xms256m-Xmx1280m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-XX:CICompilerCount=2-Dsun.io.useCanonPrefixCache=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;-Djdk.attach.allowAttachSelf=true-Dkotlinx.coroutines.debug=off-Djdk.module.illegalAccess.silent=true-Djna.nosys=true-Djna.boot.library.path=-XX:+UseCompressedOops-Dfile.encoding=UTF-8-XX:ErrorFile=$USER_HOME/java_error_in_studio_%p.log-XX:HeapDumpPath=$USER_HOME/java_error_in_studio.hprof 修改方式1:（不建议） 可以直接修改/Applications/AndroidStudio.app/Contents/bin/studio.vmoptions这个文件的内容，但是不建议直接修改该安装目录下的配置，如果修改了这个配置，每当你升级AS的时候都会有个alert框提示：这个目录下有冲突了，还是有点烦的。 修改方式2:（推荐） 修改~/Library/Preferences/AndroidStudio4.0/目录下的studio.vmoptions文件，如果没这个文件的话就自己touch个，最后将自己的配置写进去 如果你用的是别的版本的AS，上面的路径需要对应到正确的版本，比如用的是AS v3.1，那么对应的路径应该是~/Library/Preferences/AndroidStudio3.1/ 以下是我的修改的配置： 12# custom Android Studio VM options, see https://developer.android.com/studio/intro/studio-config.html-Xmx4096m","tags":[]},{"title":"Android ViewFlipper控件使用之——图片切换的实现「带手势检测」","date":"2020-10-23T07:04:15.000Z","path":"2020/10/23/Android-ViewFlipper控件使用之——图片切换的实现「带手势检测」/","text":"使用ViewFlipper控件实现图片切换参考：ViewFlipper使用详解 前言 ViewFlipper是一个切换控件1、一般用于图片的切换2、也可以用来添加View，不限定只用于ImageView，也可以是自定义View；只是我们经常利用ViewFlipper来实现ImageView的切换，如果切换自定义的View，使用ViewPager做更方便吧。 一、使用ViewFlipper实现「图片切换」demo案例 ViewFlipper布局： 123456&lt;ViewFlipper android:id=&quot;@+id/flipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;10dp&quot; android:flipInterval=&quot;2000&quot; /&gt; 代码实现： 123456789101112ViewFlipper mFlipper = findViewById(R.id.flipper); mFlipper.addView(getImageView(R.mipmap.img_1)); mFlipper.addView(getImageView(R.mipmap.img_2)); mFlipper.addView(getImageView(R.mipmap.img_3)); mFlipper.addView(getImageView(R.mipmap.img_4)); if (mFlipper.getChildCount() &gt; 1) &#123; mFlipper.startFlipping(); &#125; else &#123; mFlipper.stopFlipping(); &#125; 二、完整版demo「包含手势检测，可以手动滑动图片切换」 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 图片切换demo:手势切换 */public class TwoActivity extends Activity &#123; private ViewFlipper mFlipper; private GestureDetector mDetector; //手势检测 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_two); initView(); initData(); initAction(); &#125; private void initView() &#123; mFlipper = findViewById(R.id.flipper); mDetector = new GestureDetector(new simpleGestureListener()); &#125; private void initData() &#123; mFlipper.addView(getImageView(R.mipmap.img_1)); mFlipper.addView(getImageView(R.mipmap.img_2)); mFlipper.addView(getImageView(R.mipmap.img_3)); mFlipper.addView(getImageView(R.mipmap.img_4)); &#125; @SuppressLint(&quot;ClickableViewAccessibility&quot;) private void initAction() &#123; mFlipper.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; return mDetector.onTouchEvent(motionEvent);//手势监听 &#125; &#125;); if (mFlipper.getChildCount() &gt; 1) &#123; mFlipper.startFlipping(); &#125; else &#123; mFlipper.stopFlipping(); &#125; &#125; private ImageView getImageView(int id) &#123; ImageView imageView = new ImageView(this); imageView.setImageResource(id); return imageView; &#125; private class simpleGestureListener extends GestureDetector.SimpleOnGestureListener &#123; final int FLING_MIN_DISTANCE = 100, FLING_MIN_VELOCITY = 200; //不知道为什么，不加上onDown函数的话，onFling就不会响应，真是奇怪 @Override public boolean onDown(MotionEvent e) &#123; return true; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; // Fling left if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; mFlipper.showNext();//展示下一张图片 Toast.makeText(TwoActivity.this, &quot;Fling Left&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123; // Fling right mFlipper.showPrevious();//展示上一张图片 Toast.makeText(TwoActivity.this, &quot;Fling Right&quot;, Toast.LENGTH_SHORT).show(); &#125; return true; &#125; &#125;&#125;","tags":[]},{"title":"Android  ViewFlipper控件使用之——滑动轮播公告的实现","date":"2020-10-23T07:03:35.000Z","path":"2020/10/23/Android-ViewFlipper控件使用之——滑动轮播公告的实现/","text":"使用ViewFlipper控件实现轮播公告前言 ViewFlipper是一个切换控件1、一般用于图片的切换2、也可以用来添加View，不限定只用于ImageView，也可以是自定义View；只是我们经常利用ViewFlipper来实现ImageView的切换，如果切换自定义的View，使用ViewPager做更方便吧。 一、使用ViewFlipper实现轮播公告demo案例 1、布局文件配置： ViewFlipper布局： 123456789&lt;ViewFlipper android:id=&quot;@+id/vf_notice&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:autoStart=&quot;true&quot; android:background=&quot;@mipmap/new_home_bubble&quot; android:flipInterval=&quot;3000&quot; android:inAnimation=&quot;@anim/home_notice_in&quot; android:outAnimation=&quot;@anim/home_notice_out&quot; /&gt; 进入动画home_notice_in： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;100.0%p&quot; android:toYDelta=&quot;0.0&quot;/&gt; &lt;alpha android:duration=&quot;500&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;&lt;/set&gt; 滑出动画home_notice_out: 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;500&quot; android:fromYDelta=&quot;0.0&quot; android:toYDelta=&quot;-100.0%p&quot;/&gt; &lt;alpha android:duration=&quot;500&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot;/&gt;&lt;/set&gt; new_notice_item布局自定义view填充ViewFlipper「这里demo使用的是ViewFlipper.add(view)方式」 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_value&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;20dp&quot; android:gravity=&quot;center_vertical&quot; android:ellipsize=&quot;end&quot; android:maxLines=&quot;1&quot; android:text=&quot;测试测试&quot; android:textColor=&quot;#256470&quot; android:textSize=&quot;20dp&quot;/&gt;&lt;/LinearLayout&gt; 2、代码逻辑实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends Activity &#123; private ViewFlipper mViewFlipper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mViewFlipper = (ViewFlipper) findViewById(R.id.vf_notice); &#125; private void initData() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;这是公告111&quot;); list.add(&quot;这是公告222&quot;); list.add(&quot;这是公告333&quot;); initNotice(list); &#125; //设置滑动轮播list private void initNotice(final List&lt;String&gt; list) &#123; mViewFlipper.removeAllViews();//先移除之前的所有view for (int i = 0; i &lt; list.size(); i++) &#123; View view = LayoutInflater.from(this).inflate(R.layout.new_notice_item, null); TextView tvValue = (TextView) view.findViewById(R.id.tv_value); tvValue.setText(list.get(i)); final int finalI = i; view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, list.get(finalI), Toast.LENGTH_SHORT).show(); &#125; &#125;); mViewFlipper.addView(view);//add方式进行添加 &#125; if (mViewFlipper.getChildCount() &gt; 1) &#123; mViewFlipper.startFlipping();//开启动画 &#125; else &#123; mViewFlipper.stopFlipping();//关闭动画 &#125; &#125;&#125; 二、ViewFlipper使用介绍 1、在xml布局中的方法介绍: 1234567android:autoStart： 设置自动加载下一个Viewandroid:flipInterval：设置View之间切换的时间间隔android:inAnimation： 设置切换View的进入动画android:outAnimation：设置切换View的退出动画 2、在代码中设置的方法介绍： 12345678910111213141516isFlipping： 判断View切换是否正在进行setFilpInterval：设置View之间切换的时间间隔startFlipping： 开始View的切换，而且会循环进行stopFlipping： 停止View的切换setOutAnimation：设置切换View的退出动画setInAnimation： 设置切换View的进入动画showNext： 显示ViewFlipper里的下一个ViewshowPrevious： 显示ViewFlipper里的上一个View demo 12345viewflipper.setInAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.home_notice_in)); viewflipper.setOutAnimation(AnimationUtils.loadAnimation(MainActivity.this, R.anim.home_notice_out)); viewflipper.showNext();","tags":[]},{"title":"Android 获取手机设备信息：名称、型号、系统版本号、厂商、设备制造商、SDK版本、系统语言等等","date":"2020-10-23T07:02:44.000Z","path":"2020/10/23/Android-获取手机设备信息：名称、型号、系统版本号、厂商、设备制造商、SDK版本、系统语言等等/","text":"常用的设备信息获取方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 设备名称 * * @return 设备名称 */ public static String getDeviceName() &#123; return android.os.Build.DEVICE; &#125;/** * 设备型号 * * @return 设备型号 */ public static String getModelName() &#123; return android.os.Build.MODEL; &#125; /** * 获取当前手机系统版本号 * * @return 系统版本号 */ public static String getSystemVersion() &#123; return android.os.Build.VERSION.RELEASE; &#125; /** * 获取厂商 * * @return 厂商 */ public static String getBrand() &#123; return android.os.Build.BRAND; &#125; /** * 获取设备制造商 * * @return 制造商 */ public static String getManufacturer() &#123; return android.os.Build.MANUFACTURER; &#125;/** * SDK 版本 * @return */ public static String getSDKVersion() &#123; SDKVersion = android.os.Build.VERSION.SDK ; return SDKVersion; &#125; /** * 获取当前手机系统语言。 * * @return 返回当前系统语言。例如：当前设置的是“中文-中国”，则返回“zh-CN” */ public static String getSystemLanguage() &#123; return Locale.getDefault().getLanguage(); &#125; /** * 获取当前系统上的语言列表(Locale列表) * * @return 语言列表 */ public static Locale[] getSystemLanguageList() &#123; return Locale.getAvailableLocales(); &#125;","tags":[]},{"title":"Android 获取应用「唯一标识符」——DeviceID「兼容android 10（Q）」","date":"2020-10-23T07:01:57.000Z","path":"2020/10/23/Android-获取应用「唯一标识符」——DeviceID「兼容android-10（Q）」/","text":"前言 更多方法请参考官方文档 一、Android Q 之前 1、所需权限需动态申请权限 1&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; 2、获取方法获取设备Id，IMEI等 123TelephonyManager telManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);telManager.getDeviceId();telManager.getImei(); 但是这个方法在Android Q之后就不生效了。 二、Android Q之后下面是我们项目使用的一种方法，当然网上还有其它很多种兼容方式可以参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static String getDeviceId(Context context) &#123; final int targetSdkVersion = context.getApplicationInfo().targetSdkVersion; if (targetSdkVersion &gt; Build.VERSION_CODES.P &amp;&amp; Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.P) &#123; return getUniqueID(context); &#125; else &#123; return getTelId(context); &#125;&#125; private static String getTelId(Context context) &#123; final TelephonyManager manager = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE); return manager.getDeviceId();&#125; private static String getUniqueID(Context context) &#123; String id = null; final String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID); if (!TextUtils.isEmpty(androidId) &amp;&amp; !&quot;9774d56d682e549c&quot;.equals(androidId)) &#123; try &#123; UUID uuid = UUID.nameUUIDFromBytes(androidId.getBytes(&quot;utf8&quot;)); id = uuid.toString(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; if (TextUtils.isEmpty(id)) &#123; id = getUUID(); &#125; return TextUtils.isEmpty(id) ? UUID.randomUUID().toString() : id;&#125; private static String getUUID() &#123; String serial = null; String m_szDevIDShort = &quot;35&quot; + Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + ((null != Build.CPU_ABI) ? Build.CPU_ABI.length() : 0) % 10 + Build.DEVICE.length() % 10 + Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 + Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 + Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 + Build.TAGS.length() % 10 + Build.TYPE.length() % 10 + Build.USER.length() % 10; //13 位 if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.P) &#123; try &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; serial = android.os.Build.getSerial(); &#125; else &#123; serial = Build.SERIAL; &#125; //API&gt;=9 使用serial号 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString(); &#125; catch (Exception exception) &#123; serial = &quot;serial&quot;; // 随便一个初始化 &#125; &#125; else &#123; serial = android.os.Build.UNKNOWN; // 随便一个初始化 &#125; //使用硬件信息拼凑出来的15位号码 return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();&#125;","tags":[]},{"title":"Android Glide集成及使用注意事项——Glide 4.x","date":"2020-10-23T06:48:54.000Z","path":"2020/10/23/Android-Glide集成及使用注意事项——Glide-4-x/","text":"Glide 4.x集成及使用注意事项前言 原文请到lmz14大神参考使用更多用法请到官方指南参考使用 一、集成 1、project gradle 123repositories &#123; mavenLocal()&#125; 2、app gradle 123compile &#x27;com.android.support:support-v4:25.3.1&#x27;compile &#x27;com.github.bumptech.glide:glide:4.0.0&#x27;annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.0.0&#x27; 3、混淆 123456789101112131415#glide4.0-keep public class * implements com.bumptech.glide.module.GlideModule-keep public class * extends com.bumptech.glide.AppGlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# for DexGuard only-keepresourcexmlelements manifest/application/meta-data@value=GlideModule# 从glide4.0开始，GifDrawable没有提供getDecoder()方法，# 需要通过反射获取gifDecoder字段值，所以需要保持GifFrameLoader和GifState类不被混淆-keep class com.bumptech.glide.load.resource.gif.GifDrawable$GifState&#123;*;&#125;-keep class com.bumptech.glide.load.resource.gif.GifFrameLoader &#123;*;&#125; 4、在4.0中不用像3.X需要在AndroidManifest.xml配置GlideModule，而是通过注解继承AppGlideModule的子类来配置。 12345678910111213141516171819202122@GlideModulepublic class GlideConfiguration extends AppGlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; //自定义缓存目录，磁盘缓存给150M 另外一种设置缓存方式 builder.setDiskCache(new InternalCacheDiskCacheFactory(context, &quot;GlideImgCache&quot;, 150 * 1024 * 1024)); //配置图片缓存格式 默认格式为8888 builder.setDefaultRequestOptions(RequestOptions.formatOf(DecodeFormat.PREFER_ARGB_8888)); ViewTarget.setTagId(R.id.glide_tag_id); &#125; /** * 禁止解析Manifest文件 * 主要针对V3升级到v4的用户，可以提升初始化速度，避免一些潜在错误 * @return */ @Override public boolean isManifestParsingEnabled() &#123; return false; &#125;&#125; 二、使用 1、基本用法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123Glide.with(context) .load(myUrl) .into(imageView); 取消加载同样很简单： 1Glide.with(context).clear(imageView); 尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。 2、加载圆形图 1234Glide.with(this) .load(R.mipmap.ic_splash_bg) .apply(bitmapTransform(new CropCircleTransformation())) .into(mImageHead); 3、模糊过滤 12345Glide.with(this) .load(R.mipmap.ic_splash_bg) .apply(bitmapTransform(new BlurTransformation( 25, 4))) .into(mImageView); 4、在 Application 模块中的使用在 Application 模块中，可创建一个添加有 @GlideModule 注解，继承自 AppGlideModule 的类。此类可生成出一个流式 API，内联了多种选项，和集成库中自定义的选项： 1234567package com.example.myapp;import com.bumptech.glide.annotation.GlideModule;import com.bumptech.glide.module.AppGlideModule;@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123;&#125; 生成的 API 默认名为 GlideApp ，与 AppGlideModule 的子类包名相同。在 Application 模块中将 Glide.with() 替换为 GlideApp.with()，即可使用该 API 去完成加载工作。 12345GlideApp.with(context) .load(myUrl) .placeholder(placeholder) .fitCenter() .into(imageView); 三、注意事项 1、使用GlideApp代替Glide，asBitmap、asGif、asDrawable、asFile都要放到load之前（glide3.7.0都是要在load之后调用）。 1234567public static void loadImg(Context context,String url, ImageView imageView)&#123; GlideApp.with(context) .asBitmap() .load(url) .placeholder(R.drawable.placeholder) //设置资源加载过程中的占位符 .into(imageView); &#125; 2、占位符.placeholder(R.drawable.placeholder)不能用.9图，占位图片和加载的目标图片会同时显示，只是目标图片会先显示缩略图，然后显示正常。 3、加载gif图时，若调用dontAnimate()移除所有动画，gif就会加载失败。 4、设置淡入淡出动画glide3.7.0 1234567Glide.with(context) .load(url) .crossFade(100) //系统渐变动画 .placeholder(R.drawable.placeholder) .fallback(R.drawable.fallback) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView); glide4.0 1234567GlideApp.with(context) .load(url) .transition(DrawableTransitionOptions.withCrossFade(100))//淡入淡出100m .placeholder(R.drawable.placeholder) .fallback(R.drawable.fallback) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView); 5、磁盘缓存策略glide3.7.0 DiskCacheStrategy 的枚举意义：DiskCacheStrategy.NONE 什么都不缓存DiskCacheStrategy.SOURCE 只缓存全尺寸图DiskCacheStrategy.RESULT 只缓存最终的加载图DiskCacheStrategy.ALL 缓存所有版本图（默认行为） glide4.0 //DiskCacheStrategy.ALL 既缓存原始图片，也缓存转换过后的图片。// DiskCacheStrategy.NONE 不缓存任何内容// DiskCacheStrategy.DATA 在资源解码前就将原始数据写入磁盘缓存（即只缓存原始图片）// DiskCacheStrategy.RESOURCE 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源（即只缓存转换过后的图片）。// DiskCacheStrategy.AUTOMATIC 让Glide根据图片资源智能地选择使用哪一种缓存策略。//（默认采用）DiskCacheStrategy.AUTOMATIC策略/——————————————————————————-///源码 RequestOptions.javaprivate DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC; 6、占位符、错误图片设置glide4.0 若into中设置的是target，占位符（placeholder、error）需要在回调中再次设置，否则无效。 1234567891011121314151617181920212223242526272829303132public static void loadImg(String url, ImageView imageView) &#123; //into中用Target，占位符（placeholder、error）需要在回调中设置 GlideApp.with(FanhuanApplication.getInstance().getApplication()) .asBitmap() .load(url) .placeholder(drawbleId) //设置资源加载过程中的占位符 .fallback(drawbleId) .error(drawbleId) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(new SimpleTarget&lt;Bitmap&gt;() &#123; @Override public void onResourceReady(Bitmap resource, Transition&lt;? super Bitmap&gt; transition) &#123; imageView.setImageBitmap(resource); &#125; @Override public void onLoadFailed(@Nullable Drawable errorDrawable) &#123; super.onLoadFailed(errorDrawable); if(errorDrawable!=null)&#123; imageView.setImageDrawable(errorDrawable); &#125; &#125; @Override public void onLoadStarted(@Nullable Drawable placeholder) &#123; super.onLoadStarted(placeholder); if(placeholder!=null)&#123; imageView.setImageDrawable(placeholder); &#125; &#125; &#125;); &#125;","tags":[]},{"title":"Android Glide集成及使用注意事项——Glide 3.x","date":"2020-10-23T06:48:08.000Z","path":"2020/10/23/Android-Glide集成及使用注意事项——Glide-3-x/","text":"Glide 3.x集成及使用注意事项前言 更多用法请参考官方指南了解使用。 一、集成 1、project gradle 123repositories &#123; mavenCentral() &#125; 2、app gradle 12//glide implementation &#x27;com.github.bumptech.glide:glide:3.8.0&#x27; 3、混淆 123456#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125; 二、使用及注意事项 1、基本方法多数情况下，使用Glide加载图片非常简单，一行代码足矣： 123456String url = &quot;http://www.technosamrat.com/wp-content/uploads/2012/02/Ocean-Wallpapers-Images1.jpg&quot;;ImageView imageView = (ImageView) findViewById(R.id.imageView);Glide.with(context) .load(url) .into(imageView); 取消加载同样很简单： 1Glide.with(context).clear(imageView); 尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。 2、占位图设置Glide 也为我们提供这种方法 placeholder() 和 error() 12345Glide.with(context) .load(url) .placeholder(R.drawable.place_image)//图片加载出来前，显示的图片 .error(R.drawable.error_image)//图片加载失败后，显示的图片 .into(imageView); 3、缩略图Glide 的缩略图功能和占位图略有不同，占位图必须使用资源文件才行，而缩略图是动态的占位图可以从网络中加载。缩略图会在世纪请求加载完成或者处理完之后才显示。在原始图片到达之后，缩略图不会取代原始图片，只会被抹除。 Glide 为缩略图提供了2种不同的加载方式，比较简单的方式是调用 thumbnail() 方法，参数是 float 类型，作为其倍数大小。例如，你传入 0.2f 作为参数，Glide 将会显示原始图片的20%的大小，如果原图是 1000x1000 的尺寸，那么缩略图将会是 200x200 的尺寸。为缩略图明显比原图小得多，所以我们需要确保 ImageView 的 ScaleType 设置的正确。 1234Glide.with( context ) .load( url ) .thumbnail( 0.2f ) .into( imageView ); 与上面这种方式不同的是，这里的第一个缩略图请求是完全独立于第二个原始请求的。该缩略图可以是不同的资源图片，同时也可以对缩略图做不同的转换等等 123456789private void loadImageThumbnailRequest()&#123; // setup Glide request without the into() method DrawableRequestBuilder&lt;String&gt; thumbnailRequest = Glide.with( context ).load( url ); // pass the request as a a parameter to the thumbnail request Glide.with( context ) .load( url ) .thumbnail( thumbnailRequest ) .into( imageView );&#125; 4、动画开关动画效果可以让图片加载变得更加的平滑，crossFade() 方法强制开启 Glide 默认的图片淡出淡入动画，当前版本3.7.0是默认开启的。crossFade() 还有一个重载方法 crossFade(int duration)。可以控制动画的持续时间，单位ms。动画默认的持续时间是300ms。既然可以添加动画，那肯定就可以设置没有任何淡出淡入效果，调用 dontAnimate() 123456Glide.with(context) .load(url) .crossFade()//或者使用 dontAnimate() 关闭动画 .placeholder(R.drawable.place_image) .error(R.drawable.error_image) .into(imageView); 5、图片大小与裁剪使用 override(width,height) 方法，在图片显示到 ImageView 之前，重新改变图片大小。 1234Glide.with(context) .load(url) .override(width,height)//这里的单位是px .into(imageView); 6、图片的缓存处理为了更快的加载图片，Glide默认帮我们开启了内存缓存和磁盘缓存。（1）内存缓存 内存缓存是 Glide 默认开启的，可以调用 skipMemoryCache(true) 告诉 Glide 跳过内存缓存。 （2）磁盘缓存 磁盘缓存是 Glide 默认开启的，可以调用 .diskCacheStrategy( DiskCacheStrategy.NONE )告诉 Glide 跳过磁盘缓存。 例子如下： 12345Glide.with(context) .load(url) .skipMemoryCache(true) .diskCacheStrategy( DiskCacheStrategy.NONE ) .into(imageView); （3）自定义磁盘缓存 DiskCacheStrategy 的枚举意义：DiskCacheStrategy.NONE 什么都不缓存DiskCacheStrategy.SOURCE 只缓存全尺寸图DiskCacheStrategy.RESULT 只缓存最终的加载图DiskCacheStrategy.ALL 缓存所有版本图（默认行为） 例子如下： 1234Glide.with(context) .load(url) .diskCacheStrategy( DiskCacheStrategy.SOURCE ) .into(imageView); 7、显示 Gif 和 Video显示 GIf 对于 Glide 来说一个比较特别的功能（ Picasso 暂时还不行）而且使用起来非常简单。 12345Glide.with( context ) .load( gifUrl ) .placeholder（ R.drawable.default ） .error( R.drawable.error ) .into( imageView ); 这段代码还有点问题，如果加载的不是一张 gif 图的话，是没有办法显示的。 12345Glide.with( context ) .load( gifUrl ) .asGif() .error( R.drawable.error ) .into( imageView ); 做以上修改，如果图片类型不是 Gif 图的话就会当作 load 失败来处理，因此 error() 会被回调。即使这个url的图片是好的，也是不会显示的。当然，如果你想显示 Gif 但只是向现实静态的图片你就可以这么做 12345Glide.with( context ) .load( gifUrl ) .asBitmap() .error( R.drawable.error ) .into( imageView ); 仅仅是显示 Gif 的第一帧图像，这样就可以保证图片的正常显示了。 最后的小惊喜，Glide 还能显示视频，但是只能够显示手机本地的视频，要是向现实网络上的视频的话，还是另寻他法吧！ 1234String filePath = &quot;/storrage/emulated/0/Pictures/video.mp4&quot;;Glide.with( context ) .load( Uri.fromFile( new File( filePath ) ) ) .into( imageView ); 以上就是Glide的基本用法了。","tags":[]},{"title":"代码对比工具「for Mac」","date":"2020-10-23T06:46:35.000Z","path":"2020/10/23/代码对比工具「for-Mac」/","text":"代码对比工具 链接: https://pan.baidu.com/s/1rFeRV_r4FJhhJpeN5X0ojw密码: vgnp","tags":[]},{"title":"Android dialog属性——点击「屏幕」或者「返回键」不消失","date":"2020-10-23T06:41:10.000Z","path":"2020/10/23/Android-dialog属性——点击「屏幕」或者「返回键」不消失/","text":"Dialog属性设置 在dialog.show();之前加： 12dialog.setCanceledOnTouchOutside(false);//点击屏幕 dialog不消失dialog.setCancelable(false);//点击屏幕或返回按钮 dialog不消失 屏蔽返回键,按返回键时不销毁当前activity 重写onKeyDown方法 1234567@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; return false;//返回false进行拦截点击事件 &#125; return super.onKeyDown(keyCode, event);&#125;","tags":[]},{"title":"Android productFlavors的用法之——gradle 配置productFlavors &子模块配置productFlavors","date":"2020-10-23T06:34:24.000Z","path":"2020/10/23/Android-productFlavors的用法之——gradle-配置productFlavors-子模块配置productFlavors/","text":"前言 1234561、什么时候用到在子模块配置productFlavors 当子模块需要「配置不同信息」时，可以使用。 比如： （1）子模块在不同开发环境（uat、sit）使用不同的请求地址url，可以配置productFlavors用来区分调用即可； （2）当使用模块化开发时，可以专门抽出一个子模块配置productFlavors，这样其他模块只需要依赖该子模块，就可以全局使用子模块的配置信息；2、备注：「子模块配置样式」与「主模块配置样式」应保持一致； 配置1、主模块配置productFlavors app/build.gradle 123456789101112131415161718192021android &#123; ... flavorDimensions &#x27;default&#x27; // 定义必要的配置 否则会报错 productFlavors &#123; dev &#123; dimension = &#x27;default&#x27; // 定义不同的包名 applicationId = &quot;com.test.demo1&quot; // 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;APPID_BUGLY&quot;, &#x27;&quot;12345&quot;&#x27; &#125; sit &#123; dimension = &#x27;default&#x27; applicationId = &quot;com.test.demo2&quot; buildConfigField &quot;String&quot;, &quot;APPID_BUGLY&quot;, &#x27;&quot;67890&quot;&#x27; &#125; &#125;&#125; 2、子模块配置productFlavors module/build.gradle 1234567891011121314151617181920android &#123;... publishNonDefault true flavorDimensions &#x27;default&#x27; productFlavors &#123; dev &#123; dimension = &#x27;default&#x27; // 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://158.223.12.22:8080&quot;&#x27; buildConfigField &quot;String&quot;, &quot;RESOURCE_URL&quot;, &#x27;&quot;http://158.223.12.22:8080&quot;&#x27; &#125; sit &#123; dimension = &#x27;default&#x27; // 自定义buildConfig.java中的变量供代码中使用 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://158.223.12.11:9090&quot;&#x27; buildConfigField &quot;String&quot;, &quot;RESOURCE_URL&quot;, &#x27;&quot;http://158.223.12.11:9090&quot;&#x27; &#125; &#125;&#125; 只需要其他模块依赖该子模块，就可以全局使用该子模块的配置信息。所以可以抽出一个「公共子模块」专门用来做「配置信息」使用。","tags":[]},{"title":"Android时间获取之——Date、String、Long三种日期类型之间的相互转换","date":"2020-10-23T06:32:02.000Z","path":"2020/10/23/Android时间获取之——Date、String、Long三种日期类型之间的相互转换/","text":"date类型转换为String类型 12345// formatType 格式为yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒//或者自定义格式 // data Date类型的时间 public static String dateToString(Date data, String formatType) &#123; return new SimpleDateFormat(formatType).format(data); &#125; string类型转换为date类型 注：strTime的时间格式必须要与formatType的时间格式相同 12345678910// strTime 要转换的string类型的时间，// formatType 要转换的格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日HH时mm分ss秒， // strTime的时间格式必须要与formatType的时间格式相同 public static Date stringToDate(String strTime, String formatType) throws ParseException &#123; SimpleDateFormat formatter = new SimpleDateFormat(formatType); Date date = null; date = formatter.parse(strTime); return date; &#125; long转换为Date类型 12345678910// currentTime 要转换的long类型的时间 // formatType 要转换的时间格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒 public static Date longToDate(long currentTime, String formatType) throws ParseException &#123; Date dateOld = new Date(currentTime); // 根据long类型的毫秒数生命一个date类型的时间 String sDateTime = dateToString(dateOld, formatType); // 把date类型的时间转换为string Date date = stringToDate(sDateTime, formatType); // 把String类型转换为Date类型 return date; &#125; date类型转换为long类型 1234// date 要转换的date类型的时间 public static long dateToLong(Date date) &#123; return date.getTime(); &#125; long类型转换为String类型 12345678// currentTime 要转换的long类型的时间 // formatType 要转换的string类型的时间格式 public static String longToString(long currentTime, String formatType) throws ParseException &#123; Date date = longToDate(currentTime, formatType); // long类型转成Date类型 String strTime = dateToString(date, formatType); // date类型转成String return strTime; &#125; String类型转换为long类型注：strTime的时间格式和formatType的时间格式必须相同 12345678910111213// strTime 要转换的String类型的时间 // formatType 时间格式 // strTime的时间格式和formatType的时间格式必须相同 public static long stringToLong(String strTime, String formatType) throws ParseException &#123; Date date = stringToDate(strTime, formatType); // String类型转成date类型 if (date == null) &#123; return 0; &#125; else &#123; long currentTime = dateToLong(date); // date类型转成long类型 return currentTime; &#125; &#125;","tags":[]},{"title":"Android项目多渠道打包之——productFlavors的用法","date":"2020-10-23T06:16:25.000Z","path":"2020/10/23/Android项目多渠道打包之——productFlavors的用法/","text":"productFlavors的用处 创建不同的产品并为不同产品分配专有属性 配置不同的环境并为不同环境配置专有信息（sit、uat、pro…） 一、创建不同的「产品风味」，并为不同产品分配「专有属性」 在app:级别下的gradle文件中，加入productFlavors,并在productFlavors下创建产品A与B 12345678910111213141516171819202122232425262728293031productFlavors &#123; //新建产品A A &#123; //程序包名 applicationId &quot;com.wmj.a&quot; //不同渠道号 manifestPlaceholders = [UMC:&quot;product-Complete&quot;] //versionName versionName &quot;1.0.0&quot; //versionCode versionCode 1 // 自定义buildConfig.java中的变量供代码中使用 buildConfigField(&quot;String&quot;, &quot;APPID&quot;, &quot;\\&quot;111111\\&quot;&quot;) buildConfigField(&quot;int&quot;, &quot;TYPE&quot;, &quot;1&quot;) &#125; //新建产品B B &#123; //程序包名 applicationId &quot;com.wmj.b&quot; //不同渠道号 manifestPlaceholders = [UMC:&quot;product-Temp&quot;] //versionName versionName &quot;2.1.1&quot; //versionCode versionCode 2 // 自定义buildConfig.java中的变量供代码中使用 buildConfigField (&quot;String&quot;, &quot;APPID&quot;, &quot;\\&quot;222222\\&quot;&quot;) buildConfigField(&quot;int&quot;, &quot;TYPE&quot;, &quot;2&quot;) &#125; 这样，就可以区分A和B两个不同的产品了。A和B分别有自己不同的包名、渠道号、版本号等属性；当然，如果你想区分他们的其他属性比如不同的应用名、应用图标icon、引用不同代码资源、图片资源等等也是可以的；先在src目录下简历对应的文件夹，比如java代码则建立，product/java,res文件夹则建立product/res 二、配置不同的「开发环境」，并为不同环境配置「专有信息」有时候我们开发一个产品，需要经过开发环境、测试环境、生产环境等不同环境的测试才能正式发布；而不同的环境可能有不同的服务请求地址、不同的资源地址等等，这时候productFlavors就可以大显身手了。 123456789101112131415161718flavorDimensions &#x27;default&#x27; productFlavors &#123; sit &#123; dimension = &#x27;default&#x27; //自定义变量，如：配置sit环境的请求地址，不同环境的请求地址各不相同 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://123.123.123:8080&quot;&#x27; &#125; uat &#123; dimension = &#x27;default&#x27; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://124.124.124:8081&quot;&#x27; &#125; pro &#123; dimension = &#x27;default&#x27; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://125.125.125:8083&quot;&#x27; &#125; &#125; 如上，配置了sit、uat、pro三个不同的环境，分别配有不同的服务请求地址，这样就不用每次打不同环境的apk时手动去修改配置文件了。 当然，上面两种使用方式也可以配合一起使用啊！就可以组合出不同产品在不同环境的apk了。 1234567891011121314151617181920212223242526272829303132flavorDimensions(&quot;name&quot;, &quot;build&quot;) productFlavors &#123; //产品A A &#123; dimension &quot;name&quot; &#125; //产品B B &#123; dimension &quot;name&quot; &#125; //sit环境配置 sit &#123; dimension = &#x27;build&#x27; //自定义变量，如：配置sit环境的请求地址，不同环境的请求地址各不相同 buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://123.123.123:8080&quot;&#x27; &#125; //uat环境配置 uat &#123; dimension = &#x27;build&#x27; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://124.124.124:8081&quot;&#x27; &#125; //pro环境配置 pro &#123; dimension = &#x27;build&#x27; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &#x27;&quot;http://125.125.125:8083&quot;&#x27; &#125; &#125; 构建变体：[A, B] [sit, uat, pro] [Debug, Release] 到时这样组合就可以构建12个变体了。","tags":[]},{"title":"Android代码混淆之——依赖库Library中混淆配置方法","date":"2020-10-23T06:15:34.000Z","path":"2020/10/23/Android代码混淆之——依赖库Library中混淆配置方法/","text":"应用场景 我们自己新建一个Library给主工程引用； 引入三方Library给项目主工程引用； 这种情况下，一般我们需要对Library中的代码配置一些混淆规则，以免打混淆包某些方法不生效而无法使用。 一、在app模块写混淆规则（不建议使用）这种形式比较简单无脑，全部的混淆规则都写在了app模块里面，如果app模块依赖很多个Library模块那么app模块中的混淆规则将会非常的庞大，不利于代码的维护。 使用app模块编写所有混淆命令是基于Library模块当中不再编写混淆命令为前提。也就是Library模块中minifyEnabled都是false，如果强行将Library模块的minifyEnabled设置为true，那么程序将很大概率会崩溃掉，因为Library模块开启minifyEnabled后，app模块的混淆规则将无法作用到Library模块上，导致Library模块不该混淆的代码被混淆从而导致崩溃。 Library模块中minifyEnabled设置为false就会保证app模块的混淆规则作用到Library模块上，这也是Library模块中minifyEnabled设置为true还是false对组件化开发影响比较大的一个地方。 二、在各自Library模块写混淆规则（推荐做法）这是组件化/模块化开发最推荐的做法，最大的优点就是不用在app模块写上大量的混淆规则，只需要在相应模块写各自的混淆，方便混淆的维护。 在各自模块中配置混淆方法如下： 方式一：精简模式 123release &#123; consumerProguardFiles &#x27;proguard-rules.pro&#x27; &#125; 只需要配置一行代码即可，proguard-rules.pro就是该模块特定的混淆规则，使用这种配置最大的一个好处就是Library模块的是否混淆完全由app模块来决定；这种配置有一个非常重要的关键点：就是不能设置minifyEnabled true，因为设置为true之后，Library模块是否混淆的控制权将只能由该模块自身决定，app模块将无法控制Library模块的混淆与否。 方式二：常用模式第一步：开启混淆开关 123456buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; 第二步：配置gradle 12345678910defaultConfig &#123; minSdkVersion 22 targetSdkVersion 28 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; // 配置此参数，方可生成混淆文件 consumerProguardFiles &quot;consumer-rules.pro&quot; &#125; 在这里插入图片描述在这里插入图片描述 细心的朋友可以发现，第1步开启混淆开关配置的是proguard-rules.pro文件，而第2步配置的consumer-rules.pro文件；同时在我们Library目录下这两个混淆文件都存在。那这两文件又有什么区别呢？proguard-rules.pro文件是给Library模块自己使用的混淆规则；consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则； 而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。","tags":[]},{"title":"Windows 10 自带输入法微软拼音「简体」「繁体」切换快捷键","date":"2020-10-23T06:14:21.000Z","path":"2020/10/23/Windows-10-自带输入法微软拼音「简体」「繁体」切换快捷键/","text":"快捷键：Ctrl + Shift + F 经常无缘无故的不知道点击了什么导致输入法变成繁体，关键是不太记事每次都要查询一番，还是记下来吧。","tags":[]},{"title":"Android Studio常用快捷键(Mac)","date":"2020-10-23T06:13:39.000Z","path":"2020/10/23/Android-Studio常用快捷键-Mac/","text":"搜索查看类 在这里插入图片描述编辑类编辑在这里插入图片描述生成在这里插入图片描述自动补全在这里插入图片描述重构在这里插入图片描述 选择, 移动在这里插入图片描述 格式化在这里插入图片描述 注释在这里插入图片描述 运行调试类在这里插入图片描述 测试类在这里插入图片描述 版本控制类在这里插入图片描述 窗口类在这里插入图片描述","tags":[]},{"title":"手机Web前端调试页面之——设置debug开关方式","date":"2020-10-23T06:13:00.000Z","path":"2020/10/23/手机Web前端调试页面之——设置debug开关方式/","text":"条件：android4.4+ 配置在APP中启用 WebView 调试，开启调试后，Chrome DevTools才能对WebView进行远程调试 1WebView.setWebContentsDebuggingEnabled(true); 使用场景1.测试包如果团队中有Android开发人员能够提供测试包，只要在测试包中开启Webview的debug模式就可以了。 2.线上包对于线上的APP，一般debug开关都是关闭的，这就需要借助第三方工具，才能将debug开关打开，这个工具就是Xposed和WebviewDebugHook。 Xposed是一个框架，能够集成很多功能模块，这些模块能够在不修改APK的情况下，修改APP的运行方式。这里我们就需要WebviewDebugHook模块来开启APP的WebView debug模式。下面主要介绍一下安装的步骤： （1）获取手机的root权限，这个推荐使用KingRoot，可能一次获取root权限会失败，建议失败后多试几次； 在这里插入图片描述 （2）下载适合版本的Xposed和WebviewDebugHook，并安装。 目前Xposed的官网上给出的链接是这样的： Android5.0+：https://forum.xda-developers.com/attachment.php 而WebviewDebugHook的安装文件是git项目https://github.com/feix760/WebViewDebugHook源码中的WebViewDebugHook.apk。 （3）激活Xposed和WebViewDebugHook模块 下图是Android5.0+下的截图，通过点击【安装/更新】激活Xposed，并切换菜单到模块功能，然后勾选上WebViewDebugHook。 在这里插入图片描述在这里插入图片描述 安装完毕后，接下来就可以开开心心的调试Webview了。 另外还有两个小Tips： （1）访问chrome://inspect/#devices如果chrome没有检测到Remote Target中的页面，可能需要安装一下chrome的ADB插件； （2）对于腾讯系的APP，默认采用X5内核，需要将WebViewDebugHook的git目录下的debug.conf文件拷贝到SD卡的根目录下即可。","tags":[]},{"title":"Android Studio 清理缓存clean project与invalidate caches——解决项目一片报红，但是可以正常编译","date":"2020-10-23T06:12:10.000Z","path":"2020/10/23/Android-Studio-清理缓存clean-project与invalidate-caches——解决项目一片报红，但是可以正常编译/","text":"报错现象： Android studio 打开项目有时找不到R文件、 导入的资源、布局 、 jar包等等资源； Android studio打开项目一片报红，但是项目可以正常build打包； 很有可能是studio 缓存造成的。 解决方案： 方法1： 工具栏 Build –&gt; lean project 在这里插入图片描述 方法2： 使用invalidate caches restart在这里插入图片描述在这里插入图片描述备注：如果使用方法1无效，可以试一下方法2。本人项目就是使用方1无效，使用方法2有效解决问题。","tags":[]},{"title":"Android R(11) app targetSdkVersion30遇到的那些坑之——相册选择图片黑屏现象","date":"2020-10-23T06:11:03.000Z","path":"2020/10/23/Android-R-11-app-targetSdkVersion30遇到的那些坑之——相册选择图片黑屏现象/","text":"问题：当开发版本targetSdkVersion提升到30时： 在android10手机上安装app后，调用相册选择图片时，相册会出现图片全部都是黑屏现象，选择后的图片也是黑屏图片，而且无法获取图片的小大； 在android10以下的手机安装app，可以正常选择图片； 解决： 把targetSdkVersion降到28，在android10手机上则可以正常选择相册的图片。目前（2020.08.03）没有找到targetSdkVersion30的适配方法，如有大神有解决方法，望请告知，不甚感激。 备注： 当项目targetSdkVersion为28时，在android10手机安装了app；然后将项目targetSdkVersion升级到30，再在android10手机覆盖安装此app，则相册是可以正常选择图片的。 当项目targetSdkVersion直接为30，Android10手机之前并未在targetSdkVersion低版本安装过此app，直接在targetSdkVersion30第一次安装此app，则调用相册会出现黑屏现象。","tags":[]},{"title":"手机Web前端调试页面之——Chrome DevTools（谷歌浏览器）的模拟手机调试","date":"2020-10-23T06:10:15.000Z","path":"2020/10/23/手机Web前端调试页面之——Chrome-DevTools（谷歌浏览器）的模拟手机调试/","text":"Chrome DevTools（谷歌浏览器）的模拟手机调试前言 在客户端开发中，由于使用手机app加载webview页面，客户端与前端经常会出现数据交互情况；但是在手机中无法调试看到前端代码的步骤流程，有时候会导致数据交互失败查找问题比较麻烦；因此可以引入Chrome DevTools（谷歌浏览器）的模拟手机调试。 Chrome DevTools（谷歌浏览器）的模拟手机调试 Chrome DevTools远程调试Android和iOS页面 阅读 1. Chrome DevTools模拟手机调试 直接使用谷歌浏览器的开发者工具，可以参照下图，也可以使用快捷键F12或者ctrl+shift+I；个人觉得不管是哪个浏览器，直接先按下F12，一般都可以打开开发者工具，打不开再说嘛。 这种调试方式不仅能用于模拟手机调试还是主要的PC端页面调试的方式，这里主要说用于手机调试。 在这里插入图片描述 打开后看到类似如下界面的开发者调试界面，Elements可以查看文档元素，Console可以在线调试js和查看输出结果，Sources可以调试JS和查看依赖资源，Network查看所有的网络请求 在这里插入图片描述 在浏览器地址栏输入要调试的页面地址，选择模拟设备，然后就可以选择要调试的js调试了，右侧面板中有调试操作按钮；在Application面板中可以看到应用存储的数据Cookies什么的 在这里插入图片描述 如果没有需要模拟的机型怎么办？当然是增加了，打开DevTools的设置面板，左图中的Setting点开会出现右图，如下： 在这里插入图片描述在这里插入图片描述 2. Chrome DevTools远程调试Android和iOS页面 电脑上安装新版谷歌浏览器，然后地址栏输入chrome://inspect会打开设备监视页面，这里可以监视到iOS和Android设备，如果界面和图中不一致请安装最新版浏览器在这里插入图片描述Android: 前提： 1、手机和电脑使用usb连接，手机要开启usb调试模式(不同手机不一样) 2、手机上安装最新版谷歌浏览器并打开 会发现设备监视页面多出了一个华为设备，并且能看到当前手机上谷歌浏览器打开的网页的连接 a):可以在这里输入手机要打开的url然后open，手机上显示的当前页面就会改变 b):inspect表示开始调试当前页面，会打开调试面板(重要) c):focus tab，表示让手机显示当前这个连接 d):reload表示重新加载页面，也就是刷新 e):close表示关闭当前手机显示的页面在这里插入图片描述接下来，点击inspect开始调试页面，注意如果google浏览器不能翻|墙的话，这个调试页面是打不开的，可以百度修改hosts文件翻|墙在这里插入图片描述然后就可以像调试PC端网页一样远程调试手机网页了 iOS(window系统上，如果是macbook系统忽略此部分): 可以参考：http://www.cnblogs.com/kelsen/p/6402477.html 前提： 1、电脑安装iTunes软件，不然苹果手机不能正常被识别，安装好后数据线连接手机和电脑 2、打开手机的设置——&gt;Sarafi——&gt;高级——&gt;Web检查器——&gt;启用(默认是关闭的，将其打开) 3、下载ios-webkit-debug-prox代理(32位或者64位)，其作用就是在Chrome和Sarafi之间建立了一个代理，便于电脑的Chrome检测手机Sarafi打开的页面 4、在cmd中执行ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html，命令中-f是以谷歌内置的监视器来调试(默认使用远程的)在这里插入图片描述启动后会监听9222端口，然后看到连接上了一台名为jiba的iOS设备，括号中为设备的UDID；然后看谷歌浏览器是否检查了这个端口，右图中有9222端口即可，没有就手动添加在这里插入图片描述在这里插入图片描述此时打开手机Sarafi浏览器，打开百度首页，发现浏览器能检测到，没看到就刷新这个监视界面，一般来说会在3秒内自动出现在这里插入图片描述点击inspect同样出现了调试面板，如下，发现iOS调试的面板不能看到手机屏幕在电脑上的投影，不过这并不影响调试；但是可能会遇到在调试js时断点不生效的问题， 如果很不幸遇到这个问题的话，将图中红框中的按钮连续点击两次——先禁用断点再启动即可恢复端点调试功能，不知道为什么，猜测是这个过程中恢复了断点的状态；这个问题很奇葩。在这里插入图片描述到这里使用Chrome调试iOS和Android就都完了，这种使用谷歌浏览器的方式，在Android上依赖于手机谷歌浏览器，在iOS上依赖Sarafi浏览器，受到具体软件的限制；不过可以理解，毕竟远程调试不如模拟调试简单 转载来源： 手机Web前端调试页面","tags":[]},{"title":"AndroidQ(10)分区存储完美适配","date":"2020-10-23T06:05:43.000Z","path":"2020/10/23/AndroidQ-10-分区存储完美适配/","text":"前言 Android Q文件存储机制修改成了沙盒模式 APP只能访问自己目录下的文件和公共媒体文件 对于AndroidQ以下，还是使用老的文件存储方式 背景 存储权限Android Q仍然使用READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE作为存储相关运行时权限，但现在即使获取了这些权限，访问外部存储也受到了限制，只能访问自身目录下的文件和公共内体文件。 外部存储结构划分1、公有目录：Downloads、Documents、Pictures 、DCIM、Movies、Music、Ringtones等地址：/storage/emulated/0/Downloads(Pictures)等公有目录下的文件不会跟随APP卸载而删除。2、APP私有目录地址：/storage/emulated/0/Android/data/包名/files私有目录存放app的私有文件，会随着App的卸载而删除。 适配方案 AndroidQ中使用ContentResolver进行文件的增删改查 1、获取(创建)自身目录下的文件夹获取及创建，如果手机中没有对应的文件夹，则系统会自动生成 123 //在自身目录下创建apk文件夹File apkFile = context.getExternalFilesDir(&quot;apk&quot;); 2、创建自身目录下的文件生成需要下载的路径，通过输入输出流读取写入 12345678910111213141516171819String apkFilePath = context.getExternalFilesDir(&quot;apk&quot;).getAbsolutePath();File newFile = new File(apkFilePath + File.separator + &quot;temp.apk&quot;);OutputStream os = null;try &#123; os = new FileOutputStream(newFile); if (os != null) &#123; os.write(&quot;file is created&quot;.getBytes(StandardCharsets.UTF_8)); os.flush(); &#125;&#125; catch (IOException e) &#123;&#125; finally &#123; try &#123; if (os != null) &#123; os.close(); &#125; &#125; catch (IOException e1) &#123; &#125;&#125; 3、创建公共目录下的文件夹通过MediaStore.insert写入 123456789101112131415if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123; return null;&#125;ContentResolver resolver = context.getContentResolver();ContentValues values = new ContentValues();values.put(MediaStore.Downloads.DISPLAY_NAME, fileName);values.put(MediaStore.Downloads.DESCRIPTION, fileName);//设置文件类型values.put(MediaStore.Downloads.MIME_TYPE, &quot;application/vnd.android.package-archive&quot;);//注意MediaStore.Downloads.RELATIVE_PATH需要targetVersion=29,//故该方法只可在Android10的手机上执行values.put(MediaStore.Downloads.RELATIVE_PATH, &quot;Download&quot; + File.separator + &quot;apk&quot;);Uri external = MediaStore.Downloads.EXTERNAL_CONTENT_URI;Uri insertUri = resolver.insert(external, values);return insertUri; 4、公共目录下的指定文件夹下创建文件结合上面代码，我们主要是在公共目录下创建文件或文件夹拿到本地路径uri，不同的Uri，可以保存到不同的公共目录中。接下来使用输入输出流就可以写入文件 重点：AndroidQ中不支持file://类型访问文件，只能通过uri方式访问 123456789101112131415161718192021222324252627282930313233343536ContentResolver resolver = context.getContentResolver();Uri insertUri = resolver.insert(external, values);if(insertUri == null) &#123; return;&#125;String mFilePath = insertUri.toString();InputStream is = null;OutputStream os = null;try &#123; os = resolver.openOutputStream(insertUri); if(os == null)&#123; return; &#125; int read; File sourceFile = new File(sourcePath); if (sourceFile.exists()) &#123; // 文件存在时 is = new FileInputStream(sourceFile); // 读入原文件 byte[] buffer = new byte[1024]; while ((read = is.read(buffer)) != -1) &#123; os.write(buffer, 0, read); &#125; &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; try &#123; if (is != null) &#123; is.close(); &#125; if (os != null) &#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 5、通过MediaStore读取公共目录下的文件 1234567891011121314151617181920212223ParcelFileDescriptor parcelFileDescriptor = null;FileDescriptor fileDescriptor = null;Bitmap tagBitmap = null;try &#123; parcelFileDescriptor = context.getContentResolver().openFileDescriptor(uri, &quot;r&quot;); if (parcelFileDescriptor != null &amp;&amp; parcelFileDescriptor.getFileDescriptor() != null) &#123; fileDescriptor = parcelFileDescriptor.getFileDescriptor(); //转换uri为bitmap类型 tagBitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (parcelFileDescriptor != null) &#123; parcelFileDescriptor.close(); &#125; &#125; catch (IOException e) &#123; &#125;&#125; 6、使用MediaStore删除文件 1context.getContentResolver().delete(fileUri, null, null); 转载来自 会撒娇的犀犀利","tags":[]},{"title":"Java中try()catch{}的使用方法：自动资源释放","date":"2020-10-23T06:04:51.000Z","path":"2020/10/23/Java中try-catch-的使用方法：自动资源释放/","text":"今天撸代码的时候发现了一段这样的代码 12345678910try( Connection conn=DriverManager.getConnection(url,user,pass); Statement stmt=conn.createStatement() ) &#123; boolean hasResultSet=stmt.execute(sql); &#125; 和平常见的不一样，我们平常见的是这样的 123456789101112131415161718192021try&#123; fis=new FileInputStream(&quot;src\\\\com\\\\ggp\\\\first\\\\FileInputStreamDemo.java&quot;); byte[]bbuf=new byte[1024]; int hasRead=0; while((hasRead=fis.read(bbuf))&gt;0)&#123; System.out.println(new String(bbuf,0,hasRead)); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 如果{}中的代码块出现了异常，会被catch捕获，然后执行catch中的代码，接着执行finally中的码，其中catch中的代码有了异常才会被执行，finally中的代码无论有没有异常都会被执行， 而第一种情况的()中的代码一般放的是对资源的申请，如果{}中的代码出项了异常，（）中的资源就会被关闭，这在inputstream和outputstream的使用中会很方便例如 12345678910111213141516private static void customBufferStreamCopy(File source, File target) &#123; try (InputStream fis = new FileInputStream(source); OutputStream fos = new FileOutputStream(target))&#123; byte[] buf = new byte[8192]; int i; while ((i = fis.read(buf)) != -1) &#123; fos.write(buf, 0, i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 从网上查阅资料得知从 Java 7 build 105 版本开始，Java 7 的编译器和运行环境支持新的 try-with-resources 语句，称为 ARM 块(Automatic Resource Management) ，自动资源管理。 The try-with-resources statement is a try statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource. 带有resources的try语句声明一个或多个resources。resources是在程序结束后必须关闭的对象。try-with-resources语句确保在语句末尾关闭每个resources。任何实现java.lang.AutoCloseable,包括实现了java.io.Closeable的类，都可以作为resources使用。 自定义AutoClosable 实现 这个try-with-resources结构里不仅能够操作java内置的类。你也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。 AutoClosable 接口仅仅有一个方法，接口定义如下： 12345public interface AutoClosable &#123; public void close() throws Exception; &#125; 任何实现了这个接口的方法都可以在try-with-resources结构中使用。下面是一个简单的例子： 1234567891011public class MyAutoClosable implements AutoCloseable &#123; public void doIt() &#123; System.out.println(&quot;MyAutoClosable doing it!&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoClosable closed!&quot;); &#125;&#125; doIt()是方法不是AutoClosable 接口中的一部分，之所以实现这个方法是因为我们想要这个类除了关闭方法外还能做点其他事。 下面是MyAutoClosable 在try-with-resources结构中使用的例子： 12345678private static void myAutoClosable() throws Exception &#123; try(MyAutoClosable myAutoClosable = new MyAutoClosable())&#123; myAutoClosable.doIt(); &#125;&#125; 当方法myAutoClosable.doIt()被调用时，下面是打印到System.out的输出： 123MyAutoClosable doing it!MyAutoClosable closed! 通过上面这些你可以看到，不论try-catch中使用的资源是自己创造的还是java内置的类型，try-with-resources都是一个能够确保资源能被正确地关闭的强大方法。 参考资料1、The try-with-resources Statement 转载来自1、https://blog.csdn.net/qq_33543634/article/details/807258992、https://blog.csdn.net/bigtree_3721/article/details/50508985","tags":[]},{"title":"原生WebView长截图 和 Tencent x5webview截长图","date":"2020-10-23T06:02:30.000Z","path":"2020/10/23/原生WebView长截图-和-Tencent-x5webview截长图/","text":"前言： 之前项目用的是原生webview，最近使用公司新框架使用的是x5的webview；正好有需求需要做长截图，踩坑之路开始。 1、原生WebView长截图 Android5.0及以上版本，Android对WebView进行了优化，为了减少内存使用和提高性能，使用WebView加载网页时只绘制显示部分。如果我们不做处理，仍然使用上述代码截图的话，就会出现只截到屏幕内显示的WebView内容，其它部分是空白的情况。这时候，我们通过调用WebView.enableSlowWholeDocumentDraw()方法可以关闭这种优化，但要注意的是，该方法需要在WebView实例被创建前就要调用，否则没有效果。 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; android.webkit.WebView.enableSlowWholeDocumentDraw(); &#125; 1234567891011121314151617181920212223242526272829303132/** * 原生WebView长截图 * * @param webView * @return */ public static Bitmap getWebViewBtpBase64Str(WebView webView) &#123; Bitmap bitmap = null; try &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; Picture snapShot = webView.capturePicture(); bitmap = Bitmap.createBitmap(snapShot.getWidth(), snapShot.getHeight(), Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); snapShot.draw(canvas); &#125; else &#123; float scale = webView.getScale(); //得到缩放后webview内容的高度 int webViewHeight = (int) (webView.getContentHeight() * scale); bitmap = Bitmap.createBitmap(webView.getWidth(), webViewHeight, Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); //绘制 webView.draw(canvas); &#125; return bitmap; &#125; catch (OutOfMemoryError e) &#123; LogEx.e(&quot;ScreenUtils&quot;, e.getMessage(), e); &#125; catch (Exception e) &#123; LogEx.e(&quot;ScreenUtils&quot;, e.getMessage(), e); &#125; finally &#123; &#125; return &quot;&quot;; &#125; 2、Tencent x5webview截长图1234567891011121314151617181920212223/** * Tencent x5webview截长图 * * @param webView * @return */ public static Bitmap getX5WebViewBtpBase64Str(WebView webView) &#123; if (webView == null) &#123; return null; &#125; int wholeWidth = webView.getContentWidth(); int wholeHeight = webView.getContentHeight(); Bitmap x5bitmap = Bitmap.createBitmap(wholeWidth, wholeHeight, Bitmap.Config.RGB_565); Canvas x5canvas = new Canvas(x5bitmap);// x5canvas.scale((float) wholeWidth / (float) webView.getContentWidth(), (float) wholeHeight / (float)webView.getContentHeight()); if (webView.getX5WebViewExtension() == null) &#123; return null; &#125; IX5WebViewExtension ix5WebViewExtension = webView.getX5WebViewExtension(); ix5WebViewExtension.snapshotWholePage(x5canvas, false, false); Bitmap bitmap = Bitmap.createBitmap(x5bitmap); return bitmap; &#125;","tags":[{"name":"Android Webview","slug":"Android-Webview","permalink":"http://example.com/tags/Android-Webview/"}]},{"title":"设置Android studio内存大小防止使用卡顿","date":"2020-10-23T06:01:38.000Z","path":"2020/10/23/设置Android-studio内存大小防止使用卡顿/","text":"前言： 最近开发中发现AS越来越卡，尤其使用CPU Profiler时直接卡死，顿时才想起来自己使用的是重新下载的最新版4.0.1的AS，并没有对其内存设置大小=。= 操作： 在AS的安装目录bin目录下找到studio64.exe.vmoptions文件； 在这里插入图片描述 设置JVM参数 Xms JVM启动的起始堆内存，堆内存是分配给对象的内存。 -Xmx AndroidStudio能使用的最大heap内存 -XX:ReservedCodeCacheSize 设置JIT java compiler在compile的时候的最大代码缓存 -XX:+UseCompressedOops 这个参数允许系统将代码里面的引用(reference)类型用32位存储，同时却能够让引用能够使用64位的内存大小。 -XX:SoftRefLRUPolicyMSPerMB 每兆堆空闲空间中SoftReference的存活时间(ms),越小越好在这里插入图片描述 打开AS，打开Setting，选中Appearance，勾选Show memory indicator；就可以在AS的右下角看到内存实际使用情况； 在这里插入图片描述","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://example.com/tags/Android-Studio/"}]},{"title":"Android studio菜单栏被隐藏解决方案","date":"2020-10-23T06:00:21.000Z","path":"2020/10/23/Android-studio菜单栏被隐藏解决方案/","text":"今天使用android studio 开发项目，在想打开一个新的项目时，发现自己的File菜单栏不见了？？？一顿莫名其妙，不知道自己啥时候无意间点了什么快捷键把菜单栏隐藏了。 问题：android studio菜单栏被隐藏现象：File去哪啦？解决： 点击右边【搜索】按钮； 输入搜索【Main menu】，下面就会出现View|Appearance：Main Menu一栏； 把右侧【OFF】切换到【ON】就ok了。在这里插入图片描述 总结：不要手贱啊！！！","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://example.com/tags/Android-Studio/"}]},{"title":"Android fragment 4种切换方式及对应的生命周期步骤","date":"2020-10-23T05:58:44.000Z","path":"2020/10/23/Android-fragment-4种切换方式及对应的生命周期步骤/","text":"最近做项目使用到fragment切换，要求切换时对fragment页面进行刷新操作。 由于使用的是公司封装好的框架（暂无法改动），框架使用的是add hidden show的方式进行fragment切换，而这种方式切换fragment是不会重新走fragment的生命周期的，导致页面无法刷新。。。于是决定对fragment使用进行学习下 Fragment 1 切换到 Fragment 2时生命周期变化1、通过 add hide show 方式来切换 Fragment Fragment1 的生命周期变化为：onCreate（）、onCreateView、onStart（）、onResume（） 回调onHiddenChanged（） 方法 Fragment2 的生命周期变化为： onCreate（）、onCreateView、onStart（）、onResume（） Fragment 2 再次返回到 Fragment 1：不走任何生命周期方法但是回调 onHiddenChanged（）方法 123456789@Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); if (hidden) &#123; //隐藏时所作的事情 &#125; else &#123; //显示时所作的事情 &#125; &#125; boolean的值代表是否隐藏，当切换到当前fragment时hidden为false，切换到别到fragment时hidden为true。fragment的“显示”“隐藏”监听就这么简单。 总结：当以这种方式进行 Fragment 1 与 Fragment 2 的切换时，Fragment 隐藏的时候并不走 onDestroyView，所有的显示也不会走 onCreateView 方法，所有的 view 都会保存在内存 2、使用 replace 的方法进行切换时 载入Fragment 1时：Fragment1的生命周期：onCreate（）、onCreateView（）、onStart（）、onResume（） 切换到Fragment2时：Fragment1的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 2的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） Fragment 2切换回Fragment 1时：Fragment2的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 1的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） 总结：通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期 3、使用 ViewPager 进行切换时 当使用 ViewPager 与 Fragment 进行切换时，Fragment 会进行预加载操作 所有的 Fragment 都会提前初始—&gt;预加载； 初始化时 Fragment 们的生命周期： Fragment 1 的生命周期：onCreate（）、onCreateView（）Fragment 2 的生命周期：onCreate（）、 onCreateView（） Fragment 1 切换到 Fragment 2 的生命周期： Fragment 1 ：不走任何生命周期；Fragment 2 ：走 setUserVisVleHint（）方法 切回去也是一样的 注意： setUserVisVleHint（）方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法 1234567891011121314151617181920/***第一个 Fragment 需要处理 setUserVisVleHint（）方法，设置为 setUserVisibleHint(true);*否则会产空指针异常，因为 setUserVisVleHint（）方法的优先级高于 onCreate（）方法。** @param savedInstanceState*/@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; setUserVisibleHint(true); super.onActivityCreated(savedInstanceState);&#125; 主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题。setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。此时要对是否调用了onCreateView（）方法进行标记判断。 作者：吾乃韩小呆链接：https://www.jianshu.com/p/c8f34229b6dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 123456789101112131415161718192021222324252627282930313233343536373839/** * 标志位，标志已经初始化完成 */private boolean isPrepared; @Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; // 配置setUserVisibleHint（）方法 setUserVisibleHint(true); super.onActivityCreated(savedInstanceState);&#125; @Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = LayoutInflater.from(getActivity()).inflate(R.layout.fragment_a, container, false); //已经初始化 isPrepared = true; return view;&#125; @Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); //可见的并且是初始化之后才加载 if (isPrepared &amp;&amp; isVisibleToUser) &#123; getList（）； &#125;&#125; 作者：吾乃韩小呆链接：https://www.jianshu.com/p/c8f34229b6dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 4.attach和detach切换 方法和show hide一样，只是把show改为attach，把hide改为detach 从Fragment 1切换到Fragment 2的时候， Fragment 1调用detach()方法，onPause()-&gt;onStop()-&gt;onDestroyView(); Fragment 2 调用attach()方法，onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android命令行装包：卸载之前的包再重新安装新包","date":"2020-10-23T05:57:20.000Z","path":"2020/10/23/Android命令行装包：卸载之前的包再重新安装新包/","text":"Android命令行装包：卸载之前的包再重新安装新包 最近遇到早部分厂商手机（华为、小米、oppo、vivo等）中出现覆盖安装包无法安装现象，具体报错为：*系统已存在**包名的包，请卸载后在安装。然而明明已经是卸载了，还是一直报错无法安装成功，很让人头疼。 adb uninstall “包名” Success adb install -r “新包的路径”.apk","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android scrollview里面放listview 滚动出现的问题：listview展示不全","date":"2020-10-23T05:54:41.000Z","path":"2020/10/23/Android-scrollview里面放listview-滚动出现的问题：listview展示不全/","text":"问题：scrollview中加LinearLayout，然后在LinearLayout中又加了listview；导致listview展示不全，只展示出一条数据。 解决：先写一个工具类 123456789101112131415161718192021222324252627package com.android.fmis.client.util;import android.view.View;import android.view.ViewGroup;import android.widget.ListAdapter;import android.widget.ListView;public class ListHeightUtils &#123; public static void setListViewHeightBasedOnChildren(ListView listView) &#123; ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) &#123; // pre-condition return; &#125; int totalHeight = 0; for (int i = 0; i &lt; listAdapter.getCount(); i++) &#123; View listItem = listAdapter.getView(i, null, listView); listItem.measure(0, 0); totalHeight += listItem.getMeasuredHeight(); &#125; ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); listView.setLayoutParams(params); &#125; &#125; 在listview设置了adapter填充数据后调用此方法，重新设置一下listview的高度，就搞定了。 于此同时会产生一些问题 问题1：scrollview界面出来不是显示的最顶端【滚动条不是在最顶端】， 那么请在 listview填充后 这样设置 ScrollView s=(ScrollView)findViewById(R.id.scrollview1);s.smoothScrollTo(0, 20);","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android 监听应用「进入后台」「回到前台」的几种方式整理","date":"2020-10-23T05:47:45.000Z","path":"2020/10/23/Android-监听应用「进入后台」「回到前台」的几种方式整理/","text":"需求 最近接到一个新的需求：用户把app切换到后台，再次切回到app界面的时候会被要求重新输入登陆密码，这一需求的设计主要是出于安全性考虑。 这里就需要监听app的状态，从而判断app当前处于前台还是后台，再对其做不同的逻辑处理即可。 方案一：利用ActivityLifecycleCallbacks监听所有activity的生命周期 解释下registerActivityLifecycleCallbacks这个方法，只要app中有一个activity的生命周期改变了就会调用registerActivityLifecycleCallbacks的相应方法.比如说splashActivity走了onCreate方法，registerActivityLifecycleCallbacks的onActivityCreated也会被调用，括号中的参数activity就是splashActivity本身 1.在application中注册监听方法，一般写在onCreate方法中 12345678910private int countActivity = 0;//是否进入后台private boolean isBackground = false;@Override public void onCreate() &#123; super.onCreate(); //监听应用进入后台回到前台 initBackgroundCallBack(); &#125; 2.实现监听方法：具体实现onActivityStarted,onActivityStopped方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void initBackgroundCallBack() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; countActivity++; if (countActivity == 1 &amp;&amp; isBackground) &#123; Log.e(&quot;MyApplication&quot;, &quot;onActivityStarted: 应用进入前台&quot;); isBackground = false; //说明应用重新进入了前台 Toast.makeText(MyApplication.this, &quot;应用进入前台&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; countActivity--; if (countActivity &lt;= 0 &amp;&amp; !isBackground) &#123; Log.e(&quot;MyApplication&quot;, &quot;onActivityStarted: 应用进入后台&quot;); isBackground = true; //说明应用进入了后台 Toast.makeText(MyApplication.this, &quot;应用进入后台&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; &#125; &#125;); &#125; countActivity 是为了判断应用是否进入后台，当一个activity的调用onStart方法时countActivity就会+1，调用onStop方法时countActivity就会-1当所有activity的countActivity都=0时，说明所有的activity都在后台，即整个应用都处于后台 isBackground 是为了判断应用是否在后台，如果应用在后台又被调用了onActivityStarted方法，说明应用从后台回到前台 方案二：利用ActivityManager的RunningAppProcessInfo类 ActivityManager在整个系统里面起着非常重要的作用，主要为系统中运行着的activity交互提供接口，其中RunningAppProcessInfo类则封装了正在运行着的进程信息，当然也包含了正在运行的app的包名，因此我们可以activitymanager.getRunningAppProcesses()获取当前运行的app列表，对比自身的包名，来判断本身app是否处于前台运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * App前后台状态 */ public boolean isForeground = false; @Override protected void onResume() &#123; ...... if (isForeground == false) &#123; //由后台切换到前台 isForeground = true; &#125; &#125; @Override protected void onPause() &#123; ...... if (!isAppOnForeground()) &#123; //由前台切换到后台 isForeground = false; &#125; &#125; /** * 判断app是否处于前台 * * @return */ public boolean isAppOnForeground() &#123; ActivityManager activityManager = (ActivityManager) getApplicationContext() .getSystemService(Context.ACTIVITY_SERVICE); String packageName = getApplicationContext().getPackageName(); /** * 获取Android设备中所有正在运行的App */ List&lt;RunningAppProcessInfo&gt; appProcesses = activityManager .getRunningAppProcesses(); if (appProcesses == null) return false; for (RunningAppProcessInfo appProcess : appProcesses) &#123; // The name of the process that this object is associated with. if (appProcess.processName.equals(packageName) &amp;&amp; appProcess.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123; return true; &#125; &#125; return false; &#125; 通过ActivityManager来获取当前运行的app列表，然后判断我们的app是否处于前台，能基本达到我们的预期需求。但如果将上面代码放到每一个activity，或者activity基类里面，这消耗还是挺大的。而且而且，ActivityManager通过.getRunningAppProcesses()获取当前运行列表这个方法，在5.0以后已经被deprecated掉了 参考文献 1.Android 监听APP进入后台或切换到前台方案对比","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android自定义permission android:protectionLevel介绍","date":"2020-10-23T05:44:43.000Z","path":"2020/10/23/Android自定义permission-android-protectionLevel介绍/","text":"Android protectionLevel分4个级别： normal dangerous signature signatureOrSystem 如果定义的是normal或者dangerous：我们自己的应用需要去访问其对应受保护的资源时只需要在androidManifest.xml中添加相同的权限uses-permission 如果是signature：不仅需要添加相同的权限， 必须同时具有相同的签名。 如果是signatureOrSystem（这种权限的应用第三方的应用无法单独访问）：不仅要有相同的签名，而且签名必须是系统签名，此外可能还需要android:sharedUserId=”android.uid.system”。","tags":[{"name":"android:protectionLevel","slug":"android-protectionLevel","permalink":"http://example.com/tags/android-protectionLevel/"}]},{"title":"Android四大组件：BroadcastReceiver","date":"2020-10-23T01:35:41.000Z","path":"2020/10/23/Android四大组件：BroadcastReceiver/","text":"1. 定义 BroadcastReceiver即 广播，是一个全局的监听器，属于Android四大组件之一广播分为两个角色：广播发送者、广播接收者 2. 作用 监听 / 接收 应用 App 发出的广播消息，并 做出响应 3. 应用场景 Android不同组件间的通信（含 ：应用内 / 不同应用之间） 多线程通信 与 Android 系统在特定情况下的通信（如：电话呼入时、网络可用时） 4. 实现原理 在这里插入图片描述 ​— 5. 使用流程 5.1 自定义广播接收者BroadcastReceiver 继承BroadcastReceivre基类 必须复写抽象方法onReceive()方法 1.广播接收器接收到相应广播后，会自动回调 onReceive() 方法2.一般情况下，onReceive方法会涉及 与 其他组件之间的交互，如发送Notification、启动Service等3.默认情况下，广播接收器运行在 UI 线程，因此，onReceive()方法不能执行耗时操作，否则将导致ANR 代码范例 1234567891011// 继承BroadcastReceivre基类public class mBroadcastReceiver extends BroadcastReceiver &#123; // 复写onReceive()方法 // 接收到广播后，则自动调用该方法 @Override public void onReceive(Context context, Intent intent) &#123; //写入接收广播后的操作 &#125;&#125; 5.2 广播接收器注册 注册的方式分为两种：静态注册、动态注册 5.2.1 静态注册 注册方式：在AndroidManifest.xml里通过标签声明 属性说明： 12345678910111213141516171819202122&lt;receiver android:enabled=[&quot;true&quot; | &quot;false&quot;]//此broadcastReceiver能否接收其他App的发出的广播//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false android:exported=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot;//继承BroadcastReceiver子类的类名 android:name=&quot;.mBroadcastReceiver&quot;//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收； android:permission=&quot;string&quot;//BroadcastReceiver运行所处的进程//默认为app的进程，可以指定独立的进程//注：Android四大基本组件都可以通过此属性指定自己的独立进程 android:process=&quot;string&quot; &gt;//用于指定此广播接收器将接收的广播类型//本示例中给出的是用于接收网络状态改变时发出的广播 &lt;intent-filter&gt;&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 注册示例 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=&quot;.mBroadcastReceiver&quot; &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 当此 App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中。 5.2.2 动态注册 注册方式：在代码中调用Context.registerReceiver（）方法 具体代码如下： 12345678910111213141516171819202122232425262728// 选择在Activity生命周期方法中的onResume()中注册@Override protected void onResume()&#123; super.onResume(); // 1. 实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); // 2. 设置接收广播的类型 intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE); // 3. 动态注册：调用Context的registerReceiver（）方法 registerReceiver(mBroadcastReceiver, intentFilter); &#125;// 注册广播后，要在相应位置记得销毁广播// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 @Override protected void onPause() &#123; super.onPause(); //销毁在onResume()方法中的广播 unregisterReceiver(mBroadcastReceiver); &#125;&#125; 特别注意 动态广播最好在Activity 的 onResume()注册、onPause()注销。 对于动态广播，有注册就必然得有注销，否则会导致内存泄露。 5.2.3 两种注册方式的区别 在这里插入图片描述5.3 广播发送者向AMS发送广播 5.3.1 广播的发送 广播 是 用”意图（Intent）“标识 定义广播的本质 = 定义广播所具备的“意图（Intent）” 广播发送 = 广播发送者 将此广播的“意图（Intent）”通过sendBroadcast（）方法发送出去 5.3.2 广播的类型 广播的类型主要分为5类： 普通广播（Normal Broadcast） 系统广播（System Broadcast） 有序广播（Ordered Broadcast） 粘性广播（Sticky Broadcast） App应用内广播（Local Broadcast） 1. 普通广播（Normal Broadcast） 即 开发者自身定义 intent的广播（最常用）。发送广播使用如下： 12345Intent intent = new Intent();//对应BroadcastReceiver中intentFilter的actionintent.setAction(BROADCAST_ACTION);//发送广播sendBroadcast(intent); 若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。如下mBroadcastReceiver则会接收上述广播 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=&quot;.mBroadcastReceiver&quot; &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name=&quot;BROADCAST_ACTION&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 若发送广播有相应权限，那么广播接收者也需要相应权限 ​ 2. 系统广播（System Broadcast） 3.有序广播（Ordered Broadcast） 4.App应用内广播（Local Broadcast） 2.3.4.类型的广播用法详见： Android四大组件：BroadcastReceiver史上最全面解析","tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Hello World","date":"2020-10-22T07:38:46.973Z","path":"2020/10/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]